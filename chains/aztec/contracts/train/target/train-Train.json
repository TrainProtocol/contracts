{
  "transpiled": true,
  "noir_version": "1.0.0-beta.4+0000000000000000000000000000000000000000",
  "name": "Train",
  "functions": [
    {
      "name": "refund_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3564161243949231814": {
            "error_kind": "string",
            "string": "Function refund_public can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "9323748002447105156": {
            "error_kind": "string",
            "string": "NotPassedTimelock"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "refund_public"
      ]
    },
    {
      "name": "redeem_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "ownership_key",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "get_htlc_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "view",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "key",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "Train::HTLC_Public",
            "fields": [
              {
                "name": "src_receiver",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "amount",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "token",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "hashlock_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "hashlock_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "secret_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "secret_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "ownership_hash_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "ownership_hash_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "timelock",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "claimed",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "9174444391250494040": {
            "error_kind": "string",
            "string": "Function get_htlc_public can only be called statically"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_htlc_public"
      ]
    },
    {
      "name": "add_lock_private_user",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17476367995570638746": {
            "error_kind": "string",
            "string": "NoAllowance"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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Xvj6V174+lde+PpXXvj6V174+lde+PpXXvj6V174+lde+PpXXvj6V174+lde+PpXXvj6V174+lde+PpXXvj6V174+lde+PpXXvj6V174+lde+PpXXvj6V174+lde+PpXXvj6V174+lde+PpXXvj6V174+lde+PpXXvj6V174+lde+PpXXvj6V174+lde+PpXXvj6V174+lde+PpXXvj6V174+lde+PpXXvj6V174+lde+PpXXvj6V174+lde+PpXXvj6V174+lde+PpXXvj6V174+lckfP0rEr7+FQlf/4qEr39FRvb8S8LXvyLh61/R9OtfPX46pmKf+3908NbrmOPjh7P/GOvsczXnWGef1xnHOv0aXJxjnT1feGus0W3Hxnww1tlzC86xzp6HcI6VFI119vyGc6yz50KcY10qb6qMdam8qTLWpfKm12Odfe20UELec6HkX4/19iTJbz9diJ5++sPpzL7SGvNoJ8+dmEc7efbEPFpSNdrJMyjm0U6eQzGPdvIsKrm8/XRKprwerU1m+2mb4uNg6w9Bmg3NrVhTObbOcfIMTQzHybM/KRynXxXQmL3KZnz87z9WxWdfFfDpLpyyrcRBiLQ9AgjPt+xfan09Otu0/fTtlx9oXHYfbORklv3ZyMlD+7MhsDllIyfH7c9GTkbcn83k+fNQNpPnxEPZTJXn/u7SXAtZ3rs0VRZ479JUyde9S1PlPPcu0XxdmmqGv3dpqon13qWp5rN7l6aaRu5dmu/uPdcyiPcuzXf3nmuxwnuX5rt7z7Wk4L1L892951r4796l+e7ecy3Pd+/SfHfvuRbRu3dpvrv3XEvd3bs03917rgXp7l2a7+4917Jx9y7Nd/eea3G3e5fmu3vPtQTbvUvz3b3nWijt3qX57t5zLWd279J8d++5Fh27d2m+u/dcS4PduzTf3XuuBbzuXZrv7j3XMlv3Ls13955rMax7l+a7e8+1ZNW9S/PdvedaWOrepfnu3nMt/3Tv0nx377kWabp3ab6791xLKd27NN/de64Fj+5dmu/uPdeyRPcuTXf3DnMtHnTv0nR37zDXEj/3Lk139w5murt3mGttnXuXprt7h7lWwLl3abq7d5hrPZnfXZpr2Zd7l+a7e8+1iMq9S/PdvedakuTepfnu3nMt8HHv0nx377mWy7h3ab6791yLT9y7NN/de65lHO5d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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "is_contract_initialized",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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OV1bXdUIq/D3nK6trmqE1eF7TtdWVzXCquU9p2urq1ptdVWrra5qjbama6urWm11Vautrmq11VWttrqqEb5i0XO6trqqEb440XO6trqqub4j0Z6ura5qru9ItKdrq6ua6zsS7ena6qom+zJEc7q2uqrJvt7QnK6trmqyLyw0p2urq5rsKwjN6drqqib7UkFzura6qsm+JtCcrq2uarKvCTSna6urmuxrAs3p2uqqZvuaQGu6trqq2Vbnb03XVFcVZ1vtvjVdU11VnG31+NZ0TXVVcYm2pmuqq4qzrW7emq6prirOtlp4a7q2uipnq6tytroqW2urR1trq0dba6tHW2urR1trq0dba6tHW2urR1trq0dba6tHW2urR1trq8fZ1lb/2HeO1m1btyz+28Z3jhGOXTjyTcI+HPkoYR+OfJWwD0c+S9iF42xL0L/meJ+umc9336dr5jPb9+maaT7v0422pmumlbtP10zHdZ+umcboPl0z/ct9umY+f/zXdGdbgr41XVtd1WxL0Lema6urmm0J+tZ0bXVVsy1B35qura5qtiXoW9O11VXNtgR9a7q2uqrZlqBvTddWVzXbEvSt6drqqmZbgr41XVtd1WxL0Lema6urmm0J+tZ0bXVVsy1B35qura5qtiXoW9O11VXNtgR9a7q2uqrZlqBvTddWVzXbEvSt6drqqmZbgr41XVtd1WxL0Lema6urmm0J+tZ0bXVVsy1B35qura5qtiXoW9O11VXNtgR9a7q2uqrZlqBvTddWVzXbEvSt6drqqmZbgr41XVtd1WxL0Lema6urmm0J+tZ0bXVVsy1B35qura5qtiXoW9O11VXNtgR9a7qmuqo02xL0rema6qrSbEvQt6ZrqqtKS7Q1XVNdVZptCfrWdE11VWm2Jehb07XVVc22BH1rura6qtmWoG9N11ZXNdsS9K3p2uqqZluCvjVdW13VbEvQt6Zrq6uabQn61nRtdVWzLUHfmq6trsrOSvH36drqquysu36frq2uys4q5vfp2uqqbK2tnmytrZ5sra2eJltbfQ11m275dfC3f/qPPrhQthnW+n3bO8YIxh4Y5+oCxTDO1V1+DuP7r6ikyRavl+M4Vz8sx3GuRluM42Tr+MtxnMsayHGcy3OU/U/HElsc8xq+Ns75McPov8jMZU96komQeUFmLhPxhsx9unM1+83pztWT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n2ixMtE6z0TLtu36dMZtE+2xzLWaiW6/NsrLT0V7rEM9xkQ7tIPR1cdEfWOiadkvj2mJ+Xmi9wEFbQOK2gaUtA1o1TagrG1ARduAqrIB9VhwtO+AnLYBabtSJ21X6qTtSp20XamTtit10nalTtqu1EnblXrVdqVetV2pV21X6vXqK3WstewDSvXf3rqZmOpmruMal5+jj0OPPg09+nXo0eehR1+GHn0defR5GXr0bujR+6FHP9C9Nvwc/UD32oPRD3SvPRj9QPfag9EPdK89GP1A99qfoy+9rzlrY/Qu7k8rXAzl/ejXJW5/el3q8n5jd9ti2/r277T+nGy0NNlkabKrpclmS5MtliZbp51s/THZuliarLM0WW9psvN2UAeTjXYmG1/9Un8pLyZ738uf2iuc2cvu7xvCEr429sG5b1v/Rcbu7xuaZMz+vqFJxuzvG3ypO5nFH5Ax+/uGJpkImRdkzP6+oUnG7O8bmmTM/sa3Scbsb3ybZOyuP9EgE+2uP9EiY3f9iRYZOr1XZPjuZheXFfnuZh+OfHezD0e+u9nl+pj47mYfjnx3sw9HD8cuHAMcu3CMcOzCMcGxC0f8TB+O+Jk+HPEzfTjiZ7pwXJX3j2++6fhz65jrNuzbPx8jCSl+zVZ5l/dnsy17jd3+WQ9mG6earQ/7bIM/mK3yjqnzbJX3NZ1nq7z76Dxb5T1C59kqv5P3nW1Wnh/+4Wz311ZvE18OZqs85es826l6qeZs5+qlWrONpmY7Vy/Vmu1cvVRrtnP1Uo3ZlsM7UNzf3YjxyZzXcjjZxyql/tu29wMcXvSj2z16jI0DyH3VKB7/LnqUwceRB59GHvw68uDzyIMvIw++Djz449/xjjJ4N/LgR77D1pHvsHXkO2wd+Q5bR77D1pHvsHXkO2wd+A6bloHvsGkZ+A6bloHvsGkZ+A6bFs132Ma7A2nRfIdtDl7zHbY5eM132ObgNd9hm4PXfIdtDd5pvsM2B6/5DtscvOY7bHPwmu+wzcGPfId1I99h3ch3WDfyHdaNfId1I99h/ch3WD/yHdaPfIf1I99h/ch3WD/yHdaPfIf1I99h/ch3WD/yHTaMfIcNI99hw8h32DDyHTZovsPm/dN6PoflYPCa77DNwWu+wzYHr/kO2xy85jtsc/Ca77CtwUfNd9jm4DXfYZuD13yHbQ5e8x22Ofjj63zeV9WK2T0GtL1dno5XeWvvdnxty+s+o5zdwW711G7HS1a1fqmWjldoau92XMON9/TT8fo77d3iud3Sud3Wc7vlc7uVc7vVU7uty7nd3Lnd/rxK/u32X/+//+F//st/+I//+l/+122nX//v//lv/+l//8t//29f//V////+x/b//Mf/+S//+q//8l///f/4n//9P/2X//x//ud/+ff/+t//06//75+Wr//4f/Lq3D/nNfjbgH5N4jao9M8llXD777+KMaeab///kn/9/792iKWs/xxLdb/+B/fXX4jltkVabmO7je//Dw==",
      "brillig_names": [
        "is_contract_initialized"
      ]
    },
    {
      "name": "redeem_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "ownership_key",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "772057049813214347": {
            "error_kind": "string",
            "string": "HTLCNotExists"
          },
          "2570651705007895968": {
            "error_kind": "string",
            "string": "HashlockNotMatch"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6012086182631426650": {
            "error_kind": "string",
            "string": "NotAnOwner"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17814817983036354427": {
            "error_kind": "string",
            "string": "Function redeem_public can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "redeem_public"
      ]
    },
    {
      "name": "commit_public_user",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_receiver",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3559210201980528457": {
            "error_kind": "string",
            "string": "Function commit_public_user can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "10870837545714573535": {
            "error_kind": "string",
            "string": "HTLCAlreadyExists"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "commit_public_user"
      ]
    },
    {
      "name": "refund_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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qGRb0s/kbH+cdrSUL9NGIbdw8lDhnPWKe4VjxgrHjhWOGyscGiscP1Y4Yaxw4ljhjHVXTmPdlfNYd+U81l05j3VXzmPdlfNYd+U81l05t74rv9zj6hZPHCyeNFg8eah47LIMFo8ZLJ7jBdRvhf33adYaX4jn1g9YtvBD/OvqBbeLuBYXoRYX8SwXceFxkeB2Fzn4Ii+5dWEgt+zXfVqOl1NdtjXXFvf49j4v3/GHweP3G//gnXuOPwqPPwmPP8uO//jFB0HxG+HxW+HxO+Hxk/D4R59/S/ELn3+N8PnXCJ9/jfD51wqff63w+dcKn3+t8PnXCp9/rfD51wqff63w+dcKn3+t8PnXCZ9/nfD51wmff53w+dcJn3+d8PnXCZ9/nfD51wmff53w+ZeEz78kfP4l4fMvCZ9/Sfj8S8LnXxI+/5Lw+ZeEz78kfP71wudfL3z+9cLnXy98/vXC518vfP71wudfL3z+9cLnXy98/g3C598gfP4NwuffIHz+DcLn3yB8/g3C598gfP4NwuffIHz+jcLn3yh8/o3C598ofP49XjhDUPzC598ofP6NwuffKHz+jcLn3yR8/k3C598kfP5NwuffJHz+TcLn3yR8/k3C598kfP5NwuffLHz+zcLn3yx8/s3C598sfP7NwuffLHz+zcLn3yx8/s2y51+3yJ5/3SJ7/nWL7PnXLbLnX7fInn/d8OtfleKXPf864etfOeHrXznh61854etfOeHrXznh61854etfOeHrXznh61854etfOeHrXznh61854etfOeHrXznh61854etfOeHrXznh61854etfOeHrXznh61854etfOeHrXznh61854etfOeHrXznh61854etfOeHrXznh61854etfOeHrXznh61854etfOeHrXznh61854etfOeHrXznh61854etfOeHrXznh61854etfOeHrXznh61854etfOeHrXznh61854etfOeHrXznh61854etfOeHrXznh61854etfOeHrXznh61854etfOeHrXznh61854etfOeHrXznh61854etfOeHrXznh61854etfOeHrXznh61854etfOeHrXznh61854etfOeHrXznh61854etfOeHrXznh61854etfOeHrXznh61854etfOeHrXznh61854etfOeHrXznh61854etfOeHrXznh6185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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "get_note_internal",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "call_private_function_internal",
        "load",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "lock_public_solver",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "ownership_hash",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "10870837545714573535": {
            "error_kind": "string",
            "string": "HTLCAlreadyExists"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "15001264570739363109": {
            "error_kind": "string",
            "string": "Function lock_public_solver can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "lock_public_solver"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "772057049813214347": {
            "error_kind": "string",
            "string": "HTLCNotExists"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2570651705007895968": {
            "error_kind": "string",
            "string": "HashlockNotMatch"
          },
          "2722406262643068352": {
            "error_kind": "string",
            "string": "HashlockAlreadySet"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3559210201980528457": {
            "error_kind": "string",
            "string": "Function commit_public_user can only be called internally"
          },
          "3564161243949231814": {
            "error_kind": "string",
            "string": "Function refund_public can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6012086182631426650": {
            "error_kind": "string",
            "string": "NotAnOwner"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "9174444391250494040": {
            "error_kind": "string",
            "string": "Function get_htlc_public can only be called statically"
          },
          "9323748002447105156": {
            "error_kind": "string",
            "string": "NotPassedTimelock"
          },
          "10870837545714573535": {
            "error_kind": "string",
            "string": "HTLCAlreadyExists"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "15001264570739363109": {
            "error_kind": "string",
            "string": "Function lock_public_solver can only be called internally"
          },
          "16870384257694633552": {
            "error_kind": "string",
            "string": "Function add_lock_public_user can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17814817983036354427": {
            "error_kind": "string",
            "string": "Function redeem_public can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [
        "aztec::macros::functions::utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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uezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt257NWdy17duezVvche6/6GoavR/dztVfa6L+nnavXfdjtayrfTh0Juw3G6huN1DSfoGk7UNZykazirruFkXcMpuoZTVQ2n6roqV11X5arrqlx1XZWrrqty1XVVrrquylXXVblefVV++42r23iqqvH4ZVE2HqdsPF7ZeIKy8Rxem/3N9nzt5r1LjfHc0ofHh5TX/PerF9wOkq44yHrFQXKXg4T1cZA1PB3k4Bd5JWwLA4Xled2n5Xg51WVfc20JT1+0Xr7GX5SPP+381xTCz/HXscd//Jh/oPG7wcfvBx9/GHz8cfDxp8HHvw4+fu3339b4B7//usHvv37w+68f/P7rB7//+sHvv37w+68f/P7rB7//+sHvv37w+68f/P4bBr//hsHvv2Hw+28Y/P4bBr//hsHvv2Hw+28Y/P4bBr//hsHvv3Hw+28c/P4bB7//xsHvv3Hw+28c/P4bB7//xsHvv3Hw+28c/P6bBr//psHvv2nw+28a/P6bBr//psHvv2nw+28a/P6bBr//psHvv+vg99918PvvOvj9dx38/rsOfv9dB7//roPff9fB77/r4PffdfD7bx78/psHv//mwe+/efD7bx78/psHv//mwe+/efD7bx78/psHv/+Wwe+/ZfD7bxn8/lsGv/+Wwe+/ZfD7bxn8/lsGv/+Wwe+/ZfD7bx38/lsHv//Wwe+/dfD7bx38/lsHv//Wwe+/dfD7bx38/lvHvv+GZez7b1jGvv+GZez7b1jGvv+GZez7b1jGvv+GZez7b1C//lVr/GPff8Pg61+Fwde/CoOvfxUGX/8qDL7+VRh8/asw+PpXYfD1r8Lg61+Fwde/CoOvfxUGX/8qDL7+VRh8/asw+PpXYfD1r8Lg61+Fwde/CoOvfxUGX/8qDL7+VRh8/asw+PpXYfD1r8Lg61+Fwde/CoOvfxUGX/8qDL7+VRh8/asw+PpXYfD1r8Lg61+Fwde/CoOvfxUGX/8q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xRlfrjjjyxVnfLnijK9XnPH1ijO+XnHG1yvO+HrFGV+vOOPrFWd8veKMr1ec8fWCM74syxUHcVccxF9xkHDFQeIVB0lXHGS94iD5ioOUKw5yxRnvrjjj3RVnvLvijL/i1avirjjj3RVnvLvijHdXnPHuijP+infuyhXv3JUr3rkrV7xzV654565c8c5dueKdu3LFO3flinfuyhXv3JUr3rkrV7xzV654565c8c5dueKdu3LFO3flinfuyhXv3JUr3rkrV7xzV654565c8c5dueKdu3LFO3flinfuyhXv3JUr3rkrV7xzV654565c8c5dueKdu3LFO3flinfuyhXv3JUr3rkrV7xzV654565c8c5dueKdu3LFO3flinfuyhXv3JUr3rkrV7xzV654565c8c5dueKdu3LFO3flinfuyhXv3JUr3rkrV7xzV654565c8c5dueKdu3LFO3flinfuSo937sJS96WyvWttnbcB5ccP6GP4Gk1WNZqiajRV02h6vBfYcTRO1Wi8qtEEVaOJqkaTVI1G1bW4qLoWF1XX4qLqWlxVXYurqmtxVXUtrqquxVXVtbhquhbX45f8XAjbIk0uPH3kpRyt/xTDY3nRp6HE8nWE+PEjpI8fYf34EfLHj1A+foT6l4+QHmfBenCE4/f5uh7B/fUj5GU/k+vBEfzHj/DXz+lUN6XXJRwcIX78CKnnEZ4+UPM4wvrxI+SPH+Gvn9NrdtsRynJwhPrpI/i/fk6vZVuhe63x4Aju40f46+d03j/Dll05OEL4+BFizyP49eAI6eNHWD9+hL9+Tj/Wky/LUS2Vjx/hr5/TZadUjmopLB8/wl8/p0vYFqQu0R8cwX/8CKHnEdLBtTXEjx8hffwIf/2cvt2Jv7atR+d0yB8/wl8/p28Vvx0hHnQCoX76CPGvn9N1773rekApuo8fwfc8Qj64tsbw8SPEjx/hr5/TbkmbRXHLenBWx/WCYxyf19Fvd0cX8/r+GMGV7RjBPX38xa/xMJZZtz8dlidnFv54Ivlz67xszX3IT2fcH1vfx18GH38de/zHbx0ONH43+Pj94OMPg48/Dj7+NPj418HHP/j9Nw1+/02D33/Xwe+/6+D333Xw++86+P13Hfz+uw5+/10Hv/+ug99/18Hvv+vg9988+P03D37/zYPff/Pg9988+P03D37/zdfff/3+K5I/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",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "commit_private_user",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_receiver",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6418028854678020178": {
            "error_kind": "string",
            "string": "FundsNotSent"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "random",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "lock_private_solver",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "ownership_hash",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6418028854678020178": {
            "error_kind": "string",
            "string": "FundsNotSent"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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0swa32FP/3Ztzdv7PyK9/yPyuz9im6b3f0R4/0fE93+Exn7y9A+ztkne/xHL+z9ifffGu03b+z8ivf8j8ts/Ikzv/4jw/o+I7/+I+f0fIe//iMOiXZZbarqkx05v+npRvvCi45uJZy86LpVp22f1z7/zv3QkW+E217TlvYWdUlh/vGy+9jK59rLl2suOvyynNM/3lz0cwn572XbtZenay/Kll80F3fL9OPopr+HHywokc7odSx/CNP0gOa/XXrZde1m+NLfju1jnLyssnJznh0EuP14Wr71svvYyufay5drL1msv26697HjhfFya7y+Lj1XyH35fU8fnaSl/yPE9PO0PCX//Ic/vRW7Hdwh1P2J+/0fIbz/i82XLtZet11527SuycH/u9GX50svW6drLwrWXxWsvm6+9TK697NpGul7bSAu3Oj5W0e1VH5fce8LpqL2NH0b+6+r40fb9+Ijw/o+I7/+I+f0fIe//iOX9H7G+/yO2939Eev9H5Ld/RHr/6k7vX93p/as7vX91p/ev7vT+1Z3ev7rT+1d3ev/qTu9f3fnXq/vzZeHay+K1l83XXibXXrZce9l67WXbtZelay/LV16Wpunay8K1l8VrL5uvvUyuvWy59rL12su2ay9L1152rUrCtSoJ16okXKuScK1KwrUqCdeqJFyrknCtSsK1KgnXqiReq5J4rUritSqJ16okXquSeK1K4rUqideqJF6rknitSuZrVTJfq5L5WpXM16pkvlYl87Uqma9VyXytSuZrVTJfqxK5ViVyrUrkWpXItSqRa1Ui16pErlWJXKsSuVYlcq1KlmtVslyrkuValSzXqmS5ViXLtSpZrlXJcq1KlmtVslyrkvValazXqmS9ViXrtSpZr1XJeq1K1mtVsl6rkvValazXqmS7ViXbtSrZrlXJdq1KtmtVsl2rku1alWzXqmS7ViXbtSpJ16okXauSdK1K0rUqSdeqJF2rknStStK1KknXqiRdq5Jr2Wu6lr2ma9lrupa9pmvZa7qWvaZr2Wu6lr2ma9lrupa95mvZa76WveZr2Wu+lr3ma9lrvpa95mvZa76WveZr2Wu+lr3ma9lrvpa95mvZa76WveZr2Wu+lr3ma9lrvpa95mvZa76WveZr2Wu+lr3ma9lrvpa95mvZa76WveZr2Wu+lr3ma9lrvpa95mvZa76WveZr2Wu+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re/15bJVAHIpu2Nqwzc2fD1cn+3C9vFQSLtz88l+WVovmL+HpPOQfB5STkK+WIhfj9bjvOjXVCib3dHm/nHRbTwPSech+TyknIYcnAr7FlKdTfK2v5x31dkV4s5D/HkInYeE85B4HpLOQ6rq50zPcf0LpPJqSVynD797weUrvfxfR4e7dfv5enDY7+ftZ3/effbn/Wd/nj778+GzPx87/nz2Lz+fPvvz+bM/X48T3PoCRPHpb+eRg7ThLcSeh7jzEH8eQuch4TwknoYcxIlvIfk85Lz66bz66bz66bz6B/e2bBHvEnr/bec/uLflLSSch9Rv7UlryuzKy6is70m+h+TzkHIaUt+KfA+xJyF/Lf/5f//+P//l7//hX//5/yyQr//1v//tH//rX/79377/87/+33+s/8s//Oe//Ou//sv//rv/+M9//8d//qf//s9//rt//fd//Prf/of5/n//M3lLP5L3YTHmy5YcYvqRQ/76768+k75egk2ulK///QtAIZkfy//7CfhCpBjyjxSj+Rnjf/3uF867H+RWTLA/Qvz6n39eN/jzn5z94X7+k9/+ycYfzn79E60/4vIPn7eG6QeVr/85vCLi83fph/v5VHr+U/rh3dc/5Sew/HD09U9l5eHrbqWl3vHtdVw82hp2X80s7Xz7u1Sql/9MP73daPy6zsgV+oYH82OhY4WH5fnHf/6Exy/P/U+4XeF2Ka3Z5R8fcGvtD/to8Of/uBTr7NLg9w8slf0fS0r1vL7xT37APx1YnCxphZT8wxq/2bz8pzdmlwb//Nm08PBMb49Vt0954sLM1nPy0tMWrf5aevX/Bw==",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "random",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "add_lock_public_user",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2722406262643068352": {
            "error_kind": "string",
            "string": "HashlockAlreadySet"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16870384257694633552": {
            "error_kind": "string",
            "string": "Function add_lock_public_user can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "add_lock_public_user"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "HTLC_Private"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Train"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "contracts_private",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "contracts_public",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "ownership_hash",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::lock_public_solver_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::lock_public_solver_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "ownership_key",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::redeem_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::redeem_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "key",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::get_htlc_public_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "hashlock_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "hashlock_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_hash_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_hash_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "claimed",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::HTLC_Public"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::get_htlc_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::add_lock_private_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::add_lock_private_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::add_lock_public_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::add_lock_public_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_hash",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::lock_private_solver_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::lock_private_solver_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Train::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::commit_private_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::commit_private_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::refund_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::refund_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::refund_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::refund_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "ownership_key",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::redeem_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::redeem_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  },
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::commit_public_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::commit_public_user_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "101": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "103": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "104": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "105": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "107": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_notes},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncNotes` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_notes(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "108": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "109": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "110": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "117": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/logs/note.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    messages::{\n        encoding::encode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        logs::utils::prefix_with_tag,\n        msg_type::{PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID},\n    },\n    note::{note_emission::NoteEmission, note_interface::NoteType},\n};\nuse protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n    traits::Packable,\n};\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists<let N: u32>(context: PrivateContext, note_hash_counter: u32) {\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\npub fn compute_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PRIVATE_NOTE_MSG_TYPE_ID,\n    )\n}\n\npub fn compute_partial_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID,\n    )\n}\n\nfn compute_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    msg_type: u64,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let packed_note = note.pack();\n\n    // A note message's content is the storage slot followed by the packed note representation\n    let mut msg_content: [Field; N + 1] = std::mem::zeroed();\n    msg_content[0] = storage_slot;\n    for i in 0..packed_note.len() {\n        msg_content[1 + i] = packed_note[i];\n    }\n\n    // Notes use the note type id for metadata\n    let plaintext = encode_message(msg_type, Note::get_id() as u64, msg_content);\n\n    let ciphertext = AES128::encrypt_log(plaintext, recipient);\n\n    let log = prefix_with_tag(ciphertext, sender, recipient);\n\n    log\n}\n\npub unconstrained fn compute_note_log_unconstrained<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_note_log(note, storage_slot, recipient, sender)\n}\n\n/// Sends an encrypted message to `recipient` with the content of the note, which they will discover when processing\n/// private logs.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n        assert_note_exists(*context, note_hash_counter);\n\n        let encrypted_log = compute_note_log(note, storage_slot, recipient, sender);\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note`, except encryption is unconstrained. This means that the sender is free to make\n/// the log contents be whatever they wish, potentially resulting in scenarios in which the recipient is unable to\n/// decrypt and process the payload, **leading to the note being lost**.\n///\n/// Only use this function in scenarios where the recipient not receiving the note is an acceptable outcome.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log =\n            unsafe { compute_note_log_unconstrained(note, storage_slot, recipient, sender) };\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n"
    },
    "118": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/logs/utils.nr",
      "source": "use crate::{\n    oracle::notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n    prelude::AztecAddress,\n};\n\npub(crate) fn prefix_with_tag<let L: u32>(\n    log_without_tag: [Field; L],\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> [Field; L + 1] {\n    // Safety: we assume that the sender wants for the recipient to find the tagged note, and therefore that they will\n    // cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the\n    // note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut log_with_tag = [0; L + 1];\n\n    log_with_tag[0] = tag;\n    for i in 0..log_without_tag.len() {\n        log_with_tag[i + 1] = log_without_tag[i];\n    }\n\n    log_with_tag\n}\n\nmod test {\n    use super::prefix_with_tag;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn prefixing_with_tag() {\n        let sender = AztecAddress::from_field(1);\n        let recipient = AztecAddress::from_field(2);\n\n        let app_tagging_secret = 42;\n        let index = 5;\n\n        // I am using the deserialize trait instead of directly instantiating the IndexedTaggingSecret struct because\n        // direct instantiation functionality is not exposed.\n        let indexed_tagging_secret = IndexedTaggingSecret::deserialize([app_tagging_secret, index]);\n\n        // Mock the tagging oracles\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(indexed_tagging_secret);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let log_without_tag = [1, 2, 3];\n        let log_with_tag = prefix_with_tag(log_without_tag, sender, recipient);\n\n        let expected_result = [indexed_tagging_secret.compute_tag(recipient), 1, 2, 3];\n\n        // Check tag was prefixed correctly\n        assert_eq(log_with_tag, expected_result, \"Tag was not prefixed correctly\");\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "123": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "125": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n    pub storage_slot: Field,\n    pub note_hash_counter: u32, // a note_hash_counter of 0 means settled\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note, storage_slot: Field, note_hash_counter: u32) -> Self {\n        Self { note, storage_slot, note_hash_counter }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "128": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n    retrieved_note::RetrievedNote,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::{array, comparison::compare};\nuse dep::protocol_types::{\n    constants::{GET_NOTES_ORACLE_RETURN_LENGTH, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL},\n    traits::{Packable, ToField},\n};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_fields,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. nonce, note hash, etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "131": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "134": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "137": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "138": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "139": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "140": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "141": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "142": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "146": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "147": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "148": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "149": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "150": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_notes(pending_tagged_log_array_base_slot: Field) {\n    sync_notes_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "152": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::IndexedTaggingSecret,\n    traits::{FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {\n    // This wrapper exists to extract the ORACLE_RETURN_FIELD_LENGTH generic numeric param into a value and pass it to\n    // the oracle, so that it knows how big the return array must be.\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        ORACLE_RETURN_FIELD_LENGTH,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let MAX_NOTES: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    _placeholder_fields: [Field; ORACLE_RETURN_FIELD_LENGTH], // TODO: Compute this value automatically from MAX_NOTES\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields: [_; ORACLE_RETURN_FIELD_LENGTH] = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n\n    let mut opt_notes = [Option::none(); MAX_NOTES];\n    for i in 0..opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "153": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "154": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "155": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "157": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "159": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr",
      "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\nuse crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    lifecycle::create_note,\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_notes},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context, let N: u32> Storage<N> for PrivateImmutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor.\n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: NoteType + NoteHash + Packable<N>,\n    {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> Note\n    where\n        Note: NoteType + NoteHash + Packable<N>,\n    {\n        let storage_slot = self.storage_slot;\n        let retrieved_note = get_note(self.context, storage_slot).0;\n\n        // Because the notes obtained from PrivateImmutable are not meant to be nullified and get_note(...) function\n        // has already constrained the note (by pushing a read request to the context), we can return just the note\n        // and skip the additional data in RetrievedNote.\n        retrieved_note.note\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:is_initialized\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note\n    where\n        Note: Packable<N>,\n    {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "168": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable.nr",
      "source": "use dep::protocol_types::{\n    shared_mutable::{\n        ScheduledDelayChange,\n        ScheduledValueChange,\n        shared_mutable_values::{unpack_delay_change, unpack_value_change},\n        SharedMutableValues,\n    },\n    traits::Packable,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\n\nmod test;\n\npub struct SharedMutable<T, let INITIAL_DELAY: u32, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Packable and Eq traits, and allocate `M` storage\n// slots to this state variable.\nimpl<T, let INITIAL_DELAY: u32, Context, let M: u32> Storage<M> for SharedMutable<T, INITIAL_DELAY, Context>\nwhere\n    WithHash<SharedMutableValues<T, INITIAL_DELAY>, _>: Packable<M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let INITIAL_DELAY: u32, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PublicContext>\nwhere\n    T: Eq,\n{\n\n    pub fn schedule_value_change<let N: u32>(self, new_value: T)\n    where\n        T: Packable<N>,\n    {\n        let _value_change = self.schedule_and_return_value_change(new_value);\n    }\n\n    pub fn schedule_and_return_value_change<let N: u32>(\n        self,\n        new_value: T,\n    ) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n\n        value_change\n    }\n\n    pub fn schedule_delay_change<let N: u32>(self, new_delay: u32)\n    where\n        T: Packable<N>,\n    {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay<let N: u32>(self) -> u32\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value<let N: u32>(self) -> (T, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay<let N: u32>(self) -> (u32, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change<let N: u32>(self) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        // We don't read ScheduledValueChange directly by having it implement Packable because ScheduledValueChange\n        // and ScheduledDelayChange are packed together (sdc and svc.block_of_change are stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_value_change::<T, N>(packed)\n    }\n\n    fn read_delay_change<let N: u32>(self) -> ScheduledDelayChange<INITIAL_DELAY>\n    where\n        T: Packable<N>,\n    {\n        // Since all ScheduledDelayChange member are packed into a single field, we can read a single storage slot\n        // here and skip the ones that correspond to ScheduledValueChange members. We are abusing the fact that\n        // the field containing the ScheduledDelayChange data is the first one in the storage layout - otherwise we'd\n        // need to offset the storage slot to get the position where it'd land.\n        // We don't read ScheduledDelayChange directly by having it implement Packable because\n        // ScheduledValueChange and ScheduledDelayChange are packed together (sdc and svc.block_of_change are\n        // stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_delay_change::<INITIAL_DELAY>(packed)\n    }\n\n    fn write<let N: u32>(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>,\n    )\n    where\n        T: Packable<N>,\n    {\n        // Whenever we write to public storage, we write both the value change and delay change to storage at once.\n        // We do so by wrapping them in a single struct (`SharedMutableValues`). Then we wrap the resulting struct in\n        // `WithHash`.\n        // Wrapping in `WithHash` makes for more costly writes but it also makes private proofs much simpler because\n        // they only need to produce a historical proof for the hash, which results in a single inclusion proof (as\n        // opposed to 4 in the best case scenario in which T is a single field). Private shared mutable reads are\n        // assumed to be much more frequent than public writes, so this tradeoff makes sense.\n        let values = WithHash::new(SharedMutableValues::new(value_change, delay_change));\n\n        self.context.storage_write(self.storage_slot, values);\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext>\nwhere\n    T: Eq,\n{\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n        let (value_change, delay_change, historical_block_number) =\n            self.historical_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay =\n            delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon =\n            value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n\n    fn historical_read_from_public_storage<let N: u32>(\n        self,\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32)\n    where\n        T: Packable<N>,\n    {\n        let header = self.context.get_block_header();\n        let address = self.context.this_address();\n\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        let values: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::historical_public_storage_read(header, address, self.storage_slot);\n\n        (values.svc, values.sdc, historical_block_number)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, UtilityContext>\nwhere\n    T: Eq,\n{\n    pub unconstrained fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let smv: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::utility_public_storage_read(self.context, self.storage_slot);\n\n        let block_number = self.context.block_number() as u32;\n        smv.svc.get_current_at(block_number)\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "180": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "183": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "184": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "186": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "187": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "189": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "191": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "192": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/random.nr",
      "source": "use crate::oracle::random::random;\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n"
    },
    "195": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "202": {
      "path": "/home/nerses/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "219": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "221": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "264": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "279": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "281": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "282": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "283": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "292": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "296": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "298": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "299": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "308": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "312": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_delay_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initially equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub struct ScheduledDelayChange<let INITIAL_DELAY: u32> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pub(crate) pre: Option<u32>,\n    pub(crate) post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<let INITIAL_DELAY: u32> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior constraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This\n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in\n            //                             which to scheduled value change\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY),\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Empty for ScheduledDelayChange<INITIAL_DELAY> {\n    fn empty() -> Self {\n        Self { pre: Option::none(), post: Option::none(), block_of_change: 0 }\n    }\n}\n"
    },
    "314": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_value_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\npub struct ScheduledValueChange<T> {\n    pub(crate) pre: T,\n    pub(crate) post: T,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    // Returns the previous value. This is the value that is current up until the block of change. Note that this value\n    // might not be the current anymore since block of change might have already passed.\n    pub fn get_previous(self) -> (T, u32) {\n        (self.pre, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay,\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32,\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<T> Empty for ScheduledValueChange<T>\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        Self { pre: T::empty(), post: T::empty(), block_of_change: 0 }\n    }\n}\n"
    },
    "316": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/shared_mutable_values.nr",
      "source": "use crate::{\n    hash::poseidon2_hash,\n    shared_mutable::{\n        scheduled_delay_change::ScheduledDelayChange, scheduled_value_change::ScheduledValueChange,\n    },\n    traits::{Hash, Packable},\n    utils::arrays,\n};\nuse std::meta::derive;\n\nmod test;\n\n/// SharedMutableValues is just a wrapper around ScheduledValueChange and ScheduledDelayChange that then allows us\n/// to wrap both of these values in WithHash. WithHash allows for efficient read of values in private.\n///\n/// Note that the WithHash optimization does not work in public (due to there being no unconstrained). But we also want\n/// to be able to read the values efficiently in public and we want to be able to read each value separately. Reading\n/// the values separately is tricky because ScheduledValueChange and ScheduledDelayChange are packed together (sdc and\n/// svc.block_of_change are stored in the same slot). For that reason we expose `unpack_value_change` and\n/// `unpack_delay_change` functions that can be used to extract the values from the packed representation. This\n/// is \"hacky\" but there is no way around it.\n#[derive(Eq)]\npub struct SharedMutableValues<T, let INITIAL_DELAY: u32> {\n    pub svc: ScheduledValueChange<T>,\n    pub sdc: ScheduledDelayChange<INITIAL_DELAY>,\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutableValues<T, INITIAL_DELAY> {\n    pub fn new(svc: ScheduledValueChange<T>, sdc: ScheduledDelayChange<INITIAL_DELAY>) -> Self {\n        SharedMutableValues { svc, sdc }\n    }\n}\n\npub fn unpack_value_change<T, let N: u32>(packed: [Field; 2 * N + 1]) -> ScheduledValueChange<T>\nwhere\n    T: Packable<N>,\n{\n    let svc_pre_packed = arrays::subarray(packed, 1);\n    let svc_post_packed = arrays::subarray(packed, N + 1);\n    ScheduledValueChange::new(\n        T::unpack(svc_pre_packed),\n        T::unpack(svc_post_packed),\n        packed[0] as u32,\n    )\n}\n\npub fn unpack_delay_change<let INITIAL_DELAY: u32>(\n    packed: Field,\n) -> ScheduledDelayChange<INITIAL_DELAY> {\n    // This function expects to be called with just the first field of the packed representation, which contains sdc\n    // and svc block_of_change. We'll discard the svc component.\n    let svc_block_of_change = packed as u32;\n\n    let mut tmp = (packed - svc_block_of_change as Field) / TWO_POW_32;\n    let sdc_block_of_change = tmp as u32;\n\n    tmp = (tmp - sdc_block_of_change as Field) / TWO_POW_32;\n    let sdc_post_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_post_is_some as Field) / TWO_POW_8;\n    let sdc_post_inner = tmp as u32;\n\n    tmp = (tmp - sdc_post_inner as Field) / TWO_POW_32;\n    let sdc_pre_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_pre_is_some as Field) / TWO_POW_8;\n    let sdc_pre_inner = tmp as u32;\n\n    ScheduledDelayChange {\n        pre: if sdc_pre_is_some {\n            Option::some(sdc_pre_inner)\n        } else {\n            Option::none()\n        },\n        post: if sdc_post_is_some {\n            Option::some(sdc_post_inner)\n        } else {\n            Option::none()\n        },\n        block_of_change: sdc_block_of_change,\n    }\n}\n\nglobal TWO_POW_32: Field = 2.pow_32(32);\nglobal TWO_POW_8: Field = 2.pow_32(8);\n\n// We pack to `2 * N + 1` fields because ScheduledValueChange contains T twice (hence `2 * N`) and we need one extra\n// field to store ScheduledDelayChange and the block_of_change of ScheduledValueChange.\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Packable<2 * N + 1> for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; 2 * N + 1] {\n        let mut result = [0; 2 * N + 1];\n\n        // We pack sdc.pre, sdc.post, sdc.block_of_change and svc.block_of_change into a single field as follows:\n        // [ sdc.pre_inner: u32 | sdc.pre_is_some: u8 | sdc.post_inner: u32 | sdc.post_is_some: u8 | sdc.block_of_change: u32 | svc.block_of_change: u32 ]\n        result[0] = self.svc.block_of_change as Field\n            + ((self.sdc.block_of_change as Field) * 2.pow_32(32))\n            + ((self.sdc.post.is_some() as Field) * 2.pow_32(64))\n            + ((self.sdc.post.unwrap_unchecked() as Field) * 2.pow_32(72))\n            + ((self.sdc.pre.is_some() as Field) * 2.pow_32(104))\n            + ((self.sdc.pre.unwrap_unchecked() as Field) * 2.pow_32(112));\n\n        // Pack the pre and post values from ScheduledValueChange\n        let svc_pre_packed = self.svc.pre.pack();\n        let svc_post_packed = self.svc.post.pack();\n        for i in 0..N {\n            result[i + 1] = svc_pre_packed[i];\n            result[i + 1 + N] = svc_post_packed[i];\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; 2 * N + 1]) -> Self {\n        let svc = unpack_value_change::<T, N>(fields);\n        let sdc = unpack_delay_change::<INITIAL_DELAY>(fields[0]);\n        Self::new(svc, sdc)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Hash for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn hash(self) -> Field {\n        poseidon2_hash(self.pack())\n    }\n}\n"
    },
    "319": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "333": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "337": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "338": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "354": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "355": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "357": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "367": {
      "path": "/home/nerses/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "396": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialUintNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        context.emit_private_log(encrypted_log);\n\n        PartialUintNote { commitment }\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, value: u128, context: &mut PublicContext) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "50": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/lib.nr",
      "source": "pub fn bytes_to_u128_limbs(bytes: [u8; 32]) -> (u128, u128) {\n    let mut high: u128 = 0;\n    let mut low: u128 = 0;\n    for i in 0..16 {\n        high = (high << 8) + (bytes[i] as u128);\n    }\n    for i in 16..32 {\n        low = (low << 8) + (bytes[i] as u128);\n    }\n    (high, low)\n}\n\npub fn u128_limbs_to_bytes(high: u128, low: u128) -> [u8; 32] {\n    let mut bytes: [u8; 32] = [0; 32];\n\n    let mut temp = high;\n    for i in 0..16 {\n        bytes[15 - i] = (temp & 0xff) as u8;\n        temp >>= 8;\n    }\n\n    temp = low;\n    for i in 0..16 {\n        bytes[31 - i] = (temp & 0xff) as u8;\n        temp >>= 8;\n    }\n\n    bytes\n}\n"
    },
    "51": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/main.nr",
      "source": "//     @@                                    @@@\n//    @@@\n//    @@@        @@   @@@@      @@@@@         @     @    @@@@@\n//  @@@@@@@@@   @@@@@@      @@@@    @@@@@    @@@   @@@@@@    @@@@\n//    @@@       @@@       @@@           @@@  @@@   @@@          @@@\n//    @@@       @@@       @@@           @@@  @@@   @@@          @@@\n//    @@@       @@@       @@@           @@@  @@@   @@@          @@@\n//     @@@      @@@        @@@@       @@@@@  @@@   @@@          @@@\n//       @@@@@  @@@           @@@@@@@@@ @@@  @@@   @@@          @@@\n\nmod lib;\nmod types;\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract Train {\n    use crate::lib::{bytes_to_u128_limbs, u128_limbs_to_bytes};\n    use crate::types::events::{\n        TokenCommitted, TokenLockAdded, TokenLocked, TokenRedeemed, TokenRefunded,\n    };\n    use dep::aztec::messages::logs::note::encode_and_encrypt_note;\n    use dep::aztec::protocol_types::traits::{Packable, Serialize};\n    use dep::aztec::state_vars::{private_immutable::PrivateImmutable, SharedMutable};\n    use dep::sha256;\n    use dep::token::Token;\n    use aztec::macros::{\n        functions::{initializer, internal, private, public, utility, view},\n        notes::note,\n        storage::storage,\n    };\n    use aztec::prelude::{AztecAddress, Map};\n    use std::meta::derive;\n\n    #[note]\n    #[derive(Eq)]\n    struct HTLC_Private {\n        owner: AztecAddress,\n        randomness: Field,\n    }\n    #[derive(Eq, Packable, Serialize)]\n    pub struct HTLC_Public {\n        src_receiver: AztecAddress,\n        amount: u128,\n        token: AztecAddress,\n        hashlock_high: u128,\n        hashlock_low: u128,\n        secret_high: u128,\n        secret_low: u128,\n        ownership_hash_high: u128,\n        ownership_hash_low: u128,\n        timelock: u64,\n        claimed: u8,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor() {}\n\n    #[storage]\n    struct Storage<Context> {\n        contracts_private: Map<Field, PrivateImmutable<HTLC_Private, Context>, Context>,\n        contracts_public: Map<Field, SharedMutable<HTLC_Public, 2, Context>, Context>,\n    }\n\n    #[private]\n    fn commit_private_user(\n        Id: Field,\n        src_receiver: AztecAddress,\n        timelock: u64,\n        token: AztecAddress,\n        amount: u128,\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n        randomness: Field,\n    ) {\n        assert(amount > 0, \"FundsNotSent\");\n\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address())\n            .commit_public_user(\n                dst_chain,\n                dst_asset,\n                dst_address,\n                Id,\n                src_receiver,\n                timelock,\n                token,\n                amount,\n            )\n            .enqueue(&mut context);\n\n        let htlc_note = HTLC_Private { owner: context.msg_sender(), randomness: randomness };\n        storage.contracts_private.at(Id).initialize(htlc_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        Token::at(token)\n            .transfer_to_public(context.msg_sender(), context.this_address(), amount, randomness)\n            .call(&mut context);\n    }\n\n    #[internal]\n    #[public]\n    fn commit_public_user(\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n        Id: Field,\n        src_receiver: AztecAddress,\n        timelock: u64,\n        token: AztecAddress,\n        amount: u128,\n    ) {\n        let htlc_public_current = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public_current.amount == 0, \"HTLCAlreadyExists\");\n        assert(context.timestamp() + 900 < timelock, \"InvalidTimelock\");\n        let htlc_public = HTLC_Public {\n            src_receiver: src_receiver,\n            amount: amount,\n            token: token,\n            hashlock_high: 0 as u128,\n            hashlock_low: 0 as u128,\n            secret_high: 0 as u128,\n            secret_low: 0 as u128,\n            ownership_hash_high: 0 as u128,\n            ownership_hash_low: 0 as u128,\n            timelock: timelock,\n            claimed: 1 as u8,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(htlc_public);\n        let log_msg = TokenCommitted {\n            Id: Id,\n            amount: amount,\n            token: token,\n            timelock: timelock,\n            dst_chain: dst_chain,\n            dst_asset: dst_asset,\n            dst_address: dst_address,\n            src_receiver: src_receiver,\n        };\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn add_lock_private_user(Id: Field, hashlock: [u8; 32], timelock: u64) {\n        let htlc_private = storage.contracts_private.at(Id).get_note();\n        assert(htlc_private.owner == context.msg_sender(), \"NoAllowance\");\n\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).add_lock_public_user(Id, hashlock, timelock).enqueue(\n            &mut context,\n        );\n    }\n\n    #[internal]\n    #[public]\n    fn add_lock_public_user(Id: Field, hashlock: [u8; 32], timelock: u64) {\n        assert(context.timestamp() + 900 < timelock, \"InvalidTimelock\");\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        assert(htlc_public.hashlock_high == (0 as u128), \"HashlockAlreadySet\");\n        assert(htlc_public.hashlock_low == (0 as u128), \"HashlockAlreadySet\");\n\n        let hashlock_tuple = bytes_to_u128_limbs(hashlock);\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: hashlock_tuple.0,\n            hashlock_low: hashlock_tuple.1,\n            secret_high: htlc_public.secret_high,\n            secret_low: htlc_public.secret_low,\n            ownership_hash_high: htlc_public.ownership_hash_high,\n            ownership_hash_low: htlc_public.ownership_hash_low,\n            timelock: timelock,\n            claimed: htlc_public.claimed,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n        let log_msg = TokenLockAdded { Id, hashlock, timelock };\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn refund_private(Id: Field) {\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).refund_public(Id).enqueue(&mut context);\n\n        let htlc_private = storage.contracts_private.at(Id).get_note();\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n\n        let partial_note = Token::at(htlc_public.token)\n            .prepare_private_balance_increase(htlc_private.owner, htlc_private.owner)\n            .call(&mut context);\n        Token::at(htlc_public.token)\n            .finalize_transfer_to_private(htlc_public.amount, partial_note)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn refund_public(Id: Field) {\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        assert(htlc_public.timelock < context.timestamp(), \"NotPassedTimelock\");\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: htlc_public.hashlock_high,\n            hashlock_low: htlc_public.hashlock_low,\n            secret_high: htlc_public.secret_high,\n            secret_low: htlc_public.secret_low,\n            ownership_hash_high: htlc_public.ownership_hash_high,\n            ownership_hash_low: htlc_public.ownership_hash_low,\n            timelock: htlc_public.timelock,\n            claimed: 2 as u8,\n        };\n\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n        let log_msg = TokenRefunded { Id };\n        context.emit_public_log(log_msg);\n    }\n\n    #[private]\n    fn lock_private_solver(\n        Id: Field,\n        hashlock: [u8; 32],\n        amount: u128,\n        ownership_hash: [u8; 32],\n        timelock: u64,\n        token: AztecAddress,\n        randomness: Field,\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n    ) {\n        assert(amount > 0, \"FundsNotSent\");\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address())\n            .lock_public_solver(\n                Id,\n                hashlock,\n                ownership_hash,\n                amount,\n                token,\n                timelock,\n                dst_chain,\n                dst_asset,\n                dst_address,\n            )\n            .enqueue(&mut context);\n\n        let htlc_note = HTLC_Private { owner: context.msg_sender(), randomness: randomness };\n        storage.contracts_private.at(Id).initialize(htlc_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        Token::at(token)\n            .transfer_to_public(context.msg_sender(), context.this_address(), amount, randomness)\n            .call(&mut context);\n    }\n\n    #[internal]\n    #[public]\n    fn lock_public_solver(\n        Id: Field,\n        hashlock: [u8; 32],\n        ownership_hash: [u8; 32],\n        amount: u128,\n        token: AztecAddress,\n        timelock: u64,\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n    ) {\n        let htlc_public_current = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public_current.amount == 0, \"HTLCAlreadyExists\");\n        assert(context.timestamp() + 1800 < timelock, \"InvalidTimelock\");\n        let hashlock_tuple = bytes_to_u128_limbs(hashlock);\n        let ownership_hash_tuple = bytes_to_u128_limbs(ownership_hash);\n        let htlc_public = HTLC_Public {\n            src_receiver: AztecAddress::zero(),\n            amount: amount,\n            token: token,\n            hashlock_high: hashlock_tuple.0,\n            hashlock_low: hashlock_tuple.1,\n            secret_high: 0 as u128,\n            secret_low: 0 as u128,\n            ownership_hash_high: ownership_hash_tuple.0,\n            ownership_hash_low: ownership_hash_tuple.1,\n            timelock: timelock,\n            claimed: 1 as u8,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(htlc_public);\n\n        let log_msg = TokenLocked {\n            Id: Id,\n            hashlock: hashlock,\n            ownership_hash: ownership_hash,\n            amount: amount,\n            src_receiver: AztecAddress::zero(),\n            token: token,\n            timelock: timelock,\n            dst_chain: dst_chain,\n            dst_asset: dst_asset,\n            dst_address: dst_address,\n        };\n\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn redeem_private(Id: Field, secret: [u8; 32], ownership_key: [u8; 32]) {\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).redeem_public(Id, secret, ownership_key).enqueue(\n            &mut context,\n        );\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        if (htlc_public.ownership_hash_high == 0 as u128) {\n            if htlc_public.ownership_hash_low == 0 as u128 {\n                let partial_note = Token::at(htlc_public.token)\n                    .prepare_private_balance_increase(\n                        htlc_public.src_receiver,\n                        htlc_public.src_receiver,\n                    )\n                    .call(&mut context);\n                Token::at(htlc_public.token)\n                    .finalize_transfer_to_private(htlc_public.amount, partial_note)\n                    .enqueue(&mut context);\n            }\n        } else {\n            let partial_note = Token::at(htlc_public.token)\n                .prepare_private_balance_increase(context.msg_sender(), context.msg_sender())\n                .call(&mut context);\n            Token::at(htlc_public.token)\n                .finalize_transfer_to_private(htlc_public.amount, partial_note)\n                .enqueue(&mut context);\n        }\n    }\n\n    #[public]\n    #[internal]\n    fn redeem_public(Id: Field, secret: [u8; 32], ownership_key: [u8; 32]) {\n        let mut htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.amount > 0, \"HTLCNotExists\"); // If it doesn't exist, all parameters will default to zero values.\n        let hashed_secret = sha256::sha256_var(secret, secret.len() as u64);\n        let hashed_secret_tuple = bytes_to_u128_limbs(hashed_secret);\n        assert(htlc_public.hashlock_high == hashed_secret_tuple.0, \"HashlockNotMatch\");\n        assert(htlc_public.hashlock_low == hashed_secret_tuple.1, \"HashlockNotMatch\");\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n\n        if (htlc_public.ownership_hash_high != 0 as u128) {\n            if htlc_public.ownership_hash_low != 0 as u128 {\n                let ownership_key_hashed =\n                    sha256::sha256_var(ownership_key, ownership_key.len() as u64);\n                let ownership_key_tuple = bytes_to_u128_limbs(ownership_key_hashed);\n                assert(htlc_public.ownership_hash_high == ownership_key_tuple.0, \"NotAnOwner\");\n                assert(htlc_public.ownership_hash_low == ownership_key_tuple.1, \"NotAnOwner\");\n            }\n        }\n\n        let secret_limbs = bytes_to_u128_limbs(secret);\n\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: htlc_public.hashlock_high,\n            hashlock_low: htlc_public.hashlock_low,\n            secret_high: secret_limbs.0,\n            secret_low: secret_limbs.1,\n            ownership_hash_high: htlc_public.ownership_hash_high,\n            ownership_hash_low: htlc_public.ownership_hash_low,\n            timelock: htlc_public.timelock,\n            claimed: 3 as u8,\n        };\n\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n\n        let log_msg = TokenRedeemed {\n            Id: Id,\n            hashlock: u128_limbs_to_bytes(htlc_public.hashlock_high, htlc_public.hashlock_low),\n            secret: secret,\n        };\n\n        context.emit_public_log(log_msg.pack());\n    }\n\n    // This utility function should be invoked by the frontend before each function call\n    // where the existence or non-existence of an HTLC is a critical security check.\n    #[utility]\n    unconstrained fn is_contract_initialized(Id: Field) -> bool {\n        storage.contracts_private.at(Id).is_initialized()\n    }\n\n    #[view]\n    #[public]\n    fn get_htlc_public(key: Field) -> pub HTLC_Public {\n        storage.contracts_public.at(key).get_current_value()\n    }\n}\n"
    },
    "52": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/types/events.nr",
      "source": "use dep::aztec::prelude::AztecAddress;\nuse dep::aztec::protocol_types::traits::{Packable, Serialize};\n\n#[derive(Serialize)]\npub struct TokenCommitted {\n    pub Id: Field,\n    pub amount: u128,\n    pub token: AztecAddress,\n    pub timelock: u64,\n    pub dst_chain: str<8>,\n    pub dst_asset: str<8>,\n    pub dst_address: str<48>,\n    pub src_receiver: AztecAddress,\n}\n\nimpl Packable<9> for TokenCommitted {\n    fn pack(self) -> [Field; 9] {\n        let zero: Field = 0;\n        let mut out = [zero; 9];\n        out[0] = self.Id;\n        out[1] = self.amount as Field;\n        out[2] = self.token.inner;\n        out[3] = self.timelock as Field;\n\n        let dst_chain_byte_array = self.dst_chain.as_bytes();\n        let mut dst_chain_byte_array_filled = [0 as u8; 31];\n        for i in 0..dst_chain_byte_array.len() {\n            dst_chain_byte_array_filled[i] = dst_chain_byte_array[i];\n        }\n\n        out[4] = Field::from_be_bytes::<31>(dst_chain_byte_array_filled);\n\n        let dst_asset_byte_array = self.dst_asset.as_bytes();\n        let mut dst_asset_byte_array_filled = [0 as u8; 31];\n        for i in 0..dst_asset_byte_array.len() {\n            dst_asset_byte_array_filled[i] = dst_asset_byte_array[i];\n        }\n\n        out[5] = Field::from_be_bytes::<31>(dst_asset_byte_array_filled);\n\n        let dst_address_byte_array = self.dst_address.as_bytes();\n        let mut dst_address_byte_array_filled_1 = [0 as u8; 31];\n        let mut dst_address_byte_array_filled_2 = [0 as u8; 31];\n\n        for i in 0..31 {\n            dst_address_byte_array_filled_1[i] = dst_address_byte_array[i];\n        }\n\n        for i in 31..48 {\n            dst_address_byte_array_filled_2[i - 31] = dst_address_byte_array[i];\n        }\n\n        out[6] = Field::from_be_bytes::<31>(dst_address_byte_array_filled_1);\n        out[7] = Field::from_be_bytes::<31>(dst_address_byte_array_filled_2);\n\n        out[8] = self.src_receiver.inner;\n        out\n    }\n\n    fn unpack(fields: [Field; 9]) -> Self {\n        assert(false, \"unpack not implemented\");\n        TokenCommitted {\n            Id: fields[0] as Field,\n            amount: 0 as u128,\n            token: AztecAddress::zero(),\n            timelock: 0 as u64,\n            dst_chain: \"00000000\",\n            dst_asset: \"00000000\",\n            dst_address: \"000000000000000000000000000000000000000000000000\",\n            src_receiver: AztecAddress::zero(),\n        }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenLockAdded {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub timelock: u64,\n}\n\nimpl Packable<4> for TokenLockAdded {\n    fn pack(self) -> [Field; 4] {\n        let mut out = [0 as Field; 4];\n        out[0] = self.Id;\n\n        let hb = self.hashlock;\n        let mut h1 = [0 as u8; 31];\n        for i in 0..31 {\n            h1[i] = hb[i];\n        }\n        out[1] = Field::from_be_bytes::<31>(h1);\n\n        let mut h2 = [0 as u8; 31];\n        h2[0] = hb[31];\n        out[2] = Field::from_be_bytes::<31>(h2);\n\n        out[3] = self.timelock as Field;\n        out\n    }\n\n    fn unpack(fields: [Field; 4]) -> Self {\n        let Id = fields[0];\n\n        let b1 = fields[1].to_be_bytes();\n        let b2 = fields[2].to_be_bytes();\n        let mut hash = [0 as u8; 32];\n        for i in 0..31 {\n            hash[i] = b1[i];\n        }\n        hash[31] = b2[0];\n\n        let timelock = fields[3] as u64;\n\n        TokenLockAdded { Id, hashlock: hash, timelock }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenRefunded {\n    pub Id: Field,\n}\n\n#[derive(Serialize)]\npub struct TokenRedeemed {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub secret: [u8; 32],\n}\n\nimpl Packable<5> for TokenRedeemed {\n    fn pack(self) -> [Field; 5] {\n        let mut out = [0 as Field; 5];\n        out[0] = self.Id;\n\n        let hb = self.hashlock;\n        let mut h1 = [0 as u8; 31];\n        for i in 0..31 {\n            h1[i] = hb[i];\n        }\n        out[1] = Field::from_be_bytes::<31>(h1);\n        let mut h2 = [0 as u8; 31];\n        h2[0] = hb[31];\n        out[2] = Field::from_be_bytes::<31>(h2);\n\n        let sb = self.secret;\n        let mut s1 = [0 as u8; 31];\n        for i in 0..31 {\n            s1[i] = sb[i];\n        }\n        out[3] = Field::from_be_bytes::<31>(s1);\n        let mut s2 = [0 as u8; 31];\n        s2[0] = sb[31];\n        out[4] = Field::from_be_bytes::<31>(s2);\n\n        out\n    }\n\n    fn unpack(fields: [Field; 5]) -> Self {\n        let Id = fields[0];\n\n        let b1 = fields[1].to_be_bytes();\n        let b2 = fields[2].to_be_bytes();\n        let mut hashlock = [0 as u8; 32];\n        for i in 0..31 {\n            hashlock[i] = b1[i];\n        }\n        hashlock[31] = b2[0];\n\n        let b3 = fields[3].to_be_bytes();\n        let b4 = fields[4].to_be_bytes();\n        let mut secret = [0 as u8; 32];\n        for i in 0..31 {\n            secret[i] = b3[i];\n        }\n        secret[31] = b4[0];\n\n        TokenRedeemed { Id, hashlock, secret }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenLocked {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub ownership_hash: [u8; 32],\n    pub amount: u128,\n    pub src_receiver: AztecAddress,\n    pub token: AztecAddress,\n    pub timelock: u64,\n    pub dst_chain: str<8>,\n    pub dst_asset: str<8>,\n    pub dst_address: str<48>,\n}\n\nimpl Packable<13> for TokenLocked {\n    fn pack(self) -> [Field; 13] {\n        let mut out = [0 as Field; 13];\n        out[0] = self.Id;\n\n        let hb = self.hashlock;\n        let mut h1 = [0 as u8; 31];\n        for i in 0..31 {\n            h1[i] = hb[i];\n        }\n        out[1] = Field::from_be_bytes::<31>(h1);\n\n        let mut h2 = [0 as u8; 31];\n        h2[0] = hb[31];\n        out[2] = Field::from_be_bytes::<31>(h2);\n\n        let ownership = self.ownership_hash;\n        let mut o1 = [0 as u8; 31];\n        for i in 0..31 {\n            o1[i] = ownership[i];\n        }\n        out[3] = Field::from_be_bytes::<31>(o1);\n\n        let mut o2 = [0 as u8; 31];\n        o2[0] = ownership[31];\n        out[4] = Field::from_be_bytes::<31>(o2);\n\n        out[5] = self.amount as Field;\n        out[6] = self.src_receiver.inner as Field;\n        out[7] = self.token.inner;\n        out[8] = self.timelock as Field;\n\n        let dst_chain_byte_array = self.dst_chain.as_bytes();\n        let mut dst_chain_byte_array_filled = [0 as u8; 31];\n        for i in 0..dst_chain_byte_array.len() {\n            dst_chain_byte_array_filled[i] = dst_chain_byte_array[i];\n        }\n        out[9] = Field::from_be_bytes::<31>(dst_chain_byte_array_filled);\n\n        let dst_asset_byte_array = self.dst_asset.as_bytes();\n        let mut dst_asset_byte_array_filled = [0 as u8; 31];\n        for i in 0..dst_asset_byte_array.len() {\n            dst_asset_byte_array_filled[i] = dst_asset_byte_array[i];\n        }\n        out[10] = Field::from_be_bytes::<31>(dst_asset_byte_array_filled);\n\n        let addr = self.dst_address.as_bytes();\n        let mut dst_address_byte_array_filled_1 = [0 as u8; 31];\n        let mut dst_address_byte_array_filled_2 = [0 as u8; 31];\n        for i in 0..31 {\n            dst_address_byte_array_filled_1[i] = addr[i];\n        }\n        for i in 31..48 {\n            dst_address_byte_array_filled_2[i - 31] = addr[i];\n        }\n        out[11] = Field::from_be_bytes::<31>(dst_address_byte_array_filled_1);\n        out[12] = Field::from_be_bytes::<31>(dst_address_byte_array_filled_2);\n\n        out\n    }\n\n    fn unpack(fields: [Field; 13]) -> Self {\n        assert(false, \"unpack not implemented\");\n        TokenLocked {\n            Id: fields[0] as Field,\n            hashlock: [0 as u8; 32],\n            ownership_hash: [0 as u8; 32],\n            amount: 0 as u128,\n            src_receiver: AztecAddress::zero(),\n            token: AztecAddress::zero(),\n            timelock: 0 as u64,\n            dst_chain: \"00000000\",\n            dst_asset: \"00000000\",\n            dst_address: \"000000000000000000000000000000000000000000000000\",\n        }\n    }\n}\n"
    },
    "54": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "55": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "62": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "63": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "64": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "65": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "69": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "81": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "84": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n"
    },
    "85": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
      "source": "use std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // Safety: we use the randomness to preserve the privacy of both the sender and recipient via encryption, so a\n    // malicious sender could use non-random values to reveal the plaintext. But they already know it themselves anyway,\n    // and so the recipient already trusts them to not disclose this information. We can therefore assume that the\n    // sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // TODO(#12757): compute the key pair without constraining eph_sk twice (once in from_field, once in the black box\n    // called by fixed_base_scalar_mul).\n    let eph_sk = EmbeddedCurveScalar::from_field(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
    },
    "86": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "90": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_notes` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    // TODO(https://github.com/noir-lang/noir/issues/7912): Doing the following unfortunately doesn't work. Once\n    // the issue is fixed uncomment the following and remove the workaround from TS (look for the issue link in the\n    // codebase).\n    // let utility: fn(FunctionDefinition) -> () = crate::macros::functions::utility;\n    // quote {\n    //     #[$utility]\n    //     unconstrained fn sync_notes() {\n    //     }\n    // }\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[aztec::macros::functions::utility]\n        unconstrained fn sync_notes() { }\n    }\n}\n"
    },
    "91": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "94": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n"
    },
    "95": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "98": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    }
  }
}
