{
  "transpiled": true,
  "noir_version": "1.0.0-beta.4+0000000000000000000000000000000000000000",
  "name": "Train",
  "functions": [
    {
      "name": "lock_private_solver",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "ownership_hash",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6418028854678020178": {
            "error_kind": "string",
            "string": "FundsNotSent"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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9ooYe/IDFTEKGDUw4mJUMOJiVDDiYlQw4mJUMPbkYj76jm3HmM8GEsIW9zcPeXp4938keCv20JPraQh7Ty6pIew9uaqGsPfkwhrCLmCvgb0nl9cQ9p5cYUPYe3KRDWHvyXU2hB2XWgN7xKVWwY5LrYIdl1oF+8AuNU7LbSQhfsz4BHv8kOnr8hjSA5S0Hl29TfvVW7z/tm/9xC5gr4F9YJdaE/vALrUm9oFdak3sA7vUmtgHdqkVsc8Du9Sa2Ad2qTWxD+xSa2LHpVbBLmCvgR2XWgU7LrUK9pFd6pzSjl3kLPiN6z6WuK7L/eocjsYS4u3N57A8XP2PYD+vnrd95HOev139R6aRXW1DMo3sgtuRqavHUXYs08guuyGZRnblDck0sotvSCZBphZkGjklaEimkVOFhmQihWhCJlKIJmQihWhBpq4e7tyxTKQQTchECtGETKQQTcgkyNSCTKQQTchECtGETKQQTchECtGETKQQLci0kkI0IRMpRBMykUI0IRMpRBMyCTK1IBMpRBMykUI0IRMpRBMykUI0IRMpRAsybaQQTchECtGETKQQTchECtGETIJMLchECtGETKQQTchECtGETKQQTchECtGCTIkUogmZSCGakIkUogmZSCGakEmQqQWZSCGakIkUogmZSCGakIkUogmZSCFakCmTQjQhEylEEzKRQjQhEylEEzIJMrUgEylEEzKRQjQhEylEEzKRQjQhEylEAzLJRArRhEykEE3IRArRhEykEE3IJMjUgkykEE3IRArRhEykEE3IRArRhEykEC3IFEghmpCJFKIJmUghmpCJFKIJmQSZWpCJFKIJmUghmpCJFKIJmUghmpCJFKIFmSIpRBMykUI0IRMpRBMykUI0IZMgUwsykUI0IRMpRBMykUI0IRMpRBMykUK0INNMCtGETKQQTchECtGETKQQTcgkyNSCTKQQTchECtGETKQQTchECtGETKQQLcgkpBBvkinKsiNMZzJJ3mVapin/lIkUogmZSCGakIkUogmZBJlakIkUogmZSCGakIkUogmZSCGakIkUogWZFlKIJmQihWhCJlKIJmQihWhCJkGmFmQihWhCJlKIJmQihWhCJlKIJmQihWhBppUUogmZSCGakIkUogmZSCGakEmQqQWZSCGakIkUogmZSCGakIkUogmZSCFakGkjhWhCJlKIJmQi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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "random",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "lock_public_solver",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "ownership_hash",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "15001264570739363109": {
            "error_kind": "string",
            "string": "Function lock_public_solver can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "lock_public_solver"
      ]
    },
    {
      "name": "redeem_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "ownership_key",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "772057049813214347": {
            "error_kind": "string",
            "string": "HTLCNotExists"
          },
          "2570651705007895968": {
            "error_kind": "string",
            "string": "HashlockNotMatch"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6012086182631426650": {
            "error_kind": "string",
            "string": "NotAnOwner"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17814817983036354427": {
            "error_kind": "string",
            "string": "Function redeem_public can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "redeem_public"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "772057049813214347": {
            "error_kind": "string",
            "string": "HTLCNotExists"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2570651705007895968": {
            "error_kind": "string",
            "string": "HashlockNotMatch"
          },
          "2722406262643068352": {
            "error_kind": "string",
            "string": "HashlockAlreadySet"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3559210201980528457": {
            "error_kind": "string",
            "string": "Function commit_public_user can only be called internally"
          },
          "3564161243949231814": {
            "error_kind": "string",
            "string": "Function refund_public can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6012086182631426650": {
            "error_kind": "string",
            "string": "NotAnOwner"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "9174444391250494040": {
            "error_kind": "string",
            "string": "Function get_htlc_public can only be called statically"
          },
          "9323748002447105156": {
            "error_kind": "string",
            "string": "NotPassedTimelock"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "15001264570739363109": {
            "error_kind": "string",
            "string": "Function lock_public_solver can only be called internally"
          },
          "16870384257694633552": {
            "error_kind": "string",
            "string": "Function add_lock_public_user can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17814817983036354427": {
            "error_kind": "string",
            "string": "Function redeem_public can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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AhEuCoBWABEAKBECES4KgFYAEQAoEQIRLgqAVgARACgRAhEuCoBWABEAKBECES4KgFYAEQAoEQIRLgqAVgARACgRAhEuCoBWABEAKBECES4KgFYAEQAoEQIRLgqAVgARACgRAhEuCoBWABEAKBECES4KgFYAEQAoEQIRLgqAVgARACgRAhEuCoBWABEAKBECES4KgFYAEQAoEQIRLgqAVgARACgRAhEuCoBWABEAKBECES4KgFYAEQAoEQIRLgqAVgARACgRAhEuCoBWABEAKBECES4KgFYAEQAoEQIRLgqAVgARACgRAhEuCoBWABEnAgoEEy0IABMtDAkUABAACgAlAABXAS0EAAAtDBQFLgQACIADKACABAQADiUAAFfALgiABQAJACgJAgoBKAAKgF0AES0OBREtDgkSLQ0LBQAoBQIFLQ4FCy0IAQUnAggEIAAQAQgBJwMFBAEAKAUCCCcCCQQfADgJCAktDAgKDDgKCREWDBERJAIAEQAAITMuCoBWAAoAKAoCCiMAACESLQgBCAAAAQIBLQ4FCC4IgFcAAyMAACFLDSgAA4BrAAUkAgAFAAA9biMAACFgLQ0SBS0NCAknAgoEEy0IABMtDAkUABAACgAlAABXAS0EAAAtDBQILgQABYADKACABAQADiUAAFfALgiABQAJACgJAgoBKAAKgFQAES0OCBEBKAALgG0ACC0NCAUtCAEIJwIKBCAAEAEKAScDCAQBACgIAgotDAoLLQ4FCwAoCwILLgqAVgALACgLAgsuCoBWAAsAKAsCCy4KgFYACwAoCwILLgqAVgALACgLAgsuCoBWAAsAKAsCCy4KgFYACwAoCwILLgqAVgALACgLAgsuCoBWAAsAKAsCCy4KgFYACwAoCwILLgqAVgALACgLAgsuCoBWAAsAKAsCCy4KgFYACwAoCwILLgqAVgALACgLAgsuCoBWAAsAKAsCCy4KgFYACwAoCwILLgqAVgALACgLAgsuCoBWAAsAKAsCCy4KgFYACwAoCwILLgqAVgALACgLAgsuCoBWAAsAKAsCCy4KgFYACwAoCwILLgqAVgALACgLAgsuCoBWAAsAKAsCCy4KgFYACwAoCwILLgqAVgALACgLAgsuCoBWAAsAKAsCCy4KgFYACwAoCwILLgqAVgALACgLAgsuCoBWAAsAKAsCCy4KgFYACycC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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "commit_private_user",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_receiver",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6652550611004701521": {
            "error_kind": "string",
            "string": "Funds Not Sent"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "random",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "refund_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3564161243949231814": {
            "error_kind": "string",
            "string": "Function refund_public can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "9323748002447105156": {
            "error_kind": "string",
            "string": "NotPassedTimelock"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "refund_public"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "add_lock_private_user",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17476367995570638746": {
            "error_kind": "string",
            "string": "NoAllowance"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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wfwais37G6y2OF/5aUtl/3wzJPf807/H6hSN1SsaKykaa1A01qhorEnRWLOisRY9YyWjaKyK8iZSlDeRoryJFOVNpChvIkV5EynKm0hR3kSK8qagKG8KivKmoChvCorypqAobwqK8qagKG8KivKmoChvCorypqgob4qK8qaoKG+KivKmqChviorypqgob4qK8qaoKG+KivKmpChvSorypqQob0qK8qakKG9KivKmpChvSorypqQob0qK8qasKG/KivKmrChvyorypqwob8qK8qasKG/KivKmrChvyorypqIobyor5U2uxG2s3jxtw3lGJtFOxj79dj7qSTTb5o/RPX3umP0d40op2UCMK2V7AzESMHJgXClHHYhxpfR3IMaVMuuBGFdK2gdiXMkPDMPozUpWYyBGuBgWjHAxLBjhYlgwEjByYFzJxdyurbRjLLWOWJvc/uO2mKdf/yXBtdhXcj2CsK/kkgRhX8lVCcK+kguTg92u5NoEYV/J5QnCvpIrFIR9JRcpCDsB+wjscKlDsMOlDsEOlzoEO1zqEOyKXaozYeuJdbcRV7C7m0wfhzubn6DkeHR0MvvRyT3e7Yu/sTvFLnUkdsUudSR2xS51JHbFLnUkdgL2EdgVu9SR2BW71JHYFbvUkdgVu9SR2OFSR2D3cKlDsMOlDsEOlzoEu2aX6nPesRPVCr8u7n1xMYbH0cUe9cW67cdvj/Cejv4l2Nejfdp77ov/dPRvmQgySZBJswsWJJNm1yxIJs0uW5BMml25IJk0u3g5Mi219erCMmmuEgiSSXNVQZBMqEKIkIkgkwSZUIUQIROqECJkQhVChEyoQoiQCVUICTIttZH5wjKhCiFCJlQhRMiEKoQImQgySZAJVQgRMqEKIUImVCFEyIQqhAiZUIWQIFNEFUKETKhCiJAJVQgRMqEKIUImgkwSZEIVQoRMqEKIkAlVCBEyoQohQiZUISTIlFCFECETqhAiZEIVQoRMqEKIkIkgkwSZUIUQIROqECJkQhVChEyoQoiQCVUICTJlVCFEyIQqhAiZUIUQIROqECJkIsgkQSZUIUTIhCqECJlQhRAhE6oQImRCFUKCTAVVCBEyoQohQiZUIUTIhCqECJkIMkmQCVUIETKhCiFCJlQhRMiEKoQImVCFECATGVQhRMiEKoQImVCFECETqhAiZCLIJEEmVCFEyIQqhAiZUIUQIROqECJkQhVCgkwWVQgRMqEKIUImVCFEyIQqhAiZCDJJkAlVCBEyoQohQiZUIUTIhCqECJlQhZAgk0MVQoRMqEKIkAlVCBEyoQohQiaCTBJkQhVChEyoQoiQCVUIETKhCiFCJlQhJMjkUYUQIROqECJkQhVChEyoQoiQiSCTBJlQhRAhE6oQF8nkKOwIc00mKrtMwZjyVSZUIUTIhCqECJlQhZAgE6EKIUImVCFEyIQqhAiZUIUQIRNBJgkyoQohQiZUIUTIhCqECJlQhRAhE6oQEmQKqEKIkAlVCBEyoQohQiZUIUTIRJBJgkyoQoiQCVUIETKhCiFCJlQhRMiEKoQEmSKqECJkQhVChEyoQoiQCVUIETIRZJIgE6oQImRCFUKETKhCiJAJVQgRMqEKIUGmhCqECJlQhRAhE6oQImRCFUKETASZJMiEKoQImVCFECETqhAiZEIVQoRMqEJIkCmjCiFCJlQhRMiEKoQImVCFECETQSYJMqEKIUImVCFEyIQqhAiZUIUQIROqEBJkKqhCiJAJVQgRMqEKIUImVCFEyESQSYJMqEKIkAlVCBEyoQohQiZUIUTIhCqEAJlu/w4ySZAJVQgRMqEKIUImVCFEyESQSYJMqEKIkAlVCBEyoQohQiZUIUTIhCqEBJksqhAiZEIVQoRMqEKIkAlVCBEyEWSSIBOqECJkQhVChEyoQoiQCVUIETKhCiFBJocqhAiZUIUQIROqECJkQhVChEwEmSTIhCqECJlQhRAhE6oQImRCFUKETKhCSJDJowohQiZUIUTIhCqECJlQhRAhE0EmCTKhCiFCJlQhRMiEKoQImVCFECETqhASZCJUIUTIhCqECJlQhRAhE6oQImQiyCRBJlQhRMiEKoQImVCFECETqhAiZEIVQoJMAVUIETKhCiFCJlQhRMiEKoQImQgySZAJVQgRMqEKIUImVCFEyIQqhAiZUIWQIFNEFUKETKhCiJAJVQgRMmmuQkRjd5nSc8cPZbr9pN2hPMt0Imo2m6jJltrRzpTtaOfSp6N/y0SQSYJMmqsQgmTSXIUQJJPmKoQgmTRXIQTJpLkKIUempLkKIUgmzVUIQTJprkIIkglVCBEyEWSSIBOqECJkQhVChEyoQkwhE3m/HU259kglkvs4OMaHpD4ejbI8HtaYp24cHxztfnR0wVSOtsnGjfft7+Jrv1523rHYp1jMBwfn26Olj4Ozi+754N9xi7IM4lZi3KJOhbgVGLcZhTvErcS4RSUTcSsxblHaRdxKjFvUuhG3EuOWELeIW4Fxi6chiFuJcYvHQ4hbiXGL52WIW4lxi+dliFuJcYvnZYhbgXFb8LwMcSsxbvG8DHErMW7xvAxxKzFu8bwMcSsxbglxi7gVGLd4Xoa4lRi3eF6GuJUYt3hehriVGLd4Xoa4lRi3eF6GuH38sAtpj9tc+2mb497rX3/Tp+Nv0RUNnmohuq6LLjx7QnRdF114QoToui668BwH0XVddBGiC9F1WXThmQii67rowpMLRNd10YXnC4iu66ILTwEQXddFF2r1iK7LosuiVo/oui66UKtHdF0XXajVI7quiy7U6i+KrrS/m3L78/PRv8ETwI8BjwrvIPAofg4Cj7rgIPAomQ0Cj2rSGPAOhZZB4FGDGAQe9nwQeDjXQeAJ4MeAh3MdBB7OdRB4xc7V+7TVkK2n4Coo7a0ze6nX5vT4MC8egjduB+/c07G/sSv2rSOxK3atA7F7xZ6VTNr7TZZSBXs0j09/4+PY2+Ow3yAVe1BekIo9JS9IxR6RFyQBJA9IxR6OF6RiT8YLUrHH4gWp2DXxglTsg1hBEpwNE0g4GyaQcDZMIOFsmECSYpCRyg4yVl9qdj5tJJ0vT9X6nN4uupFmHzQQu2bXNBC7Zo81ELtmRzYQu2b/Ng570Oz2BmLX7A0HYtfsJAdi1+w7B2InYB+BHS51CHa41CHY4VKHYIdL/TZ2svuSDUTmE/bfKOE8uVBGuEk2lHCIbCjh+thQwsmxoSSg5EIJx8WGEi6KDSWcERtKuB02lHA7XCgT3A4bSrgdNpRwO2wo4XbYUBJQcqGE22FDCbfDhhJuhw0l3A4bSrgdLpQZbocNJdwOG0q4HTaUcDtsKAkouVDC7bChhNthQwm3w4YSbocNJdwOF8oCt8OGEm6HDSXcDhtKuB02lASUXCjhdthQwu2woYTbYUMJt8OGEm6HCWUycDtsKOF22FDC7bChhNthQ0lAyYUSbocNJdwOG0q4HTaUcDtsKOF2uFBauB02lHA7bCjhdthQwu2woSSg5EIJt8OGEm6HDSXcDhtKuB02lHA7XCgd3A4bSrgdNpRwO2wo4XbYUBJQcqGE22FDCbfDhhJuhw0l3A4bSrgdLpQebocNJdwOG0q4HTaUcDtsKAkouVDC7bChhNthQwm3w4YSbocNJdwOF0qC22FDCbfDhhJuhw0l3A4bSgJKLpRwO2wo4XbYUMLtsKGE22FDCbfDhTLA7bChhNthQ7mU2/G0o/Qp1o6OeSPpbyXwp6PLHc1S7oUXDQHNGZql3AUvmqXcAi+apbJ/XjRLZfO8aJbKzlnRxKWybV40S2XPvGiQDZ+iQTZ8ioaA5gwNsuFTNMiGT9EgGz5Fg2z4FA2y4TM0a+31zosG2fApGmTDp2iQDZ+iIaA5Q4Ns+BQNsuFTNMiGT9EgGz5Fg2z4DM1ae4HzokE2fIoG2fApGmTDp2gIaM7QIBs+RYNs+BQNsuFTNMiGT9EgGz5Ds9Ze0bxokA2fokE2fIoG2fApGgKaMzTIhk/RIBs+RYNs+BQNsuFTNMiGT9DktfYS5kWDbPgUDbLhUzTIhk/RENCcoUE2fIoG2fApGmTDp2iQDZ+iQTZ8hmatvWZ50SAbPkWDbPgUDbLhUzQENGdokA2fokE2fIoG2fApGmTDp2iQDZ+hWWsvUl40yIZP0SAbPkWDbPgUDQHNGRpkw6dokA2fokE2fIoG2fApGmTDZ2jW2quSFw2y4VM0yIZP0SAbPkVDQHOGBtnwKRpkw6dokA2fokE2fIoG2fAZmrX2MuRFg2z4FA2y4VM0yIZP0RDQnKFBNnyKBtnwKRpkw6dokA2fokE2fIZmrb3ueNEgGz5Fg2z4FA2y4VM0BDRnaJANn6JBNnyKBtnwKRpkw6dokA2focFedOdokA2fokE2fIoG2fApGgKaMzTIhk/RIBs+RYNs+BQNsuFTNMiGz9BgL7pzNMiGT9EgGz5Fg2z4FA0BzRkaZMOnaJANn6JBNnyKBtnwKRpkw2dosBfdORpkw6dokA2fokE2fIqGgOYMDbLhUzTIhk/RIBs+RYNs+BQNsuEzNNiL7hwNsuFTNMiGT9EgGz5FQ0BzhgbZ8CkaZMOnaJANn6JBNnyKBtnwCZqCvejO0SAbPkWDbPgUDbLhUzQENGdokA2fokE2fIoG2fApGmTDp2iQDZ+hwV5052iQDZ+iQTZ8igbZ8CkaApozNMiGT9EgGz5FozcbJm/cx9HkQ/yE5qAnlDYkNtinnuSjfkeTPw6O7umXs79D15tnD4SuN4MfB13xznwDoet1HQOh6/UzA6HrdUoDoROg94eu190NhK7XNw6EDkc6ADoc6QDocKT9oSveHXMg9LUcad6O9uTCp6N/D3YtJ1gZ7FoOrDJY0jTYtRxHZbBrZfqVwa6VYVcGu1ZmWxnsWhnl68EutrNjZbCaMqjFdl+sDFZTBrXYDomVwWrKoBbbxbAyWE0Z1GI7DVYGqymDWmw3wMpgNWVQi+3YVxmspgxqsV31KoPVlEEttvNdZbCaMqjFdqerDFZTBrXYDnKVwWrKoBbb5a0yWE0Z1GI7sVUGqymDWmy3tMpgNWVQi+1oVhmspgxqsV3HKoPVlEEttjNYZbCaMqjFdu+qDFZTBrXYDluVwWrKoBbbBasyWE0Z1GI7VVUGqymDWmw3qcpgNWVQi+34VBmspgxqsV2ZKoPVlEEttnNSZbCaMqi1djci/xhs9ZtAm7bv9px5/LLL9uDYvPPIvlSOLTvxUj4f+xv4UlmcBOBLZZISgC+VzUoATgDeF/hSWb0E4Es5CwnAl3I3EoAv5bAkAF/K5c0P3Jq1tg4TQRxeszfxtcxm3pdYymRrxF3eF03ynp6Ozke/HeyuZsjm09F3kmu5yJEkCSSZSK7l+0aSXMvQjSS5llMbSXItCzaS5FreaiDJtTaYG0pyLS80kiQ8DhdJeBwukgSSTCThcbhIwuNwkYTH4SIJj8NFEh6HieRaG+UNJQmPw0USHoeLJDwOF0kCSSaS8DhcJOFxuEjC43CRhMfhIgmPw0Ryra3XhpKEx+EiCY/DRRIeh4skgSQTSXgcLpLwOFwk4XG4SMLjcJGEx2EiudamhENJwuNwkYTH4SIJj8NFkkCSiSQ8DhdJeBwukvA4XCThcbhIwuMwkVxr29ChJOFxuEjC43CRhMfhIkkgyUQSHoeLJDwOF0l4HC6S8DhcJOFxmEiutbHvUJLwOFwk4XG4SMLjcJEkkGQiCY/DRRIeh4skPA4XSXgcLpLwOEwk19p6eyhJeBwukvA4XCThcbhIEkgykYTH4SIJj8NFEh6HiyQ8DhdJeBwmkhkeh4skPA4XSXgcLpLwOFwkCSSZSMLjcJGEx+EiCY/DRRIeh4skPA4TyQKPw0USHoeLJDwOF0l4HC6SBJJMJOFxuEjC43CRhMfhIgmPw0USHoeHpDXwOFwk4XG4SMLjcJGEx+EiSSDJRBIeh4skPA4XSXgcLpLwOFwk4XGYSFp4HC6S8DhcJOFxuEjC43CRJJBkIgmPw0USHoeLJDwOF0l4HC6S8DhMJB08DhdJeBwukvA4XCThcbhIEkgykYTH4SIJj8NFEh6HiyQ8DhdJeBwmkh4eh4skPA4XSXgcLpLwOFwkCSSZSMLjcJGEx+EiCY/DRRIeh4skPA4TSYLH4SIJj8NFEh6HiyQ8DhdJAkkmkvA4XCThcbhIwuNwkYTH4SIJj8NEMsDjcJGEx+EiCY/DRRIeh4skgSQTSXgcLpLwOFwk4XG4SMLjcJGEx2EiGeFxuEjC43CRhMfhIgmPw0WSQJKJJDwOF0l4HC6S8DhcJOFxuEjC4zCRTPA4XCThcbhIwuNwkYTH4SJJIMlEEh6HiyQ8DhdJeBwukvA4XCThcZhIZngcLpLwOFwk4XG4SMLjcJEkkGQiCY/DRRIeh4skPA4XSXgcLpLwOEwkCzwOF0l4HC6S8DhcJOFxuEgSSDKRhMfhIgmPw0USHoeLJDwOF0l4HB6SzsDjcJGEx+EiCY/DRRIeh4skgSQTSXgcLpLwOFwk4XG4SMLjcJGEx2EiaeFxuEjC43CRhMfhIgmPw0WSQJKJJDwOF0l4HC6S8DhcJOFxuEjC4zCRdPA4XCThcbhIwuNwkYTH4SJJIMlEEh6HiyQ8DhdJeBwukvA4XCThcZhIengcLpLwOFwk4XG4SMLjcJEkkGQiCY/DRRIeh4skPA4XSXgcLpLwOEwkCR6HiyQ8DhdJeBwukvA4XCQJJJlIwuNwkYTH4SIJj8NFEh6HiyQ8DhPJAI/DRRIeh4skPA4XSXgcLpIEkkwk4XG4SMLjcJGEx+EiCY/DRRIeh4lkhMfhIgmPw0USHoeLJDwOF0kCSSaS8DhcJOFxvkeSXCofR5MPrnK0pbT/drBP/c5Ho4wmfxwcXXw61n9oBPc0v0bwZfNrBMc3vUYJXnJ+jeBS59cI/nd+jeCs59eIoNH0GqEaML9GqDPMrxHqDPNrhDrD/BqhzjC9RllxncHvHbHR+Ap154z5ONqR/6zRnaTiagAzScWenZmkYmfNTJJAkomkYpfKTFKxl2QmqdjxMZNU7MuYSSp2T7wkCzwOF0l4HC6S8DhcJOFxuEgSSDKRhMfhIgmPw0USHoeLJDwOF0l4HB6S3sDjcJGEx+EiCY/DRRIeh4skgSQTSXgcLpLwOFwk4XG4SMLjcJGEx2EiaeFxuEjC43CRhMfhIgmPw0WSQJKJJDwOF0l4HC6S8DhcJOFxuEjC4zCRdPA4XCThcbhIwuNwkYTH4SJJIMlEEh6HiyQ8DhdJeBwukvA4XCThcZhIengcLpLwOFwk4XG4SMLjcJEkkGQiCY/DRRIeh4skPA4XSXgcLpLwOEwkCR6HiyQ8DhdJeBwukvA4XCQJJJlIwuNwkYTH4SIJj8NFEh6HiyQ8DhPJAI/DRRIeh4skPA4XSXgcLpIEkkwk4XG4SMLjcJGEx+EiCY/DRRIeh4lkhMfhIgmPw0USHoeLJDwOF0kCSSaS8DhcJOFxuEjC43CRhMfhIgmPw0QyweNwkVzK4+SwkyyGPh19H+1SPqQ62qW8QnW0pGq0S+Xc1dEulRdXR7tU7lod7VL5ZXW0S+WAtdGutVd7dbSqcqm19jyvjlZVLrXW3uHV0arKpdbag7s6WlW51Fp7WVdHqyqXWmtP6OpoVeVSa+2tXB2tqlxqrT2Kq6NVlUuttddvdbSqcqm19sytjlZTLkVr7T1bHa2mXIrW2sO1OlpNuRQZUjVaTbkUrbWnaHW0mnIpWmtvzupoVeVSa+1xWR2tqlxqrb0iq6NVlUuttedidbSqcqm19i6sjlZVLrXWHoDV0arKpdbaS686WlW51Fp70lVHqyqXWmtvt+poVeVSa+2RVh2tqlxqrb3GqqNVlUuttWdXdbSqcqm19r6qjlZVLrXWHlLV0arKpdbai6k6WlW51Fp7GlVHqyqXWmtvoOpoVeVSa+2xUx2tqlxqrb1qqqNVlUuttedLsWEfbawdbVP+ONg9rYDjsj04Nu88si+VY0veulzK52PvxJfK50QQXyqnFEF8qby2pK3bZMlUjnbJuw15Ks9HhyPmN1YbdGfjp6N/k1xrr5mhJJfKx4eSXCrXH0pyKR8xlCSBJBPJpfzPUJJreauRJNfyTCNJruWFRpKEx2EiudZeM0NJwuNwkYTH4SIJj8NFkkCSiSQ8DhdJeBwukvA4XCThcbhIwuMwkVxrr5mhJOFxuEjC43CRhMfhIkkgyUQSHoeLJDwOF0l4HC6S8DhcJOFxmEiutU/TUJLwOFwk4XG4SMLjcJEkkGQiCY/DRRIeh4skPA4XSXgcLpLwOEwk19o/bShJeBwukvA4XCThcbhIEkgykYTH4SIJj8NFEh6HiyQ8DhdJeBwekmGtfQ2HkoTH4SIJj8NFEh6HiySBJBNJeBwukvA4XCThcbhIwuNwkYTHYSK51n6jQ0nC43CRhMfhIgmPw0WSQJKJJDwOF0l4HC6S8DhcJOFxuEjC4zCRXGsf4KEk4XG4SMLjcJGEx+EiSSDJRBIeh4skPA4XSXgcLpLwOFwk4XGYSK61P/dQkvA4XCThcbhIwuNwkSSQZCIJj8NFEh6HiyQ8DhdJeBwukvA4TCQJHoeLJDwOF0l4HC6S8DhcJAkkmUjC43CRhMfhIgmPw0USHoeLJDwOE8kAj8NFEh6HiyQ8DhdJeBwukgSSTCThcbhIwuNwkYTH4SIJj8NFEh6HiWSEx+EiCY/DRRIeh4skPA4XSQJJJpLwOFwk4XG4SMLjcJGEx+EiCY/DRDLB43CRhMfhIgmPw0USHoeLJIEkE0l4HC6S8DhcJOFxuEjC43CRhMdhIpnhcbhIwuNwkYTH4SIJj8NFkkCSiSQ8DhdJeBwukvA4XCThcbhIwuMwkSzwOFwk4XG4SMLjcJGEx+EiSSDJRBIeh4skPA4XSXgcLpLwOFwk4XF4SEYDj8NFEh6HiyQ8DhdJeBwukgSSTCThcbhIwuNwkYTH4SIJj8NFEh6HiaSFx+EiCY/DRRIeh4skPA4XSQJJJpLwOFwk4XG4SMLjcJGEx+EiCY/DRNLB43CRhMfhIgmPw0USHoeLJIEkE0l4HC6S8DhcJOFxuEjC43CRhMdhIunhcbhIwuNwkYTH4SIJj8NFkkCSiSQ8DhdJeBwukvA4XCThcbhIwuMwkSR4HC6S8DhcJOFxuEjC43CRJJBkIgmPw0USHoeLJDwOF0l4HC6S8DhMJAM8DhdJeBwukvA4XCThcbhIEkgykYTH4SIJj8NFEh6HiyQ8DhdJeBwmkhEeh4skPA4XSXgcLpLwOFwkCSSZSMLjcJGEx+EiCY/DRRIeh4skPA4TyQSPw0USHoeLJDwOF0l4HC6SBJJMJOFxuEjC43CRhMfhIgmPw0USHoeJZIbH4SIJj8NFEh6HiyQ8DhdJAkkmkvA4XCThcbhIwuNwkYTH4SIJj8NEssDjcJGEx+EiCY/DRRIeh4skgSQTSXgcLpLwOFwk4XG4SMLjcJGEx+EhmQw8DhdJeBwukvA4XCThcbhIEkgykYTH4SIJj8NFEh6HiyQ8DhdJeBwmkhYeh4skPA4XSXgcLpLwOFwkCSSZSMLjcJGEx+EiCY/DRRIeh4skPA4TSQePw0USHoeLJDwOF0l4HC6SBJJMJOFxuEjC43CRhMfhIgmPw0USHoeJpIfH4SIJj8NFEh6HiyQ8DhdJAkkmkvA4XCThcbhIwuNwkYTH4SIJj8NEkuBxuEjC43CRXMnjkN2PJlvip6Pvo13Jh9RHS6pGu1I+Xx/tSjl3fbQr5cX10a6Uu9ZHu1J+WR3tUvvA10e7Up5WH62qXGqpPc/royVVo1WVSy21v3d9tKpyqaX2ya6PVlUutdR+0/XRqsqlltq3uT5aVbnUUvsf10erKpdaah/h+mhV5VJL7cdbH62qXGqpfW3ro1WVSy21P2x9tKpyqaX2Wa2PVlUutdR+pfXRqsqlltr3sz5aVbnUUvtn1kerKpdaah/K+mhV5VJL7edYH62qXGqpfRHro1WVSy21v2B9tKpyqaX26auPVlUutdR+d/XRqsqllto3rj5aVbnUUvuv1UerKpdaah+z+mg15VJ5qf3A6qPVlEvlpfbVqo92qVyKrN9Gm6w5GC2pGu1SuVR1tEvlUtXRLpVLVUe7VC5VHe1SuVRttEvtO1Qf7VK5VHW0S+VS1dGqyqWW2genPlpVudRS+8nUR6sql1pqX5b6aFXlUkvtb1Ifrapcaql9QuqjVZVLLbXfRn20qnKppfatqI9WVS611P4P9dGqyqWW2kehPlpVudRS+xHUR6sql1pqXf/6aFXlUkutj18frapcaql15uujVZVLLbVee320qnKptdY9r45WVS611rrn1dGqyqXWWve8OlpVudRa655XR6sql1pr3fPqaFXlUmute14drapcaq11zyujLQMqrDFtR4eY/fNo7z0aEG3mwd/Erz06zsCc34TwPuVKj3wsZjs6m6/bUpWTIhLzSXKPk5QOJzmpVDCfxPY4ietxEt/jJNTjJKHHSXpc8dTjiqceVzz1uOJDjys+9LjiQ48rPvS44kOPKz70uOJDjys+9LjiQ48rPvS44mOPKz72uOJjjys+9rjiY48rPva44mOPKz72uOJjjys+9rjiU48rPvW44lOPKz71uOJTjys+9bjiU48rPvW44lOPKz71uOJzjys+97jic48rPve44nOPKz73uOJzjys+97jic48rPnNc8TntRxdjv56kmB4nsT1O4nqcxPc4CfU4SehxktjjJIn5JNYdnITjis/74x9fnPl0kq9H5/0RS/aPJywu24Nj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1bbVXm1b7dW21V5tW+3VttVebVvt1bbVXm1b7dW21V5tW+3VttVebVvt1bbVXm1b7dW21V5tW+3VttVebVvt1bbVXm1b7dW21V5tW+3VttVebVvt1bbVXm1b7dW21V5tW+3VttVebVvt1bbVXm1b7dW21V5tW+3VttVebVvt1bbVXm1b7dW21V5tW+3VttVebVvt1bbVXm1b7dW21V5tW+3VttVebVvt1bbVXm1b7dW21V5tW+3VttVe7UnttexvGNpC9qDZSZTsS/rZUtynZkdL+TJtFHLrTpmqO2e14lHdsXN1x83VHT9Xd2iu7oS5uhPn6k6aqztz3ZXzXHflMtdducx1Vy5z3ZXLXHflMtdducx1Vy6978ov97i69SdN1p88WX/KVP1xxkzWHztZf44XUL8l9h/NnLOh0p9bPcDs3Y/pj6sX3E7ie5yEepwksJzEx8dJon86ycEXedlvCwN587zukzleTtXsa64Z//j2vpiP/sfJ+x92/jF4/7X/SXj/s/D+F9n9P37xQVD/rfD+O+H998L7T8L7P/v8W+u/8PnXCp9/rfD51wqff53w+dcJn3+d8PnXCZ9/nfD51wmff53w+dcJn3+d8PnXCZ9/vfD51wuff73w+dcLn3+98PnXC59/vfD51wuff73w+dcLn39J+PxLwudfEj7/kvD5l4TPvyR8/iXh8y8Jn39J+PxLwuffIHz+DcLn3yB8/g3C598gfP4NwuffIHz+DcLn3yB8/g3C598ofP6NwuffKHz+jcLn3yh8/o3C598ofP6NwuffKHz+jcLn3yR8/k3C598kfP5NwuffJHz+TcLn3yR8/k3C598kfP5NwuffLHz+zcLn3yx8/s3C598sfP7NwuffLHz+zcLn3yx8/s3C598ifP4twuffInz+LcLn3yJ8/i3C598ifP4twuffInz+LbLnX29kz7/eyJ5/vZE9/3oje/71Rvb866df/6rWf9nzrxe+/pUXvv6VF77+lRe+/pUXvv6VF77+lRe+/pUXvv6VF77+lRe+/pUXvv6VF77+lRe+/pUXvv6VF77+lRe+/pUXvv6VF77+lRe+/pUXvv6VF77+lRe+/pUXvv6VF77+lRe+/pUXvv6VF77+lRe+/pUXvv6VF77+lRe+/pUXvv6VF77+lRe+/pUXvv6VF77+lRe+/pUXvv6VF77+lRe+/pUX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a26rvea22mtuq73mttprbqu95rbaa26rvea22mtuq73mttprbqu95rbaa26rvea22mtuq73mttprbqu95rbaa26rvea22mtuq73mttprbqu95rbaa26rvea22mtuq73mttprbqu95rbaa26rvea22mtuq73mttprbqu95rbaa26rvea22mtuq73mttprbqu95rbaa26rvea22mtuq73mttprbqu95rbaa26rvea22mtuq73mttprbqu95rbaa26rveZ0soxK2T9MdzZ8anbwAvt2ivR4XYX8x+/7i3+fLv79cPHvx4t/P138+/ni3y/X/n42F/++vfj3L75+88XXb774+s0XX7/54us3X3z95ouv33zx9Vsuvn7LxdfvSZX99rz3o427mZIv03Y5LoRa77f3O61/Wh8mH706Sv7xZdLTCCh/nMFefgZ3+Rn85Wegy88QLj9D/PEZQtjW3Q3x6Azp8jPkn58hme0MqRycoVx9BvfzazqUTelo/MEZ7OVncJxneFrb5nEGf/kZ6PIz/PyajmnbCyZmc3CGePkZfn5Nx7x93BsLHZwhX36Gn1/TaV/BLdn89QzeXH4Gy3kGFw/O4C4/g7/8DD+/ph+fot8e6B+cIVx+hp9f03mnlA9jKV1+hp9f07dnYtsZnjbBepyhXH0GMpxnCAf3VrKXn8FdfoafX9O3vPHj2HJ0TRNdfoafX9Nl37PtpurBGeLlZ/j5NV323LvEI0r58jMUzjOkg3trMJefwV5+hp9f09aEzaJYEw+u6uA7nOP4uia3zY6WUnx9Dm/zdg5vn9aNcZGOjjZx+2lvnpyZ//XA5OvRyWzJvU9PV9yvo+/9D8L7H4X3Pwnvfxbe/yK7/8eP6QX13wrvvxPefy+8/8Ln3yh8/o3C598ofP6NwuffKHz+TcLn3yR8/k3C598kfP5NwuffJHz+TcLn3yR8/k3C598kfP7NwuffLHz+zcLn39x//nX7S+72eRu1w/6/uwL5vtcSJft16dySSdVog6rRRlWjTapGm1WNtmgabTGqRmtVjdapGq2qXKqoyqWKqlyqqMqliqpcqqjKpYqiXCoboyiXuo12rfn25e5pt9EudU9+vbnFbbST35Nn2TTQlu2FYudM+XT0nePkd3sxHCefR6RwtJPPUGI4Tl5HEMNx8gqFGI6T52JiOBI4snCcvF4jhuPkrkMM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TbGRmmIjNcVGaoqN1BQbqSk2UlNspKbYSE2xkZtiIzfFRm6KjdwUG7kpNnJTbOSm2MhNsZGbYiM3xUZpio3SFBulKTZKU2yUptgoTbFRmmKjNMVGaYqN0hIbJ9voVVvZplauqZVvakVNrUJTq9jUKjW1yk2tmmLDNsWGbYoN2xQbtik2bFNs2KbYsE2xYZtiwzbFhm2KDdcUG64pNlxTbLim2HBNseGaYsM1xYZrig3XFBuuKTZ8U2z4ptjwTbHhm2LDN8WGb4oN3xQbvik2mqpzJ3uw1FpRU2xQU2xQU2xQU2xQU2xQU2w01UV9U13UN9VFfVNd1DfVRX1TXdQ31UV9U13UN9VFfVNd1DfVRX1TXdQ31UV9U13UN9VFfVNd1DfVRX1TXdQ31UV9U13UN9VFfVNd1DfVRX1TXdQ31UV9U13UN9VFfVNd1DfVRX1TXdQ31UV9U13UN9VFfVNd1DfVRX1TXdQ31UV9U13UN9VFfVNd1DfVRX1TXdQ31UV9U13UN9VFfVNd1DfVRX1TXdQ31UV9U13UN9VFfVNd1DfVRX1TXZSa6qLUVBelprooNdVFqakuSk11UWqqi1JTXZSa6qLUVBelprooNdVFqakuSsd10VsZeFue5VaJC59afX2lZ1+TPT0+6CN//3m69ufDtT8fr/35dO3P52t/vlz688dlY76ft9f+vLv256+9at21V6279qp111617tqr1l171bprr1p/7VXrr71q/bVX7UkdPMX80cSl5w/of83Qt39yv449Lv8G/1gO+mkNLLpP7fH9Jun9Jvn9JuXNJrd/8r+OPJ5xaCce3TO9cmt4+8f/75/+/S//9M9//bf/uDX59V//79/+5T//8ve/ffzjf/7//2f7L//873/561//8r//8f/8+9//5d/+9f/++7/941///i+//tufzMf//M90K5n8Od2czD/83lbpf+abZfhzvs3j//C7h7f/Hu3tvyf767//akApmT/f/if8+he/WqRbmvbn2//QY2emX4eF21HRbK3cDYXzcRf/1yHe/ZncdkCwfw7xgeV3m1uT27/679ug/x8=",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [
        "aztec::macros::functions::utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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uezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt257NWdy17duezVncte3bns1Z3LXt257NWdy17duezVvche6/6GoavR/dztVfa6L+nnavXfdjtayrfTh0Juw3G6huN1DSfoGk7UNZykazirruFkXcMpuoZTVQ2n6roqV11X5arrqlx1XZWrrqty1XVVrrquylXXVblefVV++42r23iqqvH4ZVE2HqdsPF7ZeIKy8Rxem/3N9nzt5r1LjfHc0ofHh5TX/PerF9wOkq44yHrFQXKXg4T1cZA1PB3k4Bd5JWwLA4Xled2n5Xg51WVfc20JT1+0Xr7GX5SPP+381xTCz/HXscd//Jh/oPG7wcfvBx9/GHz8cfDxp8HHvw4+fu3339b4B7//usHvv37w+68f/P7rB7//+sHvv37w+68f/P7rB7//+sHvv37w+68f/P4bBr//hsHvv2Hw+28Y/P4bBr//hsHvv2Hw+28Y/P4bBr//hsHvv3Hw+28c/P4bB7//xsHvv3Hw+28c/P4bB7//xsHvv3Hw+28c/P6bBr//psHvv2nw+28a/P6bBr//psHvv2nw+28a/P6bBr//psHvv+vg99918PvvOvj9dx38/rsOfv9dB7//roPff9fB77/r4PffdfD7bx78/psHv//mwe+/efD7bx78/psHv//mwe+/efD7bx78/psHv/+Wwe+/ZfD7bxn8/lsGv/+Wwe+/ZfD7bxn8/lsGv/+Wwe+/ZfD7bx38/lsHv//Wwe+/dfD7bx38/lsHv//Wwe+/dfD7bx38/lvHvv+GZez7b1jGvv+GZez7b1jGvv+GZez7b1jGvv+GZez7b1C//lVr/GPff8Pg61+Fwde/CoOvfxUGX/8qDL7+VRh8/asw+PpXYfD1r8Lg61+Fwde/CoOvfxUGX/8qDL7+VRh8/asw+PpXYfD1r8Lg61+Fwde/CoOvfxUGX/8qDL7+VRh8/asw+PpXYfD1r8Lg61+Fwde/CoOvfxUGX/8qDL7+VRh8/asw+PpXYfD1r8Lg61+Fwde/CoOvfxUGX/8q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xRlfrjjjyxVnfLnijK9XnPH1ijO+XnHG1yvO+HrFGV+vOOPrFWd8veKMr1ec8fWCM74syxUHcVccxF9xkHDFQeIVB0lXHGS94iD5ioOUKw5yxRnvrjjj3RVnvLvijL/i1avirjjj3RVnvLvijHdXnPHuijP+infuyhXv3JUr3rkrV7xzV654565c8c5dueKdu3LFO3flinfuyhXv3JUr3rkrV7xzV654565c8c5dueKdu3LFO3flinfuyhXv3JUr3rkrV7xzV654565c8c5dueKdu3LFO3flinfuyhXv3JUr3rkrV7xzV654565c8c5dueKdu3LFO3flinfuyhXv3JUr3rkrV7xzV654565c8c5dueKdu3LFO3flinfuyhXv3JUr3rkrV7xzV654565c8c5dueKdu3LFO3flinfuyhXv3JUr3rkrV7xzV654565c8c5dueKdu3LFO3flinfuSo937sJS96WyvWttnbcB5ccP6GP4Gk1WNZqiajRV02h6vBfYcTRO1Wi8qtEEVaOJqkaTVI1G1bW4qLoWF1XX4qLqWlxVXYurqmtxVXUtrqquxVXVtbhquhbX45f8XAjbIk0uPH3kpRyt/xTDY3nRp6HE8nWE+PEjpI8fYf34EfLHj1A+foT6l4+QHmfBenCE4/f5uh7B/fUj5GU/k+vBEfzHj/DXz+lUN6XXJRwcIX78CKnnEZ4+UPM4wvrxI+SPH+Gvn9NrdtsRynJwhPrpI/i/fk6vZVuhe63x4Aju40f46+d03j/Dll05OEL4+BFizyP49eAI6eNHWD9+hL9+Tj/Wky/LUS2Vjx/hr5/TZadUjmopLB8/wl8/p0vYFqQu0R8cwX/8CKHnEdLBtTXEjx8hffwIf/2cvt2Jv7atR+d0yB8/wl8/p28Vvx0hHnQCoX76CPGvn9N1773rekApuo8fwfc8Qj64tsbw8SPEjx/hr5/TbkmbRXHLenBWx/WCYxyf19Fvd0cX8/r+GMGV7RjBPX38xa/xMJZZtz8dlidnFv54Ivlz67xszX3IT2fcH1vfx18GH38de/zHbx0ONH43+Pj94OMPg48/Dj7+NPj418HHP/j9Nw1+/02D33/Xwe+/6+D333Xw++86+P13Hfz+uw5+/10Hv/+ug99/18Hvv+vg9988+P03D37/zYPff/Pg9988+P03D37/zdfff/3+K5I/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",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "refund_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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FUk+ecy1xLyVsMvtYffTaa7uNKo7zdeddnyzXJJzj9N2i7Cvp8W601LdabnqNHeSt/xYjn7JwTyddkIyp3VZemOW5YmkC3WnxbrTctXYjp9ilU87+eHk7HZB+qfTbN1pru40qjvN150W6k6Ldacd/3Buh+bHaXavkn/4XFPH62kxX+T4GR73RczvL/L6WWQ+fkLIewl3/SXo00vcT/N1p4W60+pukSfP54qn5arTwlJ3mqk7zdad5upOo7rT6ibSUDeRnjzqiH67sca4/0z1qLy1cdneMIrWPl3CXH8Je/0l3PWXoOsv4a+/RLj+EvH6S6TrL5Evv0S6/tedrv91p+t/3en6X3e6/tedrv91p+t/3en6X3e6/tedrv91549/3ffTTN1ptu40V3ca1Z3m604LdafFutNS3Wm54jS/LEvdaabuNFt3mqs7jepO83WnhbrTYt1pqe60OpWYOpWYOpWYOpWYOpWYOpWYOpWYOpWYOpWYOpWYOpXYOpXYOpXYOpXYOpXYOpXYOpXYOpXYOpXYOpXYOpW4OpW4OpW4OpW4OpW4OpW4OpW4OpW4OpW4OpW4OpVQnUqoTiVUpxKqUwnVqYTqVEJ1KqE6lVCdSqhOJb5OJb5OJb5OJb5OJb5OJb5OJb5OJb5OJb5OJb5OJaFOJaFOJaFOJaFOJaFOJaFOJaFOJaFOJaFOJaFOJbFOJbFOJbFOJbFOJbFOJbFOJbFOJbFOJbFOJbFOJalOJalOJalOJalOJalOJalOJalOJalOJalOJalOJblOJblOJblOJblOJblOJblOJblOJblOJblOJXW9V1PXezV1vVdT13s1db3X2/+tO83XnRbqTot1p6W60+pUUtd7NXW9V1PXezV1vVdT13s1db1XU9d7NXW9V1PXezV1vVdT13s1db1XU9d7NXW9V1PXezV1vVdT13s1db1XU9d7NXW9V1PXezV1vVdT13s1db1XU9d7NXW9V1PXezV1vVdT13s1db1XU9d7NXW9V1PXezV1vVdT13s1db1XU9d7NXW9V1PXezV1vVdT13s1db1XU9d7NXW9V1PXezV1vVdT13s1db1XU9d7NXW9V1PXezV1vVdT13s1db1XU9d7NXW9V1PXezV1vVdT13s1db1XU9d7NXW9V1PXezV1vVdT13s1db1XU9d7NSe917y9YWgymYPTTlSyLeln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e011vddU13tNdb3XVNd7TXW911TXe011vddU13tNdb3XVNd7TXW911TXe011vddU13tNdb3XVNd7TXW911TXe011vddU13tNdb3XVNd7TXW911TXe011vddU13tNdb3XVNd7TXW911TXe011vddU13tNdb3XVNd7TXW911TXe011vddU13tNdb3XVNd7TXW911TXe011vddU13tNdb3XVNd7TXW911TXe011vddU13tNdb3XVNd7TXW911TXe011vddU13tNx71Xt+Ttw3Rr/I/TDl5gXy8RH6+rkPv++/7ivx8u/vvx4r+fLv77+dK/n5fl4r9vLv779uK/7y7++3Tx3/cX//1w8d+PF//9dPHfv/j3ay7+/ZqLf7/m4t+vufj3e9Jlj2F7ZfTWTnmatvNxI9Q4t77fadxufZh09OoouceXSbsRUPq+grv8CnT5FfzlVwiXXyFefoX06yt4v66768PRFfLVVzhuMH92hbisV4j54Arm8iv8/jft85rpsLiDK7jLr0CcV9itbfO4gr/8CuHyK/z+Nx3iuhdMSMvBFdLlV/j9bzqk9ePekOn5Cn65/Aq//03HbQW3aNLBFezlV3CcV7Dh4Ap0+RX85Vf4/W/68Sl6Wo60FC+/wu9/02mjlA61lK++Qvj9b/r2NH+9wm4TrMcVzOVXsJxX8Af31uAuvwJdfoXf/6azWY/NR7/pEC6/wu9/03nbs+1WQR5cIV1+hd//pvNWe9+YP18hLpdfwXBeIR7cW6O9/Aru8iv8/jdtFr9aFLOEg1919A2ucfy7JrvOjoZieH0NZ9J6DWd268bYQEdHL2H9027ZOTP354HJ89FxWYt7F3e/uD9H3+OPwuNPwuPPsuM/figtKH4jPH4rPH4nPH4SHr8XHr/w+TcJn3+T8Pk3CZ9/s/D5Nwuff7Pw+TcLn3+z8Pk3C59/s/D5Nwuff7Pw+TeLnn/Tsoief2/xi55/b/GLnn9v8Yuef2/xi55/b/G3n3/t9pK72W+jdhj/pyuQb3stUTRPS+feRhtUjTaqGm1SNdqsabRmUTVao2q0VtVonarRkqrRqqqljKpayqiqpYyqWsqoqqWsqlrKqqqlrKpays41377cPe022qnuya83t7iNdvB78iibBpq8vlBs7ZJ/HP3F0Q1+txfDcfB5RAzHwWcoMRwH7yOI4UjgyMJx8FpMDMfB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Wa7qLKo6y1edVaUNX6UNX6UNX6WNUKWNUKWNUKWNUKWNUKWNUKWN/7+5a9l121iC/3LXWrAfM939LYERJL7GhQEjDnyTAFn430NSh0PZHIpnKof0bA4sidUsiTU1ZHkeGdJGhrSRIW1kSBsGacMgbRikDYO0YZA2DNKGQdowSBsGacMgbTikDYe04ZA2HNKGQ9pwSBsOacMhbTikDYe0EZA2AtJGQNoISBsBaSMgbQSkjYC0EZA2AtGGDAOEIgjFEEoglEKoBKEyhDII5RAK0gZB2iBIGwRpgyBtEKQNgrRBkDYI0gZB2iBIGwxpgyFtMKQNhrTBkDYY0gZD2mBIGwxpgyFtCKQNgbQhkDYE0oZA2hBIGwJpQyBtQOnczgZdRyiFtKGQNhTShkLaUEgbCmkDykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUFykUVykUVykUVykUVykUVykUVykUVykUVykUVykUVykUVykUVykUVykV3Nt8aY+BleZYxiUvfoLZDesoS6LZO6FO5l9dzy6dzy+dzy9u55f3c8nFq+Xps/Hbl6dzyfG75c1stn9tq+dxWy+e2Wj631fK5rZbPbbVybquVc1utnNtqd3Jwy/4CYXucQD/10OMrnY6th5BGy2T6scYKTKm2VLiXhRsfx+iOx77b29ykqTwtW52nbxamvpfXc8unc8vnc8vbueX93PJxavl6mGvDWj6Oymdaxptr1vXo8f/bK0ezU7lbXldj0ye7evwgLtwRF7mWC2VZPJZy+vbod3s7efw4OqkvOrkvOtYXHe+LTnRFx4a+6FBfdLgvOn25sl3uyr7svUtGvqGT+qKT+6JjfdHxvuhEV3R86IsO9UWH+6JztStbikLnIVxY6GhfdFJfdHJfdKwvOt4XneiKTgx90aG+6HBfdPpy5ejLlaMvV46+XDn6cuXoy5WjL1em4XJbjnW1Ex62fKgzPtwZH+mMj3bGJ3XGJ3fGxzrj453xib74UGf+TJ35M3Xmz9SZP1Nn/kyd+TN15s90tT+7DIWPxJaPd8YnfiAfzRs+PHTGhzrj8wb+nJcnGDXKB3yYqQwe45S2fORyPlb45K2eWTvjky7mI8MykIblYY/Lwid3xsc64+NX8+FU+KSKfuJyPlr4mGz4yHAxHy17ULNShQ91xoc743O1PysXP9TkWz56OZ9c+Ni2vUvqjM/V/qxR+vc0VK6XdcbHO+NztT8nLu09pa1+dLicT+lPU97eH+rV/pxi2e+a87DN55U74yOd8bnan/P6fJF12740Xc6n9F85V9rX1f68DvcZHy9sy8c64+Od8Ym++KShMz7UV3+auC8+9XEtFLL0ehT68KsmvaMYQgmEUgiVDlGPd+8LKkMog1AOoQJA7exYxsPaNw2StyiCUAyhBEIphEoQKkMog1AOoQJBEaQNgrRBkDYI0gZB2iBIGwRpY2eJ3iGVhGp4vENbUDvfq8ybHv+5dYCdBXCPzrWjXi+Z3hBpi3IIFQhqZwHcIxRBKIZQAqF2rnKZRjqitoraWQD3CJUhlCE63FkA9wgVCGpnAdwjFEEohlACoSAH2FkA9wi1c78RXIYJRsiqX475vnJn461X4AjEMYgTEKcgLoG4DOIMxDmIA/VSX6dALZY0WV18iyIIxRBKIJRCqAShMoQCFZJBhWRQIQY6ioGOYqCjGOgoBjqKgY5ioKMYqJf6JNQjddbnih6hHHITh9zEITdxyE0cchMHFeKgQhxUiIOO4qCjBOgoATpKgI4SoKME6CgB9T4B9T717OwQBXlJIF6ys23XIYogFKaQnY27XoFTEJdAXAZxBuIcxGGOsrON1ytwBOKQvmdnK69DlEKoBKEyhDII5RAKVAiDCmFQIQw6CoOOwqCjMOgoDDoKg47CoKMw1PcI1PcI1PcI5CUCeYlAXiKQlwioEAEVIqBCBHQUBR1FQUdR0FEUdBQFHUVBR1Go71Go71Go71HISxLkJQnykgR5CZjFCpjFCpjFCpjFCpjFCpjFCpjF7mwA9goc6CgZdBQokRUokRUokRUokd3ZBuwQBXlJhrwEzGIFzGIFzGJ3NgN79u0qM9Z0KDMw9XEGptj9HHrBOdIF5wBdDcyDpT0P3n4ns2WAhYVsv1GcfYb2nLnxDDtbPdA6ipcy5y0qQyg7RIluUQ6hohk1vkrTsfUTpjKSJTMXIOlL9NcMqT96PYdQO4TbIdIIGV/l6ch6qEI02DISZfx3PKw27zPW9rFe5mb5g5zIKirPWvgleTx0/Eb13Oativu/LV6GwWT374vHvy6+zIa24Xvm9ajoTYqPL/zJZS1TKDziVd84ZDG8SPac1KHeYm7jVdvLsnQpPqwdCt0tpe55zyHWDvF2SDRD6ubzHFI1Hy+dsKtvINwOkXaItkNSOyS3Q6wdUjcT11p7kZr8xweJl2PHG8e1f0v38nFq+XpS9Hbl6dzyfG55Obe8nls+nVs+v2F5l015O7e8n1u+3iWWedDxuCvP3UfqWdxzCLVDuB0i7RBth6R2SG6G1GOU5xBvh7RffWu/+tZ+9a396u/sna5lpHq278W/s3H6U0hqh9RHqFuZ+hebVrmzX/pTiLdDohmys036Uwg1Qr5OKxPO99FVZE7LM0SOh63sdN7Rtv4/xs8h0g7Rdkhqh+RGyPTD0XRovUNNZZpdsvz9yeqd5HOItUO8HRKNkK/jy79++fLxl18/ffj/CJk+/fO39398/Pzby8s//v59+eTXLx8/ffr4v59///L5/Yf//vnlw8+fPr+fPvvP8PLnJxOPmykNI5lJkK5MN1eJ6Z53/nx8JBwPSu/uuv1JzYbb+Gd+Y0LYtKzI+MfnKzTVnXDCN+UFk+iW8vQxz0+201vjWXh+SxaEprFuHhYMj78BSy67RM7nHqaqshxC420CeSxEZIz2JLyEUXPR8cxUaPAt2Zq5zCXixrpGKfOJ9caxPobPb9lNuDwAz2/l4ZbLT+B281hb9nTi8VFl/g3vv9n4zdIq4L3f5+t4ef8B",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "get_note_internal",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "call_private_function_internal",
        "load",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "is_contract_initialized",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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yZvTnap1Ti6mbWO3HsRRc336oDnduT590J7uVP1ie7pTtXXt6U7Vq7WnG21Nd6quqj3dqbqq9nSn6qqep+udP5jutF3V8XSn7aoOpzvXpw/a0522qzqe7rRd1fF05+qqssv7xqUeTDfamu5cXVVzunN1Vc3pztVVNac7V1fVnO5cXVVrunN9+qA93bm6quZ05+qqmtO11VXN9emD9nRtdVVzffoglbBsG9e1NP50rDub59eby3Kwrc+L/9rYZ//wWusXxrm6NTGMc3WBYhjn6i47YfwLzVyfi+iLZq6utSuauTrcrmjm6oa7oomgeYVmri77j9Dcsvpt41gO0BjuyFtoDHfZLTSGO+cWGsPdcAPNXJ/56IvGcDfcQmO4G26hMdwNt9BEw2jS3g2Xg254rk+Y9EVjuRtuoLHcDTfQWO6GG2gsd8Nv0axzfZ6lLxrL3XADjeVuuIHGcjfcQBNB8wqNmW74Pl0zHe59uma61vt0zXSi9+ma6S7/mu5cn55pT3eqLvDW728DWcPqDqY7VWfXnu5U3Vp7utHWdKfqqtrTnaqrak93qq6qPd2puqr2dKfqqprTnevTM+3p2uqq5vr0THu6trqquT49056ura5qrk/PtKdrq6ua69Mz7ena6qrm+vRMe7q2uqq5Pj3Tnq6trmquT8S0p2urq5rrkyvt6drqqub6gEl7ura6qrk+B9Kerq2uaq6Pa7Sna6urmuszGO3p2uqq5vq2RXu6trqqub5t0Z6ura5qrm9btKdrq6ua69sW7ena6qrm+rZFe7q2uqq5vm3Rnq6trmqub1u0p2urq5rr2xbt6drqqub6tkV7ura6qrm+bdGerq2uaq5vW7Sna6urmuvbFu3p2uqq5vq2RXu6trqqub5t0Z6ura5qrm9btKdrq6ua69sW7ena6qrm+lZEe7q2uqq5vtPQnq6trmqu7ym0p2urq5rruwft6drqqub6PkF7ura6qrm+I9Cerq2uaq71/tvTtdVVzbUuf3u6trqqudbPb0/XVlc11zr37ena6qrmWo++PV1TXVWea9349nRNdVV5rvXd29M11VXlJdqarqmuKs+1tnp7uqa6qjzX2urt6drqquZaW709XVtdla211bOttdWzrbXVs6211bOttdWzrbXVs6211bOttdWzrbXVs6211bOttdWzrbXVs6211bOttdWzrbXV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Us5VSTlXJeVclZRzVVLOVUk5VyX1XJXUc1VSz1VJPVcl9VyV1HNVUs9VST1XJfVcldRTVRKW5dxu7txu/txu4dxu8dxu6dxu67nd8rndyrndzlWJO1cl7lyVuHNV4s5ViTtXJe5clbhzVeLOVYk7VyXuXJX4c1Xiz1XJuew1nMtew7nsNZzLXsO57DWcy17Duew1nMtew7nsNZzLXsO57DWcy17Duew1nMtew7nsNZzLXsO57DWcy17Duew1nMtew7nsNZzLXsO57DWcy17Duew1nMtew7nsNZzLXsO57DWcy17Duew1nMtew7nsNZzLXsO57DWcy17Duew1nMtew7nsNZzLXsO57DWcy17Duew1nMtew7nsNZzLXsO57DWcy17Duew1nMtew7nsNZzLXsO57DWcy17Duew1nMtew7nsNZzLXsO57DWcy17Duew1nMtew7nsNZzLXsO57DWcy17Duew1nMtew7nsNZzLXsO57DWcy17Duew1nMtew7nsNZzLXsO57DWcy17juew1nste47nsNZ7LXuO57DWey17juew1nste47nsNb7IXuv+hqGr0f3c7VX2ui/p5+rTMp6/djv6vlmnryffhuN0DcfrGk7QNZyoazhJ13BWXcPJuoZTdA2nqhqO13VV9rquyl7XVdnruip7XVdlr+uq7HVdlb2uq7K/+qq87qusLIs/GE/VNZ6wKBuPUzYer2w8Qdl4Dq/N3pVtnRHvn75xeDwet+ZlH/6af6xeEI+f9/Y+yHrFQXKXg4T1cZA1PB3k4Bd5JWwLA4Xled2n5Xg51WVfc20Jj9/e1+Vr/EX5+NPOf709S/85/jr2+I8f8w80fjf4+P3g4w+Djz8OPv40+PjXwcev/f7bGv/g9984+P03DX7/TYPff9Pg9980+P03DX7/TYPff9Pg9980+P03DX7/TYPff9fB77/r4PffdfD77zr4/Xcd/P67Dn7/XQe//66D33/Xwe+/6+D33zz4/TcPfv/Ng99/8+D33zz4/TcPfv/Ng99/8+D33zz4/TcPfv8tg99/y+D33zL4/bcMfv8tg99/y+D33zL4/bcMfv8tg99/y+D33zr4/bcOfv+tg99/6+D33zr4/bcOfv+tg99/6+D33zr4/beOff9Ny9j337SMff9Ny9j337SMff9Ny9j337SMff9Ny9j337SMff9Ny9j3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",
      "brillig_names": [
        "is_contract_initialized"
      ]
    },
    {
      "name": "get_htlc_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "view",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "key",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "Train::HTLC_Public",
            "fields": [
              {
                "name": "src_receiver",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "amount",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "token",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "hashlock_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "hashlock_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "secret_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "secret_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "ownership_hash_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "ownership_hash_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "timelock",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "claimed",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "9174444391250494040": {
            "error_kind": "string",
            "string": "Function get_htlc_public can only be called statically"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7V3bblypEv0XP+eBorjOr4yOotwmsmTZkZMc6SjKv5/dtjfd8YYu92rGhoaXTPeY1cVaBQXFZsOvq89fPv78+v769p+771d//f3r6ubu04cf13e3y7dfv99dfby/vrm5/vr+8H9fqd0/WpkHwPdvH25337//+HD/4+ovYm3su6svt593nzmo5Uf+ub75cvVXDL/fbYsrrdfSyuh9YZspbKLyT4VNJJcKO84UDsaEp8LBOHNY+D/vltrHKrWPcS1NFF+v9lRHexuS9kHQnqxfa0+O+Xjto2XzVDguuOe117py7Un/UfudDVavYMNmbWhLbkVpy+G4Dc92rZFnT4KwWq2Fo9bhubBGvaBC5g/SDzALwSxmzQYI5jgLM0EnF5lgbYJZyjrU8b7D7lvx0rqzbX6tkVZ75/Ouo2/dGFPD8jHuS+tdx9qUZrtGPXMQCR6sbMpqirRWYwlbQmmr14hkWf1R9kFEP0U8W0Svp4jnizhb4vkihtkSK4g4W+L5IkaaIp4v4myJZ4vIasbECiKGKeLZItLMWCqIGKeILxExrqszjuxGxMK6wBTxJBHNFPF8EWd3Pl9EO1tiBRFnSzxfRDdbYgUR52T7fBH9bIkVRJwx8XwRg50ini1inBlLBRHdFPFcEY2aK9sVRJwxcSvigzBzxM0LQ3M+VxBmZgt5YfR88FMQZj5WzAvDc2gvCDOH67ww80FKSZiZauSFsbPFFISZMSYvjBt2VNJh3Qmg+aAeSZhhY4wgjJ8tpiDMsDFGEmbYZQdBmDDsni1JmGGTSEGYcXc+S8LM4JsVxqphUwJJmNliCsLM4TovzLhPCSRhhn1KIAgz7lMCSZiZXeeF4TlcF4SZwbcgzAy+eWHMzK4LwswWkxfGDjtc+3QcivbP3os7rfSDjMMO7ifJSM6plaHzYSPjuK87VJVx3ANU6so47JJsVRnDsAu4p8nofWLo43akDnOIqSHjuC8+1JVxjtRVZBw2L6kpoxv3TJq6Ms4hpoaMNCc8VWScrbGGjHpOeKrIaKaMNWScE54aMvKc8FSRcQ4xNWQc962dujLOIaaGjOO+EXSajFGluzWizsg4R+oaMroqIzWFVFobK8hol0XOp9Iu6P3dJqSyvx3T/RgU/Z4AuYd7IZxXvRMInROos/L/hgRetIX/4MlRlgA7WkMJu4NLX3ZGtqUd8/oSoOMDuvnLgHxYC4dwEHkeb31xLzrm56TqG/9cI6/oNYy8BhOqw8T6ZMRHwdvG0RqEzTKNEkr7wGvj9sEKNwJ5k66g8lapZ23Dkx2I7IuWki6G7Eie5ZE8yyN51ozkWTOUZ+NAZF90JPfFkA0DkXVuILIv2pl5MWT9QGTDSJ4NI/XZOFA+G9RledZql8jq5/ckB31ZAcrRuoq1fNyQ5fabsd6TdcL93Uxh9SzrA88y+0e27WcCFdl2kOTVZGuGYtt+MlCRreWh2Lafwp/CVjud2Aa1Yesuy7cS28vqtwJbP5Rv/VC+DUP5Ngzl2ziUb2P7CV89tlG1vyRVk237KxcV2b7oYLaLYdvBxoOabC9r7UJg28HWg5PYpo1zzGT+YLstTSGtT9KyZLXV5sJ6eVVtLix3rqlNB0/L/z1tVNoYvnzc/zTbR238hUXX07RxlLTxaqvNW/Sp9DaH8SqcUXpH4E1S1aoEQucEom6cADle5yPk7P63mdwjAd83AVKKumdge2dA3fuAXO8MdPc+0N33A936jEJkwK1PKWQGrc8pRAam/UlFWH+bPIUMg/ZnFQID270PbPsjmsDAqe4ZmO4ZtD+iCQx89z7w7Y9oAoPQfDT1Np1r4IPJMGh+RJMYxObzA5FB8/mBwIBU8yOayKB/HzQ/okkMqPkcTWTQezSl9ldbRAbd9+T2V1skBu2vtogMuu/JpvuebLrvyab7nmzb78nRrDVZHrlnGDSfZUoMXPtZpsSg+TU7iYFvP5pKDLr3QWg/y5QYmO4ZdB9N29/aIjLovSfrDtaLJAa992Steu/Jmnrvybr93TkSA919T9bN9+T98SHLx+2+Cs3N9wORQfP94JDB4Xb0lUH7qy0ig+59YKv7IDqpTlGlVziioYM6mac6ufbq1P7+E2FVSrveVwa1794HvnsfdLCeIDHo3gexex90v3uDu9+9wd3v3mDq3gfUvQ86yGUlBt37gLv3AXfvA9O9D7rfOcC2ex/Y7n3QfZ7M3efJ3H2ezN3nydx9nszd58ncfZ7M3efJpvs82XSfJ5vu82TTfZ5sus+TTfd5suk+Tzbd58mm+zzZdJ8nm+7zZNN9nmy6z5PtpZ3DW/GkxUWcCztK/TRxUjsjFeIf4mxLh1TrwEYoa8N6WI4NvBVdX9ip332IfmGHj7chukt1doeH3K6iD3068luJbmZ4eQPRL+zeikZEp73omdmLnS39DUSfLf31RXeXdTVoK6LbdTO18zoj+sj3F7yV6G9y9N3oondwNfoFij4H0tcXvYOr4i9Q9Hmhy6Po2wtdyKmhW6QkztDr04I4dGE3g9YVZ+jJuyDOm7wX3404s+WUxeEZc46IM/SMXhCngxsPeS+OpePieJvud1w++sPCj2zbn7icwnZfEe/clq1rPyqcxNboo2wvzLc67tmG44V3x56mHHL3UH0jTgfrdyeJQ5TEoW1TCO1fjVyTbfvjW0W2sf1F0ZpsLyyoHWXr1YUNWALboXxLI/VbT+3va6vHNhResFE63U6o3H53jlb6CRYhmM5HCdqfVbZou4UxYbAIwYzBYPmYsCx/JFjISFJ4Js4xXabFMWPNMwbzECwQBrMQLELcoiIMlu/vNiX2u71oW1ghKIqwCMEK64sSrPDikwizEMxg1gr9zbr0GoI9eLaWYIW9aiLMQ7DC4QASrPBGvgjDJCncESjBAqZk4ckvqwRjnelvhQO5j8O0KrxPLMIMBgsQrBAURBgmiSYMhlljzAGMOYAxBxS2arNJxxo/PG/fwAIEK7yNJsEKr4CJMAfBCpdxiLAIwQIyduvSzZoSLBIGg6xRfvbq92ubBy+EJVB+dIvpNbJoM5by7VEA5QdECeQAUL4BSyBEiPzsWAAV5sbHk5MF5iFYYfQUYZi1iFmLkLXlvxgMs0aMwTBrhdFThFkIlh89j8cOnR87o1rDVNQ5ENBlCqdcC5YcUr38sx4B5DUCAkKbzme6EgixlD+kKKblgugzzSi/8e84qHBkrQSSwnUWBLS9wlmoAkhrBOQBUH6DhgQCBnA2iCWDcLKEgBA/WaBFlM6Oipw2RMSDhQS25gkWIFhh2JFghfFDhDkRdiBJghXSKAlWyIckmFUYLNtClvx2XTlf8jqXgUUIlh9+ZBhmzWPWPGYtYNYCZi2/4CrDAgKz+UmlCMsfZibDHATL924ZhlljjBtD/c3agjVrEszRFuYLknidYD5kYA6yFgqVDDbBos3ALASLmLVSDzgOc4ohGBEGixBMF0JQoD3MZWARgjFmjQPSJp0xEMwSBnMQzGkM5iGYx6x5jFuAHOAL6xExph13y+eD0yR0dI/AwkmYLwAaFBhBoEYt6gACGVW1sD1bBhrUokEtWtRi4U4yGZhfUlkmhOs2ZxM4ZGAWg0UIll8qlWEBggXMWn6pVIQVHg7Inotg1w2FTXAykAgFWhSIckTDU9CoRUYtMmrRoH40UEsN+eAkwxwEwwJTwAJT8Ji1fLotw8AxMATU5QG1GDUKBEek0gapFwBRi2hci4Ra1AoFQg0uamjcjcwYDIov0WgMhlnLZ0kyDBzKokNd7mCL4MASPaNAMMpENK5FNK7FiFqM2Nx+ebyFNLgF5iAYKQxmMFiEYBqzpgMEAxPIBYi63KAWjQOBVqFACwIdatGhFj1q0RsUiDU4KJFkBSWSXNhlJsOg+EJYNCNlMRg2lDGBC2MLELWoGQWCUYbQuEZoXCM0rpFBLVpCgViDg7JPLuwelGFQfCFoWWyBYdaCxmDgUEYRdTmYebJWCgUaFAhGGY3GNY3GNa1Ri+CCP2uGGpyGsk/WhjAYFF+0VRgMtAZNz7UDh7LC7skXAD1q0Z/s9MwhF0altwaMPjjKhv2jkdMjIGLkNZiAq3rMaIgsbNQ8jdbyQOepsI+8IVXY1lnVBP3rLEpHfjtKb324g23Ee1iEYIUOdwhjk4EFCBZOt/Z7+frfD/fXHz7efPm+gHZ//Xn76cf13e3T1x//+7b+5eP99c3N9df33+7vPn35/PP+y/ubu0+7v12pp3/+dj6+80ot1XlYIdm9KMQm7r7udPeKlr/yYnWx/H8=",
      "brillig_names": [
        "get_htlc_public"
      ]
    },
    {
      "name": "commit_public_user",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 8
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 48
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_receiver",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3559210201980528457": {
            "error_kind": "string",
            "string": "Function commit_public_user can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7Z3djiS3rYDfZa99oX9ReZXgILAdJ1hgYQe2c4CDIO9+NLNTqtotqbnDprprRd4Ybbs4FD9REkX9/efD33/56d///NvHX//x2x8f/vLX/3z49NvPP/758bdf67/9578/fPjp94+fPn3859+O//mDeflHCelV4I9//fjry7//8eePv//54S/WuxB/+PDLr39/+e3B1D/yj4+ffvnwlwL//eH8uXFu+9oEt38cOx+HYvLbx6HY1D5OvvMxhABvH0NI4fjx//zwoUTLUvpStq+tLQ8sPQ/7CI09IOxtzFvpbfL+dulL9OHt41Llvi59Csylt+6L0r/oyO4BOnJXhy3Fb1LOWHtbRzRg3r6uPwFxi2i34kP05muw0De6FiLvBfL5doE4/RS+hZAvxwK9iBVHEbPGGKJc7Mn5CJsX+2T2aoy2AyKF1hWkaA1CDcKGGCDFr6hZYw1ennIsz2epTJFyjiRF0uUjRSrgNJw5S0WKVPQkKehJBVO2lh2szbf9x5rk96Fk719rv9vtjdPbx87s3ZJ/GYJO3+bSurxcW1b72r10+R1TXSvz3vZftZy+dbbYrRjuUHH9r6PbGsix53r59pVhcsrwboZZGd7LMKsf3s9Q/fBuhqB+eD/DpAzvZVjUD+9nqP3hvQzr5EEZ3s1Q5yl3M7RBGeIMy5bfSDaeGfbzAMrwXQyLMryXYdC2fD9D9cO7GUb1w/sZqh/ezTBpjH0/Q/XDuxlm7Q/vZghGGd7NUOcpdzMsVhnezVDz2PcydEb7w68ZfuaiY22fi8ZxXS5W5wh9LrrG0+XidP2wz0XH9C4Xr+N0n4vORbpcgs4v+lzUX7pcovYvfS5CxyMH23J/HXrcmUsS2r+gXNRfulyy0P4F5RKUS5eL0D1ZGBep+59RLtrvdrkU7Xf7XITOAxAuXup6AMpFx+k+F6HrARgXqesBKBeh6wEYF6fz6T4XHaf7XLTf7XLx2u/2ueh8usslqL/0uQgdp7Ntxcidc271bymXLheh+ReMSxI6n0a5BOXS5SJ0nMa4SL1/BuWi43SXi9R1EpSLjtNdLhzrJBbatZguRIRLjO1PJ3D7FZHWdP92ie2CzpJ3MjbBW/nhuy5/MOn7Lj/H/RdPLT+eTwr+dvmdd6HNKZP9Qkfn65g3a10yBvk6JLvNV0MKAfk6g9+KnSHuJeneOpr3K0pzNF9fHmuD80pmQAaUTJ+MV58ZkVGfGZAJ6jMjMuozAzJRfWZEJiuZPplvuFFaKpmkZPpkvmGXslAy33CfiFQyUcn0yRT1mREZ7WdGZDQ/0ycTrVyfiS41Mi6fyHi5PXCy27HO+rNDZq3W5HYyCXmZylvYfMa7g894nz+jWSwNwYpmrTwEJ5q41qSSFc1as0pONN9wiFwsmrXyV+9B45JraA5PUTY0Wa7XoGjk9jUYGlCvGaJRrxmhKeo1QzTqNQM0yajXDNGslZPgRGPXSguzogmKZoDGyZ15o2jk5mswNIttUGNFI9hrmo3e2/AFmvd9/QoyCO6ZeEEKzgWxglxs69M0kNa0czj15/6nfXwDCYKHj/eBTLaBzKYD8upNO29HvUI2cMfXr9ZePpvCa+3VEySc1mZz9dnre6ytUeAWJNoU92uhvU1v1l49jcFr7dW3S7Baa68+uPFaK6puXRBlrai6vXxOg9falSJH1NqwUuSIW7tS5IhaG9eKHGF7b7GOrdCxdq3IEbE2iarbb7jUaiVrr54oZ7U2Xz13yGvtWtEFYi2IqtvLb/ditfbyh+3eZW2OpVkLoWPtUtEFau1S81vEWjBLzW9Ra5eKLjBr18o5otYuFV1g1rqlcheotZJGIFgrw4pZu1aGFbVWVC+1VoYVtVZULxVE9VKXvxSN11pRvdTlTwy/z9qylaRGEqZj7VKZGszavFamBrM2iLJ2rREIsRZE1S2slalBrC1LrRWg1koagcpae1hRayX1UmWxfDJirZXUSxUrqpdyonqptXbsotaK6qX8Ur3UfkFl/Xne51jCUu0WtXapdnu09nggslm71PwWszaKqtv48LpN3jZro0e+jvstwDFG7G+/8xpd165eTgluf2xtKPu7gLVQx89fQaZ4cZCwFSQmh50adtVvtr9dTTu7zePTmU+1dqm6reZuf9vFeLYWlqpbZ3OzNp2Gcmcev13nmdY+/kKlmdZ60/62t7Zj7VJ1i1nrRdWtX6tuXWwliZ12G9aq20NJsu9Yu1TdBrMdEXTBdqyNS9Utaq2ouk1r1a1r0UWI0LF2rbptU08X8nkEsiaIsvbqiYL3WVvaHCiasydbu1bdYtaKqlu3VN1G10agY4Jst3apuo2u/e2Y4tlav1bdtpxjTQyHjrVr1S1ibRBVt2Gpuk17zjGFTp8cl6rbtGfhUur0yZdfdHmftbBbW/LZ2rRW3WLWiqrbvFTdYn1yBkl1+/h7kJ9qrai6LUvVLZKFqwu4gua3ddlLlLWi6vbxW58TtJWpbLHNSck3NsmHfX7e3VMDGbaPAYw7fvzZ1vxUW8sXX7+WyLnLlehyjB6/Cp1DaSXKWHu0JW0FccYcxwr3Wn7/+Mxv2fuTEs9E/eOzs1iJ3OUYPd7r0BI9vGWW1NpBOcR8/a8hhK0gEL7YcRC6rcZsq0O2BPvF16/WPn5/wlOtXetIzs1rCZyPgi5PqdaKqtvFrpzArBVVt5d/Sp7XWlF1e/kH33mtFVW3Sz0khlsrqW7D5R9P57VWVN1aUXW72LUEiLWSrrl92QoqyVovqm69qLqVdPFrtTZJslZUXiqIyksFUXmpICovFUTlpYKovFQQlZcKovJSQVReKojKS0VReakoKi8VReWloqi8VBSVl4qi8lJRVF4qispLRVF5qSgqLxUfnpfyJm17cr3JEfk6xbBZmxK6o7vAVpBSDrvXS+yVI7Y9kfWn65CJSqZP5uFPyV+GDPhtr6WHzo11MYn1meK2v+yLt2cyWazPoGTUZ0ZkipLpk3n4adfvh0xWMn0yD38u6fshoz7TJ5OM2NkBSkbsqA3tTGUlc77VqmrT2UElkzpk5EZ6UBqZzg0PycmdHWBk1GdGZOTODhAyXu7sACMjN9JDyAS5swOMjPrMgIzctQOUjNxRO263WwVjOvMmXTt4JeM6ZKT6TDC2NDLJnMmIXTuoOEIjkzs+I3btACUD6jMjMkHJDMiAkumTEbt2gJOROjvAyGSjPjMik5RMn4zYtYMaA8NOJnXIyF1vOsyb8nmuncWuHQTb3oQO1vfIiJ0dYGS8+syITFAyAzJiZwcYGbFrBzgZsbMDjExUnxmRETs7wMiIXTuoJvrdxM68Se65g8Ps4GhiIyN37cC2twOCM6ZDRuzswJmWhXC205rkrh2gZNRnRmSk7kZDyRSpu9FwMmJnBwgZkLt2gJJRnxmQsVJ3o+Fk5OaB2+0Hlcx5Rglyzx0c5k3OQoeM3BllK3WF5DtkxJ47wMiIXTvAyajPDMgE9ZkRGfWZAZko9nwTSkbsWRWMTBJ7vgklI3VdGyWTtZ8ZkdGxaUBG7O56lEyRO9fGyOhcu0+myL1/BiUjdZcISsZqpDcio7ODARmnkd6IjM4OBmQ02zkko7ODAZmgkd6ATNTZwYiMRnoDMklnByMyGukNyGSdHYzIaKQ3ICP3tm2UjEZ6AzIlKJkeGW+MRnojMjo7GJARu7cTJ6OzgwEZp5HeiIzODgZk5N6cjJLR2cGAjO5gHJLR2cGAjNz7gTEygu8HxshopDcgk3V2MCKjkd6ADOjsYERGI70BGbEn2XEyGun1yVgj9vaDimAz0X9F5vy19clvD0fU37CXuy5mvpEUe/8eN0mxOyT5SYq9q42bpBN7ewM7SfVJJpJybwlmJxmUJBNJsfeMcZMMGplzkRR7JxU3Sbm3IrOTVJ9kIil2lzU/SbH3sHGTlHurMzvJoCSZSGp+komk2P32/CTVJ5lIyn0Bk52k5id5SDqxt6Pwk9TInIuk5ieZSNqgJJlIqk8ykRR7Tw4/Sc1PMpH0GplzkdTInIlk0PwkF0mNzJlIir1hiZ9kUJJMJDU/yUQyaWTORVIjcyaSYs/l8ZPUyJyJJKhPcpHUyJyLpOYnmUiKvXWNn6RG5jwkvdy3jNlJamTORFJPgLKR1MiciaTYt5g5Sfa+t7l97vdye5/fuGscP4N7KtvX2cQzdT1b+o3U6/SoUc/FnvsNsTcTspMMGhUwkdS1NjaSQUnykBT7AjI/SY35mUjq6TM2khoFMZEEbd1MJMW++MxPUls3D8mg2XguklZbNxfJoCSZSGo/yURST/qwkVSfZCIp9nUefpLqk0wkNWfORlLn3Uwko+5x5SKpa+NMJMW+68RPMihJJpK675qJZNbInIukRuZMJMW+8MVPUvddM5EsGplzkdTZIg/JaDQy5yKps0UukhqZM5HUtUU2khqZM5HUtUU2khqZM5HUWwTZSMqNzFNuJA/nw6gnImOQO1vkJik3MucmKTcyZyYp+GQTN0n1SSaSgm8R5CYpNzJnJpnlRubcJNUnmUgKvkWQm6RG5kwkBZ+24yapPslFUiNzHpLJaGTORVLuOg4zScG3CHKT1Jw5E0mnkTkXSfVJJpKC7/rjJhmUJBNJjcyZSAaNzLlIan6SiWTUyJyLpPokE8mkkTkXSc1PMpHMGplzkQxKkomk5ieZSIJG5lwk1SeZSBaNzLlIan6Sh2Q2GplzkdTInIuk5ieZSAo+AcpNUn2SiaTgE6DcJDU/yURS8AlQbpIamTORDJqf5CKpkTkTScFv23GTDEqSiaTmJ+8n2fv+9tvBWc+LfiN37NaMnDUHx0VSR3omkrp+xkZSZ+lMJPVsHhtJzWbykASjrZuJpNUoiIuktm4mkrpWwUXSa+vmIqlREBNJPb3DRlKjICaSgt9v4yapK5FMJPX0DhtJ9UkmkpozZyOp8SQXSZ13M5GEoCSZSOrqOBPJorNFLpI6W+QhWYzuW+UiqZE5E0ldx2EjqZE5E0mn+1a5SAYlyURSZ4tMJL1G5lwkdbbIRDJoZM5FUmeLTCR1bZGNpM4WmUgmjcy5SOpskYkkiB27q42bieHwl19IVjLByH2JJGTXyEDpkJERpbzaKiTD99lWGSP9q61LZcms8VtJrIkJad+5hK0kuRS3jwngeuWOrTOw+192pvets8VuRJwpyNfRbR1wPJy5ffn2cw0FraGL19BKWb0la2ipd0TWrCFtQxevoaBt6Oo1tFImf8kaWuoGoDVrSMehi9fQUjnPJWtoqVdW1qyhlTJc32kNlW0BI9l4rqGl9kuvWEN2qVcU1qwh7eUuXkNLrSqtWUPahi5eQ07b0NVrSGesF6+hpW6qWrOGdBy6eA0ttft9zRrSnMLFayiutNdyzRrSNdaL11DSceixNfSZusZnT6C+1I1o3w91nc8/g7ruzHgC9aVuZft+qGuU+QTqRSPHZ1DXrMTjqbulTnV+P9TV159A3Wq//gzqGsNMoO78Tj24M3Wnvv4M6tqvP4G6rjg+g/pSb0Bfhnq2aSOSOzv2XdLR9AnUs/Ywz6Cua0lPoA56ausZ1INSfwJ1HU2fQH2p11S+H+rq64+n7pd6peX7oX7xyDE526iHjHwN3m6HuMG7PcOafK8gLmw3nHqXvqyiVzT24uHdM9FcfD/PE9Fc/XrIZ6JRrxmh8eo1QzTqNSM0Qb1miCYomhGai28LfSKaq58meiKaqz9v/0w0F1/LfiKaqy8HPRONes0IDWhfM0Sj+ZoBmnD168VmooEdzeHdlYbm6nvcJqLxZiu299Z30MhtUD6ahiZ2vMYL9hoMjdw5FIZG8MwbQxPl5mtQNHKzfBiaq28ffSYauXMoDA0shaauhDc0JtxGU5fQtz/9xWp6/fiFTDT9riaUtqweDyq6ZELaVtWrC+6fujcFZbICG+5WENuOg5jiWcH9FiS7OVo67FLYFDg/WwFMVuBnW+BnWxBmWzC4PY1PweCpbkYFabKCwcPOjAribAWzu4ocZiuY3dBgdkOD2XVQJtdBMma2gsntIFk7W8HkvigNkoSMCiaPB2n2mJz8bAvCbC8Ks70o3t+Sc9x22uZkzgribAVlsoIUZiuYbUGebUGebQHMtgBmW1D8bAUwV0E2brICa2YrCLMVTPai7GZb4GZ7kfezFdw/6GfYLuCFwxrkpoBh0EcUpMkK0mwL4P6uouYQNwURzgruR1TMlr4t9uxF5f6+qNgtHVtSOSuIsxWUuQrA+NkKYLICO9sCmycrcJahHcTWDuxZQZ6swIfZCspkBSFOVsAwR0MUwGQFyc1WkCYryLPrIM/2IoY5mjWwLdXVn6dRGRgyp6gKmK6izLeiTLeiGD9fxXwr7HwrGMZoTAVDqhZVkaarYBipURXzPSrM96gw34o436Pi/HbBMA+11m6DnrXBnlXE6SoYQgNMBcy2IhrD0IHYmJoKSCcVDPk96/yWd6g/4ayCoY9ywTUVJZ9VlOkqGLbboCrydBXezVcx3wqGbB+qInK0C7+3i3JSEe18FTBdRfLzVZTpKnKYrgLcfBVpuopi5quYXxdlukdZjrlesG1gDS6cVeTpKqybr2K+FW6+FW6+FX6+FX6+FRxjN6YiTVfBkP5FVcB0FWm+R6X5HpXnW5HnexTMbxccM9bQTpHUn+dRj2HLDqaCIzzAVEy3wpkwX8V8K+x8K+x8Kzim9pgKmK6CJTy4rSKY+Srme1SY71FxvhVxvkel+e2C4eCIjfuoV7vur1WMLlp9l4rkt/3a9ac7qWDYP2dTaFakc57Wc0Tm2W+7q2wO5qSCIzLPod3ZDMafVaTpKjgic0xFmK+iTFeR5luRYLoKjuA/+7i3C3tWAdNVcETmiAqOxB2mIs1WMbqgilVFma6CYwcF7KMeWDirYBgvwLWxG+BsBUdWDVORpqvwZr6KOF1FmG8FR2SOqQCOduH3dnGKBgPH2I2o4NhBgalI01VwDKyYijxdBcfAiqlgGC+g7O2inDvzEmeriMbNV5Gnq2AZWBEVMF0Fy6h3WwXLqIeoGPS0aTtDVLXZ2yoAtr1Lx83T/cuccttoXecE+zzBe3grDlyqOKMtj88qzrXoxGvRideiM1q2e1ZxrkUnX8t3Rkc8nlQcuFavPMpKPKs48UrFSaNsx7OKky5VHHupbjCNMi5PKo67VDeY3KUGiXSt4DT5Sw0SKVyrG4yXGiRSvFY3mK5FJ13Ld+CxdMBs39af+VSc/OARvZh2w3GxveKwVpYzx+K8KrBmtoLZFrjZFrjpFpTJCngH056C2RaE2Rbw5lc6CngzJj0FebIC3qxGT8FsC/JsC/JsL4LZ7aDM7k05ZvDZNAX+9gBbcrsRq+RYvi4NGHOp0oRLlaZcqTT2UmzcY8NEaNtVPAR3ChPBpUsVx1+Ljn/sjAegxfTHPRR7ccqVphjw4FwCVpzorlWcfKniJH+t4sClipOvRSdfy3fgUqkNluu8bm/7Lxx7ZlJue/ITxJMKjutZEuzb/m04q4jTVbj5VjBcwoyp4DhghagI80FxXGxy+6xK4bjYBFMB01UkP19Fma6C42ITTMV8K2B+XUCerCIZw1AXNw+7VRUc5+lyuyCuuuhJBcceS0zFfCs4Di9E344mxQRnFTBdBcfJAkQFx5CEqUjTVXAMSZiK+Vak+XXBcSoQUQGzb5isKjjuZtzjKGfdSQXHeTpMxQOsYBi7b94wmayJ01Vw3FKFqcjTVXBcQ4GpgOkq/Hwr/Py64DgLj6hgmMLcevAlcdzuBGkLogDCWUGerCDPtoDhXqdbb+IkO/nRncRx4dJtBQzXLd1U4BjeLUUUxMkK7GwL7Ow6YJhw3VYwmKjUKGpTYIO/rcB5t4WVzqc95us/d+9Naqt2Jkfk61QRvH2d6iQe+bqaunEBf+DSTVSDbY8FgXVffPxKZjC/kkCmRp83yQj2GZf2gT2eyES5PoORUZ8ZkSly+xmIO5l0+2Nra+Kuhe0p+BPIJNfFxiBfyQyC3e+UjLdtdPKu3CbjHWzRT/25f2xLfEOTxKLxth2J8N6c0RSraEZo1GsGaLxZKgR6HxoTGppD2mdHI9hrEDSDtUtFU9GAohmgGewtUjQVzVKzClY0Xr1miEb7mhGaIHcOhaG5egYjBt/QWIN8bc2+ScLE9IW1nYW+EraS5FL2Zfw65e6VO7a0vd3/sjOuS8T4RuSw6frl61fq6eLd2KLU1defQD1ffHrwfVJ3bQtSrQDXoX7xaGBN6ldP1i5K/eK5mTWpl4snCxelHpT6E6jraPp46sHoaPoM6lmpP566VV9/BnWNHJ9A3a+UESiwFaSUgDAP1cbNxHD4y3Vd/o3MSn3v+8j45mCVwpnM1fetTiQTbCNz2ATeyFx93+oTyajPjMislAlnJZPk9sAImaytaUAG5PbALu6jdo/MSvE1K5kiNwbGyKyUa+MkE01QMgMycuMZhIxVnxmRkdvP5D0LAR0yTu6ojZDxFz9W80QycntghEyQ2wMfbjroZDtjkOszCJmoPjMiI3fURsgkuaM2QiZraxqRETxq7+tNh7PljQzIzXYiZMpKOxV4ychdO7hNJhm52U6MjOAsxG0yVz9W/kQy2s8MyPhHr8S5mLc7alwymK0htaObIYWAfJ3BbcXOkJArlrxrNnp/eKHCv2ymOX1tTdv8VX/uf9rH/AYyKMhvA5l9A3n0yNj7Gg4ndwPybWx3SEXwnQoCraBLV9DDz5xrBX09DrUyp8PVfa2Coo4VF68g7eKuXUHJawU9uYLsXkGdKC5pC7p2BWVtQRevoKwV9OQKag9+pOzOFfTwPL1W0PsqqGiYffEK0iDh0hWUjQYJF68gDRKuXUHWagV9WwW1h71qXZkOSPV0HpAPv/14WZBFQbKA9DqR4gEZdMLDBFI9kgmk9pE8IKPOxHhA5rX6SL+DjPY2yBzbi3L1Zz5+/JlMEEsmxe3h5VwT72cya/Vi7yIT3C0yINhnXNnJwO2PrQ2l5R9sbYcnkIvlqt8F0toG0p5d7OGPpn0vZGCx7CwnmbUWFhjJWMEdNkJG8CB/m8xiGUNOMtrPDMj4tfYg85Ep/Wv+rHHtmWqT9h2P2821JVuaWDeTZW0zqIamcBYDTxLrv/2LiyWCWDb9N2OtTfuD3xDPYq5fSF+2OWD92dHmIk2skMT6FxXjYpkkFmi2RVoh+7ur67SoVXc8PEXXxPovl6Fig4aDiiWSWP8ZHlwsk8QKTdugvcVUmthhjXwTsybQxApJzGaSmHM0MRqS/qk/XIxGMgzaW7va23oHHTEgiUVHE0sksWRoYoEmRkOSaRWQadqAVgFAq4BCq4AyqIDQHgR43TfzlZgbjN2oWCaJWUcTA5KY8yQxb2lipLHbeVJc4oKnidG09Vu3q+13C/WzNx2xfr2l1IbFmrk+iw2GfEysnwPHxQpJrH97r837/rZcXEcMKGK+/w4SLpZIYtbQxAJNjIbEeZoYTZunVYCnVUCgVUCgVUCgIYk0JJGGJPW1lX1YLK4j1l9mRsUGzbT4tqhdDgG9j+FVLAzaGybW35yKixWSWD+N+IXY8Yr7TWzQAjCxgSujYkAS68+EnbEtJ2W+OOO1iWWSWN8ncTGatkzTlmnagKYNaNr6CStcLFHEYj/oxcWAJNYfFnGxQhJzNG2OZpsntbcYBtpiSzSbQ6K5iaUBknYlUP157hQGlz+i2vKgkBCbWIlnMfA0MZq2UQu4LZaMpYkVkpjNJDE36ILA7mKpI5ZJYp6mzSeKTw7uhsHFSC0gxUASS4YmFklimaYt02wDUgXkQb6kFLcHlOVwU4Yr6U0QiIKDnAku6KhFHQWIuCDVxsEqyzcIUjUGqsZA1Rip9difMIVctuRLgMPjFk0sWZpYpIkVkthgrysqRtPWH5pxsUysuRKpgoUmCIZYVBhNQXFBoo1A7Z7AUTV6qkZP1kitx0DyVOh3TqhYv2vCxUgdE9A6Jkg0bYNzBqgYcQwEcFTBRBQsVLemdk+FGgQVQ9VoqRptoAqSmlJxniaWSWLe0sRITakEmrYQaWLEvrNE4hhYkqUKUt06U906UzUCVSOQNVLrsdCaUqE0XDDG0cQSScxamhhNmzM0MVrfCcY7qmAiCgZDFYxEwUjVGKkaE1VjotZjojWl7GlimSQGtKYEtKZUaNpKpInR+k6wxHlgnQZaqiDRrS1xHlgFqRo9VaMna6TWI2keCJY0DwRLmgeCJc0DwZLmgVWMpo00D6xixL7TEueBYInzQLCF6tbEeSA44jywClI1WqpG4jwQHGkeCI40D6xipDHQkeaBVYzUlFygaSPNA8ER54E1TUit8kjVmN5d6Z0j6sG0fabBHS7O8PlNCTxASX6EJRmInKldpCvmfrNyO99WEylno94f6b1XhTfTrfCx28QB2j7h+nNXYeFNKlKk+vMaVKrrA1Da3SpQE09Hqc5RRWhvWjkAe1LRP7HEq2K+Ff2MD6+KOF1FmW9FmW5FMGa+ivlW9EMiVhX98IlXRZmuws+vizToo7JpKg7X4W5S/fXzYtqJ6fLFG39vUv0DFpguGHgLtO69HEagTaqf/K0lbE8FmkNI0aSAIBUNRVfsZ0pQqUSRciRdrlCk+mciq5TbpexZqlCkAklXAFTKn+2Kg1r2sUkFf5YCtKUcry14k0oDXQH29nUuYR7Ucsg3WmXMidCWI1iSVCRIJTM6VL2fsg3uFIMm62hiiSTmLE2Mps3TtHmatsHqCCKWB6fajSv71Y6unHr8wU1hqBwYS5Qb3OTh290i9fe5pxvtecLlEk1usFnR+LDfie/PvQkM8hEmtF329bc7tTsYrPug+tKonDntcnDWNziVjcsR9UGiyRVLlCskuTL0T0Ru0AFWOXOQS2e5TJNzRH0ufYNcOdvnLVEuDuT2axvqgvCp/ZVBN1gjAEQuEuVo7Xa0gQWVG+xfQeRe4qaeXN5vHD08D/12QrIMLsYp7VHp4/G8XSgThPrpZkwoUoQKQShSQAzCyttCaTQe37p6qoolkhjpoqsyuq8HEwOaNqBpKzRthaTNGkcTo2kbLJGhYoEmVt7fd1g3mB61eY7rCRGajB206NuaIqV4/U4bEUqWIkTo2gbL35gQSVMfebsMruSOG/VTS5gQRVPBuuuuEMH3nAkEIWspQokg1I/2MCHCAO48RZOn2BQMRYhST4HiEaOrZmy7fScdGvzbPLwuamaKmB9Mp49iPnTEEknMvl/bf+u//u+Pv3/88adPv/xRhV7+779//fnPj7/9+vavf/7fv7b/89PvHz99+vjPv/3r999+/uXv//79l799+u3nl//3wbz94682pfyDTQC1QC+lqV1R/MGC9fXfX1q9rXFwHUZe/u/r57XMP9R/pJf/8Pl7CD/Uf6Raslq6/wc=",
      "brillig_names": [
        "commit_public_user"
      ]
    },
    {
      "name": "redeem_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "ownership_key",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "add_lock_public_user",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2722406262643068352": {
            "error_kind": "string",
            "string": "HashlockAlreadySet"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16870384257694633552": {
            "error_kind": "string",
            "string": "Function add_lock_public_user can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "add_lock_public_user"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "HTLC_Private"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Train"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "contracts_private",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "contracts_public",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_hash",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::lock_private_solver_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::lock_private_solver_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Train::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "ownership_key",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::redeem_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::redeem_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::refund_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::refund_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::add_lock_private_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::add_lock_private_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "ownership_key",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::redeem_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::redeem_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  },
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::commit_public_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::commit_public_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::refund_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::refund_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "ownership_hash",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::lock_public_solver_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::lock_public_solver_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 8
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 48
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::commit_private_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::commit_private_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::add_lock_public_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::add_lock_public_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "key",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::get_htlc_public_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "hashlock_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "hashlock_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_hash_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_hash_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "claimed",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::HTLC_Public"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::get_htlc_public_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "101": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "103": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "104": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash =\n            compute_unique_note_hash(nonce, compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash));\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.nonce, note_and_data.nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == first_note_and_data.nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.nonce == second_note_and_data.nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "105": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    pending_partial_notes.for_each(|i, pending_partial_note: DeliveredPendingPartialNote| {\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log sans the extra\n            // fields) to get the complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                // temporary node connectivity issue - is simply throwing good enough here?\n                assert(\n                    deliver_note(\n                        contract_address,\n                        pending_partial_note.storage_slot,\n                        discovered_note.nonce,\n                        complete_packed_note,\n                        discovered_note.note_hash,\n                        discovered_note.inner_nullifier,\n                        log.tx_hash,\n                        pending_partial_note.recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "107": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{\n            ComputeNoteHashAndNullifier,\n            partial_notes::process_partial_note_private_msg,\n            pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n            private_notes::process_private_note_msg,\n        },\n        encoding::decode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        msg_type::{\n            PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n        },\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_notes},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncNotes` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_notes(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get the logs from the capsule array and process them one by one\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    logs.for_each(|i, log: PendingTaggedLog| {\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n        logs.remove(i);\n    });\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(log_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            pending_tagged_log.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        // In the case of events, the msg metadata is the event selector.\n        let event_selector = EventSelector::from_field(msg_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            msg_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n            pending_tagged_log.tx_index_in_block,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "108": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n        // issue, and we should perhaps not have marked the tag index as taken.\n        assert(\n            oracle::message_discovery::deliver_note(\n                contract_address,\n                storage_slot,\n                discovered_note.nonce,\n                packed_note,\n                discovered_note.note_hash,\n                discovered_note.inner_nullifier,\n                tx_hash,\n                recipient,\n            ),\n            \"Failed to deliver note\",\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "109": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\nglobal MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "110": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "117": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/logs/note.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    messages::{\n        encoding::encode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        logs::utils::prefix_with_tag,\n        msg_type::{PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID},\n    },\n    note::{note_emission::NoteEmission, note_interface::NoteType},\n};\nuse protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n    traits::Packable,\n};\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists<let N: u32>(context: PrivateContext, note_hash_counter: u32) {\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\npub fn compute_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PRIVATE_NOTE_MSG_TYPE_ID,\n    )\n}\n\npub fn compute_partial_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID,\n    )\n}\n\nfn compute_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    msg_type: u64,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let packed_note = note.pack();\n\n    // A note message's content is the storage slot followed by the packed note representation\n    let mut msg_content: [Field; N + 1] = std::mem::zeroed();\n    msg_content[0] = storage_slot;\n    for i in 0..packed_note.len() {\n        msg_content[1 + i] = packed_note[i];\n    }\n\n    // Notes use the note type id for metadata\n    let plaintext = encode_message(msg_type, Note::get_id() as u64, msg_content);\n\n    let ciphertext = AES128::encrypt_log(plaintext, recipient);\n\n    let log = prefix_with_tag(ciphertext, sender, recipient);\n\n    log\n}\n\npub unconstrained fn compute_note_log_unconstrained<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_note_log(note, storage_slot, recipient, sender)\n}\n\n/// Sends an encrypted message to `recipient` with the content of the note, which they will discover when processing\n/// private logs.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n        assert_note_exists(*context, note_hash_counter);\n\n        let encrypted_log = compute_note_log(note, storage_slot, recipient, sender);\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note`, except encryption is unconstrained. This means that the sender is free to make\n/// the log contents be whatever they wish, potentially resulting in scenarios in which the recipient is unable to\n/// decrypt and process the payload, **leading to the note being lost**.\n///\n/// Only use this function in scenarios where the recipient not receiving the note is an acceptable outcome.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log =\n            unsafe { compute_note_log_unconstrained(note, storage_slot, recipient, sender) };\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n"
    },
    "118": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/messages/logs/utils.nr",
      "source": "use crate::{\n    oracle::notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n    prelude::AztecAddress,\n};\n\npub(crate) fn prefix_with_tag<let L: u32>(\n    log_without_tag: [Field; L],\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> [Field; L + 1] {\n    // Safety: we assume that the sender wants for the recipient to find the tagged note, and therefore that they will\n    // cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the\n    // note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut log_with_tag = [0; L + 1];\n\n    log_with_tag[0] = tag;\n    for i in 0..log_without_tag.len() {\n        log_with_tag[i + 1] = log_without_tag[i];\n    }\n\n    log_with_tag\n}\n\nmod test {\n    use super::prefix_with_tag;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn prefixing_with_tag() {\n        let sender = AztecAddress::from_field(1);\n        let recipient = AztecAddress::from_field(2);\n\n        let app_tagging_secret = 42;\n        let index = 5;\n\n        // I am using the deserialize trait instead of directly instantiating the IndexedTaggingSecret struct because\n        // direct instantiation functionality is not exposed.\n        let indexed_tagging_secret = IndexedTaggingSecret::deserialize([app_tagging_secret, index]);\n\n        // Mock the tagging oracles\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(indexed_tagging_secret);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let log_without_tag = [1, 2, 3];\n        let log_with_tag = prefix_with_tag(log_without_tag, sender, recipient);\n\n        let expected_result = [indexed_tagging_secret.compute_tag(recipient), 1, 2, 3];\n\n        // Check tag was prefixed correctly\n        assert_eq(log_with_tag, expected_result, \"Tag was not prefixed correctly\");\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "123": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "125": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n    pub storage_slot: Field,\n    pub note_hash_counter: u32, // a note_hash_counter of 0 means settled\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note, storage_slot: Field, note_hash_counter: u32) -> Self {\n        Self { note, storage_slot, note_hash_counter }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "128": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n    retrieved_note::RetrievedNote,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::{array, comparison::compare};\nuse dep::protocol_types::{\n    constants::{GET_NOTES_ORACLE_RETURN_LENGTH, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL},\n    traits::{Packable, ToField},\n};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_fields,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. nonce, note hash, etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_fields,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "131": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "134": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "137": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "138": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "139": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "140": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "141": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "142": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "146": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "147": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "148": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "149": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::messages::encoding::MAX_MESSAGE_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        msg_content,\n        tx_hash,\n        log_index_in_tx,\n        tx_index_in_block,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n    tx_index_in_block: Field,\n) {}\n"
    },
    "150": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_notes(pending_tagged_log_array_base_slot: Field) {\n    sync_notes_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "152": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::IndexedTaggingSecret,\n    traits::{FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {\n    // This wrapper exists to extract the ORACLE_RETURN_FIELD_LENGTH generic numeric param into a value and pass it to\n    // the oracle, so that it knows how big the return array must be.\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        ORACLE_RETURN_FIELD_LENGTH,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let MAX_NOTES: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    _placeholder_fields: [Field; ORACLE_RETURN_FIELD_LENGTH], // TODO: Compute this value automatically from MAX_NOTES\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields: [_; ORACLE_RETURN_FIELD_LENGTH] = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n\n    let mut opt_notes = [Option::none(); MAX_NOTES];\n    for i in 0..opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "153": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "154": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "155": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "157": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "159": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr",
      "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\nuse crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    lifecycle::create_note,\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_notes},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context, let N: u32> Storage<N> for PrivateImmutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor.\n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: NoteType + NoteHash + Packable<N>,\n    {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> Note\n    where\n        Note: NoteType + NoteHash + Packable<N>,\n    {\n        let storage_slot = self.storage_slot;\n        let retrieved_note = get_note(self.context, storage_slot).0;\n\n        // Because the notes obtained from PrivateImmutable are not meant to be nullified and get_note(...) function\n        // has already constrained the note (by pushing a read request to the context), we can return just the note\n        // and skip the additional data in RetrievedNote.\n        retrieved_note.note\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:is_initialized\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note\n    where\n        Note: Packable<N>,\n    {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: x_coordinates_match,\n        };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "168": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable.nr",
      "source": "use dep::protocol_types::{\n    shared_mutable::{\n        ScheduledDelayChange,\n        ScheduledValueChange,\n        shared_mutable_values::{unpack_delay_change, unpack_value_change},\n        SharedMutableValues,\n    },\n    traits::Packable,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\n\nmod test;\n\npub struct SharedMutable<T, let INITIAL_DELAY: u32, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Packable and Eq traits, and allocate `M` storage\n// slots to this state variable.\nimpl<T, let INITIAL_DELAY: u32, Context, let M: u32> Storage<M> for SharedMutable<T, INITIAL_DELAY, Context>\nwhere\n    WithHash<SharedMutableValues<T, INITIAL_DELAY>, _>: Packable<M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let INITIAL_DELAY: u32, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PublicContext>\nwhere\n    T: Eq,\n{\n\n    pub fn schedule_value_change<let N: u32>(self, new_value: T)\n    where\n        T: Packable<N>,\n    {\n        let _value_change = self.schedule_and_return_value_change(new_value);\n    }\n\n    pub fn schedule_and_return_value_change<let N: u32>(\n        self,\n        new_value: T,\n    ) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n\n        value_change\n    }\n\n    pub fn schedule_delay_change<let N: u32>(self, new_delay: u32)\n    where\n        T: Packable<N>,\n    {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay<let N: u32>(self) -> u32\n    where\n        T: Packable<N>,\n    {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value<let N: u32>(self) -> (T, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay<let N: u32>(self) -> (u32, u32)\n    where\n        T: Packable<N>,\n    {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change<let N: u32>(self) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        // We don't read ScheduledValueChange directly by having it implement Packable because ScheduledValueChange\n        // and ScheduledDelayChange are packed together (sdc and svc.block_of_change are stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_value_change::<T, N>(packed)\n    }\n\n    fn read_delay_change<let N: u32>(self) -> ScheduledDelayChange<INITIAL_DELAY>\n    where\n        T: Packable<N>,\n    {\n        // Since all ScheduledDelayChange member are packed into a single field, we can read a single storage slot\n        // here and skip the ones that correspond to ScheduledValueChange members. We are abusing the fact that\n        // the field containing the ScheduledDelayChange data is the first one in the storage layout - otherwise we'd\n        // need to offset the storage slot to get the position where it'd land.\n        // We don't read ScheduledDelayChange directly by having it implement Packable because\n        // ScheduledValueChange and ScheduledDelayChange are packed together (sdc and svc.block_of_change are\n        // stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_delay_change::<INITIAL_DELAY>(packed)\n    }\n\n    fn write<let N: u32>(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>,\n    )\n    where\n        T: Packable<N>,\n    {\n        // Whenever we write to public storage, we write both the value change and delay change to storage at once.\n        // We do so by wrapping them in a single struct (`SharedMutableValues`). Then we wrap the resulting struct in\n        // `WithHash`.\n        // Wrapping in `WithHash` makes for more costly writes but it also makes private proofs much simpler because\n        // they only need to produce a historical proof for the hash, which results in a single inclusion proof (as\n        // opposed to 4 in the best case scenario in which T is a single field). Private shared mutable reads are\n        // assumed to be much more frequent than public writes, so this tradeoff makes sense.\n        let values = WithHash::new(SharedMutableValues::new(value_change, delay_change));\n\n        self.context.storage_write(self.storage_slot, values);\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext>\nwhere\n    T: Eq,\n{\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n        let (value_change, delay_change, historical_block_number) =\n            self.historical_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay =\n            delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon =\n            value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n\n    fn historical_read_from_public_storage<let N: u32>(\n        self,\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32)\n    where\n        T: Packable<N>,\n    {\n        let header = self.context.get_block_header();\n        let address = self.context.this_address();\n\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        let values: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::historical_public_storage_read(header, address, self.storage_slot);\n\n        (values.svc, values.sdc, historical_block_number)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, UtilityContext>\nwhere\n    T: Eq,\n{\n    pub unconstrained fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let smv: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::utility_public_storage_read(self.context, self.storage_slot);\n\n        let block_number = self.context.block_number() as u32;\n        smv.svc.get_current_at(block_number)\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "180": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "183": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "184": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "186": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "187": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "189": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "191": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "192": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/random.nr",
      "source": "use crate::oracle::random::random;\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n"
    },
    "195": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "202": {
      "path": "/home/nerses/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "219": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "221": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "264": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "279": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "281": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "282": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "283": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "292": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "296": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "298": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "299": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "308": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "312": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_delay_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initially equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub struct ScheduledDelayChange<let INITIAL_DELAY: u32> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pub(crate) pre: Option<u32>,\n    pub(crate) post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<let INITIAL_DELAY: u32> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior constraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This\n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in\n            //                             which to scheduled value change\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY),\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Empty for ScheduledDelayChange<INITIAL_DELAY> {\n    fn empty() -> Self {\n        Self { pre: Option::none(), post: Option::none(), block_of_change: 0 }\n    }\n}\n"
    },
    "314": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_value_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\npub struct ScheduledValueChange<T> {\n    pub(crate) pre: T,\n    pub(crate) post: T,\n    // Block at which `post` value is used instead of `pre`\n    pub(crate) block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    // Returns the previous value. This is the value that is current up until the block of change. Note that this value\n    // might not be the current anymore since block of change might have already passed.\n    pub fn get_previous(self) -> (T, u32) {\n        (self.pre, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay,\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32,\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n\nimpl<T> Empty for ScheduledValueChange<T>\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        Self { pre: T::empty(), post: T::empty(), block_of_change: 0 }\n    }\n}\n"
    },
    "316": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/shared_mutable_values.nr",
      "source": "use crate::{\n    hash::poseidon2_hash,\n    shared_mutable::{\n        scheduled_delay_change::ScheduledDelayChange, scheduled_value_change::ScheduledValueChange,\n    },\n    traits::{Hash, Packable},\n    utils::arrays,\n};\nuse std::meta::derive;\n\nmod test;\n\n/// SharedMutableValues is just a wrapper around ScheduledValueChange and ScheduledDelayChange that then allows us\n/// to wrap both of these values in WithHash. WithHash allows for efficient read of values in private.\n///\n/// Note that the WithHash optimization does not work in public (due to there being no unconstrained). But we also want\n/// to be able to read the values efficiently in public and we want to be able to read each value separately. Reading\n/// the values separately is tricky because ScheduledValueChange and ScheduledDelayChange are packed together (sdc and\n/// svc.block_of_change are stored in the same slot). For that reason we expose `unpack_value_change` and\n/// `unpack_delay_change` functions that can be used to extract the values from the packed representation. This\n/// is \"hacky\" but there is no way around it.\n#[derive(Eq)]\npub struct SharedMutableValues<T, let INITIAL_DELAY: u32> {\n    pub svc: ScheduledValueChange<T>,\n    pub sdc: ScheduledDelayChange<INITIAL_DELAY>,\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutableValues<T, INITIAL_DELAY> {\n    pub fn new(svc: ScheduledValueChange<T>, sdc: ScheduledDelayChange<INITIAL_DELAY>) -> Self {\n        SharedMutableValues { svc, sdc }\n    }\n}\n\npub fn unpack_value_change<T, let N: u32>(packed: [Field; 2 * N + 1]) -> ScheduledValueChange<T>\nwhere\n    T: Packable<N>,\n{\n    let svc_pre_packed = arrays::subarray(packed, 1);\n    let svc_post_packed = arrays::subarray(packed, N + 1);\n    ScheduledValueChange::new(\n        T::unpack(svc_pre_packed),\n        T::unpack(svc_post_packed),\n        packed[0] as u32,\n    )\n}\n\npub fn unpack_delay_change<let INITIAL_DELAY: u32>(\n    packed: Field,\n) -> ScheduledDelayChange<INITIAL_DELAY> {\n    // This function expects to be called with just the first field of the packed representation, which contains sdc\n    // and svc block_of_change. We'll discard the svc component.\n    let svc_block_of_change = packed as u32;\n\n    let mut tmp = (packed - svc_block_of_change as Field) / TWO_POW_32;\n    let sdc_block_of_change = tmp as u32;\n\n    tmp = (tmp - sdc_block_of_change as Field) / TWO_POW_32;\n    let sdc_post_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_post_is_some as Field) / TWO_POW_8;\n    let sdc_post_inner = tmp as u32;\n\n    tmp = (tmp - sdc_post_inner as Field) / TWO_POW_32;\n    let sdc_pre_is_some = tmp as bool;\n\n    tmp = (tmp - sdc_pre_is_some as Field) / TWO_POW_8;\n    let sdc_pre_inner = tmp as u32;\n\n    ScheduledDelayChange {\n        pre: if sdc_pre_is_some {\n            Option::some(sdc_pre_inner)\n        } else {\n            Option::none()\n        },\n        post: if sdc_post_is_some {\n            Option::some(sdc_post_inner)\n        } else {\n            Option::none()\n        },\n        block_of_change: sdc_block_of_change,\n    }\n}\n\nglobal TWO_POW_32: Field = 2.pow_32(32);\nglobal TWO_POW_8: Field = 2.pow_32(8);\n\n// We pack to `2 * N + 1` fields because ScheduledValueChange contains T twice (hence `2 * N`) and we need one extra\n// field to store ScheduledDelayChange and the block_of_change of ScheduledValueChange.\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Packable<2 * N + 1> for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; 2 * N + 1] {\n        let mut result = [0; 2 * N + 1];\n\n        // We pack sdc.pre, sdc.post, sdc.block_of_change and svc.block_of_change into a single field as follows:\n        // [ sdc.pre_inner: u32 | sdc.pre_is_some: u8 | sdc.post_inner: u32 | sdc.post_is_some: u8 | sdc.block_of_change: u32 | svc.block_of_change: u32 ]\n        result[0] = self.svc.block_of_change as Field\n            + ((self.sdc.block_of_change as Field) * 2.pow_32(32))\n            + ((self.sdc.post.is_some() as Field) * 2.pow_32(64))\n            + ((self.sdc.post.unwrap_unchecked() as Field) * 2.pow_32(72))\n            + ((self.sdc.pre.is_some() as Field) * 2.pow_32(104))\n            + ((self.sdc.pre.unwrap_unchecked() as Field) * 2.pow_32(112));\n\n        // Pack the pre and post values from ScheduledValueChange\n        let svc_pre_packed = self.svc.pre.pack();\n        let svc_post_packed = self.svc.post.pack();\n        for i in 0..N {\n            result[i + 1] = svc_pre_packed[i];\n            result[i + 1 + N] = svc_post_packed[i];\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; 2 * N + 1]) -> Self {\n        let svc = unpack_value_change::<T, N>(fields);\n        let sdc = unpack_delay_change::<INITIAL_DELAY>(fields[0]);\n        Self::new(svc, sdc)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32, let N: u32> Hash for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn hash(self) -> Field {\n        poseidon2_hash(self.pack())\n    }\n}\n"
    },
    "319": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "333": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "337": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "338": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "354": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "355": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "357": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "367": {
      "path": "/home/nerses/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "396": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialUintNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        context.emit_private_log(encrypted_log);\n\n        PartialUintNote { commitment }\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, value: u128, context: &mut PublicContext) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "50": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/lib.nr",
      "source": "pub fn bytes_to_u128_limbs(bytes: [u8; 32]) -> (u128, u128) {\n    let mut high: u128 = 0;\n    let mut low: u128 = 0;\n    for i in 0..16 {\n        high = (high << 8) + (bytes[i] as u128);\n    }\n    for i in 16..32 {\n        low = (low << 8) + (bytes[i] as u128);\n    }\n    (high, low)\n}\n\npub fn u128_limbs_to_bytes(high: u128, low: u128) -> [u8; 32] {\n    let mut bytes: [u8; 32] = [0; 32];\n\n    let mut temp = high;\n    for i in 0..16 {\n        bytes[15 - i] = (temp & 0xff) as u8;\n        temp >>= 8;\n    }\n\n    temp = low;\n    for i in 0..16 {\n        bytes[31 - i] = (temp & 0xff) as u8;\n        temp >>= 8;\n    }\n\n    bytes\n}\n"
    },
    "51": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/main.nr",
      "source": "//     @@                                    @@@\n//    @@@\n//    @@@        @@   @@@@      @@@@@         @     @    @@@@@\n//  @@@@@@@@@   @@@@@@      @@@@    @@@@@    @@@   @@@@@@    @@@@\n//    @@@       @@@       @@@           @@@  @@@   @@@          @@@\n//    @@@       @@@       @@@           @@@  @@@   @@@          @@@\n//    @@@       @@@       @@@           @@@  @@@   @@@          @@@\n//     @@@      @@@        @@@@       @@@@@  @@@   @@@          @@@\n//       @@@@@  @@@           @@@@@@@@@ @@@  @@@   @@@          @@@\n\nmod lib;\nmod types;\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract Train {\n    use crate::lib::{bytes_to_u128_limbs, u128_limbs_to_bytes};\n    use crate::types::events::{\n        TokenCommitted, TokenLockAdded, TokenLocked, TokenRedeemed, TokenRefunded,\n    };\n    use dep::aztec::messages::logs::note::encode_and_encrypt_note;\n    use dep::aztec::protocol_types::traits::{Packable, Serialize};\n    use dep::aztec::state_vars::{private_immutable::PrivateImmutable, SharedMutable};\n    use dep::sha256;\n    use dep::token::Token;\n    use aztec::macros::{\n        functions::{initializer, internal, private, public, utility, view},\n        notes::note,\n        storage::storage,\n    };\n    use aztec::prelude::{AztecAddress, Map};\n    use std::meta::derive;\n\n    #[note]\n    #[derive(Eq)]\n    struct HTLC_Private {\n        owner: AztecAddress,\n        randomness: Field,\n    }\n    #[derive(Eq, Packable, Serialize)]\n    pub struct HTLC_Public {\n        src_receiver: AztecAddress,\n        amount: u128,\n        token: AztecAddress,\n        hashlock_high: u128,\n        hashlock_low: u128,\n        secret_high: u128,\n        secret_low: u128,\n        ownership_hash_high: u128,\n        ownership_hash_low: u128,\n        timelock: u64,\n        claimed: u8,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor() {}\n\n    #[storage]\n    struct Storage<Context> {\n        contracts_private: Map<Field, PrivateImmutable<HTLC_Private, Context>, Context>,\n        contracts_public: Map<Field, SharedMutable<HTLC_Public, 2, Context>, Context>,\n    }\n\n    #[private]\n    fn commit_private_user(\n        Id: Field,\n        src_receiver: AztecAddress,\n        timelock: u64,\n        token: AztecAddress,\n        amount: u128,\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n        randomness: Field,\n    ) {\n        assert(amount > 0, \"Funds Not Sent\");\n\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address())\n            .commit_public_user(\n                dst_chain,\n                dst_asset,\n                dst_address,\n                Id,\n                src_receiver,\n                timelock,\n                token,\n                amount,\n            )\n            .enqueue(&mut context);\n\n        let htlc_note = HTLC_Private { owner: context.msg_sender(), randomness: randomness };\n        storage.contracts_private.at(Id).initialize(htlc_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        Token::at(token)\n            .transfer_to_public(context.msg_sender(), context.this_address(), amount, randomness)\n            .call(&mut context);\n    }\n\n    #[internal]\n    #[public]\n    fn commit_public_user(\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n        Id: Field,\n        src_receiver: AztecAddress,\n        timelock: u64,\n        token: AztecAddress,\n        amount: u128,\n    ) {\n        assert(context.timestamp() + 900 < timelock, \"InvalidTimelock\");\n        let htlc_public = HTLC_Public {\n            src_receiver: src_receiver,\n            amount: amount,\n            token: token,\n            hashlock_high: 0 as u128,\n            hashlock_low: 0 as u128,\n            secret_high: 0 as u128,\n            secret_low: 0 as u128,\n            ownership_hash_high: 0 as u128,\n            ownership_hash_low: 0 as u128,\n            timelock: timelock,\n            claimed: 1 as u8,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(htlc_public);\n        let log_msg = TokenCommitted {\n            Id: Id,\n            amount: amount,\n            token: token,\n            timelock: timelock,\n            dst_chain: dst_chain,\n            dst_asset: dst_asset,\n            dst_address: dst_address,\n            src_receiver: src_receiver,\n        };\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn add_lock_private_user(Id: Field, hashlock: [u8; 32], timelock: u64) {\n        let htlc_private = storage.contracts_private.at(Id).get_note();\n        assert(htlc_private.owner == context.msg_sender(), \"NoAllowance\");\n\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).add_lock_public_user(Id, hashlock, timelock).enqueue(\n            &mut context,\n        );\n    }\n\n    #[internal]\n    #[public]\n    fn add_lock_public_user(Id: Field, hashlock: [u8; 32], timelock: u64) {\n        assert(context.timestamp() + 900 < timelock, \"InvalidTimelock\");\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        assert(htlc_public.hashlock_high == (0 as u128), \"HashlockAlreadySet\");\n        assert(htlc_public.hashlock_low == (0 as u128), \"HashlockAlreadySet\");\n\n        let hashlock_tuple = bytes_to_u128_limbs(hashlock);\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: hashlock_tuple.0,\n            hashlock_low: hashlock_tuple.1,\n            secret_high: htlc_public.secret_high,\n            secret_low: htlc_public.secret_low,\n            ownership_hash_high: htlc_public.ownership_hash_high,\n            ownership_hash_low: htlc_public.ownership_hash_low,\n            timelock: timelock,\n            claimed: htlc_public.claimed,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n        let log_msg = TokenLockAdded { Id, hashlock, timelock };\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn refund_private(Id: Field) {\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).refund_public(Id).enqueue(&mut context);\n\n        let htlc_private = storage.contracts_private.at(Id).get_note();\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n\n        let partial_note = Token::at(htlc_public.token)\n            .prepare_private_balance_increase(htlc_private.owner, htlc_private.owner)\n            .call(&mut context);\n        Token::at(htlc_public.token)\n            .finalize_transfer_to_private(htlc_public.amount, partial_note)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn refund_public(Id: Field) {\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        assert(htlc_public.timelock < context.timestamp(), \"NotPassedTimelock\");\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: htlc_public.hashlock_high,\n            hashlock_low: htlc_public.hashlock_low,\n            secret_high: htlc_public.secret_high,\n            secret_low: htlc_public.secret_low,\n            ownership_hash_high: htlc_public.ownership_hash_high,\n            ownership_hash_low: htlc_public.ownership_hash_low,\n            timelock: htlc_public.timelock,\n            claimed: 2 as u8,\n        };\n\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n        let log_msg = TokenRefunded { Id };\n        context.emit_public_log(log_msg);\n    }\n\n    #[private]\n    fn lock_private_solver(\n        Id: Field,\n        hashlock: [u8; 32],\n        amount: u128,\n        ownership_hash: [u8; 32],\n        timelock: u64,\n        token: AztecAddress,\n        randomness: Field,\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n    ) {\n        assert(amount > 0, \"FundsNotSent\");\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address())\n            .lock_public_solver(\n                Id,\n                hashlock,\n                ownership_hash,\n                amount,\n                token,\n                timelock,\n                dst_chain,\n                dst_asset,\n                dst_address,\n            )\n            .enqueue(&mut context);\n\n        let htlc_note = HTLC_Private { owner: context.msg_sender(), randomness: randomness };\n        storage.contracts_private.at(Id).initialize(htlc_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        Token::at(token)\n            .transfer_to_public(context.msg_sender(), context.this_address(), amount, randomness)\n            .call(&mut context);\n    }\n\n    #[internal]\n    #[public]\n    fn lock_public_solver(\n        Id: Field,\n        hashlock: [u8; 32],\n        ownership_hash: [u8; 32],\n        amount: u128,\n        token: AztecAddress,\n        timelock: u64,\n        dst_chain: str<8>,\n        dst_asset: str<8>,\n        dst_address: str<48>,\n    ) {\n        assert(context.timestamp() + 1800 < timelock, \"InvalidTimelock\");\n        let hashlock_tuple = bytes_to_u128_limbs(hashlock);\n        let ownership_hash_tuple = bytes_to_u128_limbs(ownership_hash);\n        let htlc_public = HTLC_Public {\n            src_receiver: AztecAddress::zero(),\n            amount: amount,\n            token: token,\n            hashlock_high: hashlock_tuple.0,\n            hashlock_low: hashlock_tuple.1,\n            secret_high: 0 as u128,\n            secret_low: 0 as u128,\n            ownership_hash_high: ownership_hash_tuple.0,\n            ownership_hash_low: ownership_hash_tuple.1,\n            timelock: timelock,\n            claimed: 1 as u8,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(htlc_public);\n\n        let log_msg = TokenLocked {\n            Id: Id,\n            hashlock: hashlock,\n            ownership_hash: ownership_hash,\n            amount: amount,\n            src_receiver: AztecAddress::zero(),\n            token: token,\n            timelock: timelock,\n            dst_chain: dst_chain,\n            dst_asset: dst_asset,\n            dst_address: dst_address,\n        };\n\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn redeem_private(Id: Field, secret: [u8; 32], ownership_key: [u8; 32]) {\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).redeem_public(Id, secret, ownership_key).enqueue(\n            &mut context,\n        );\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        if (htlc_public.ownership_hash_high == 0 as u128) {\n            if htlc_public.ownership_hash_low == 0 as u128 {\n                let partial_note = Token::at(htlc_public.token)\n                    .prepare_private_balance_increase(\n                        htlc_public.src_receiver,\n                        htlc_public.src_receiver,\n                    )\n                    .call(&mut context);\n                Token::at(htlc_public.token)\n                    .finalize_transfer_to_private(htlc_public.amount, partial_note)\n                    .enqueue(&mut context);\n            }\n        } else {\n            let partial_note = Token::at(htlc_public.token)\n                .prepare_private_balance_increase(context.msg_sender(), context.msg_sender())\n                .call(&mut context);\n            Token::at(htlc_public.token)\n                .finalize_transfer_to_private(htlc_public.amount, partial_note)\n                .enqueue(&mut context);\n        }\n    }\n\n    #[public]\n    #[internal]\n    fn redeem_public(Id: Field, secret: [u8; 32], ownership_key: [u8; 32]) {\n        let mut htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.amount > 0, \"HTLCNotExists\"); // If it doesn't exist, all parameters will default to zero values.\n        let hashed_secret = sha256::sha256_var(secret, secret.len() as u64);\n        let hashed_secret_tuple = bytes_to_u128_limbs(hashed_secret);\n        assert(htlc_public.hashlock_high == hashed_secret_tuple.0, \"HashlockNotMatch\");\n        assert(htlc_public.hashlock_low == hashed_secret_tuple.1, \"HashlockNotMatch\");\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n\n        if (htlc_public.ownership_hash_high != 0 as u128) {\n            if htlc_public.ownership_hash_low != 0 as u128 {\n                let ownership_key_hashed =\n                    sha256::sha256_var(ownership_key, ownership_key.len() as u64);\n                let ownership_key_tuple = bytes_to_u128_limbs(ownership_key_hashed);\n                assert(htlc_public.ownership_hash_high == ownership_key_tuple.0, \"NotAnOwner\");\n                assert(htlc_public.ownership_hash_low == ownership_key_tuple.1, \"NotAnOwner\");\n            }\n        }\n\n        let secret_limbs = bytes_to_u128_limbs(secret);\n\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: htlc_public.hashlock_high,\n            hashlock_low: htlc_public.hashlock_low,\n            secret_high: secret_limbs.0,\n            secret_low: secret_limbs.1,\n            ownership_hash_high: htlc_public.ownership_hash_high,\n            ownership_hash_low: htlc_public.ownership_hash_low,\n            timelock: htlc_public.timelock,\n            claimed: 3 as u8,\n        };\n\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n\n        let log_msg = TokenRedeemed {\n            Id: Id,\n            hashlock: u128_limbs_to_bytes(htlc_public.hashlock_high, htlc_public.hashlock_low),\n            secret: secret,\n        };\n\n        context.emit_public_log(log_msg.pack());\n    }\n\n    // This utility function should be invoked by the frontend before each function call\n    // where the existence or non-existence of an HTLC is a critical security check.\n    #[utility]\n    unconstrained fn is_contract_initialized(Id: Field) -> bool {\n        storage.contracts_private.at(Id).is_initialized()\n    }\n\n    #[view]\n    #[public]\n    fn get_htlc_public(key: Field) -> pub HTLC_Public {\n        storage.contracts_public.at(key).get_current_value()\n    }\n}\n"
    },
    "52": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/types/events.nr",
      "source": "use dep::aztec::prelude::AztecAddress;\nuse dep::aztec::protocol_types::traits::{Packable, Serialize};\n\n#[derive(Serialize)]\npub struct TokenCommitted {\n    pub Id: Field,\n    pub amount: u128,\n    pub token: AztecAddress,\n    pub timelock: u64,\n    pub dst_chain: str<8>,\n    pub dst_asset: str<8>,\n    pub dst_address: str<48>,\n    pub src_receiver: AztecAddress,\n}\n\nimpl Packable<9> for TokenCommitted {\n    fn pack(self) -> [Field; 9] {\n        let zero: Field = 0;\n        let mut out = [zero; 9];\n        out[0] = self.Id;\n        out[1] = self.amount as Field;\n        out[2] = self.token.inner;\n        out[3] = self.timelock as Field;\n\n        let dst_chain_byte_array = self.dst_chain.as_bytes();\n        let mut dst_chain_byte_array_filled = [0 as u8; 31];\n        for i in 0..dst_chain_byte_array.len() {\n            dst_chain_byte_array_filled[i] = dst_chain_byte_array[i];\n        }\n\n        out[4] = Field::from_be_bytes::<31>(dst_chain_byte_array_filled);\n\n        let dst_asset_byte_array = self.dst_asset.as_bytes();\n        let mut dst_asset_byte_array_filled = [0 as u8; 31];\n        for i in 0..dst_asset_byte_array.len() {\n            dst_asset_byte_array_filled[i] = dst_asset_byte_array[i];\n        }\n\n        out[5] = Field::from_be_bytes::<31>(dst_asset_byte_array_filled);\n\n        let dst_address_byte_array = self.dst_address.as_bytes();\n        let mut dst_address_byte_array_filled_1 = [0 as u8; 31];\n        let mut dst_address_byte_array_filled_2 = [0 as u8; 31];\n\n        for i in 0..31 {\n            dst_address_byte_array_filled_1[i] = dst_address_byte_array[i];\n        }\n\n        for i in 31..48 {\n            dst_address_byte_array_filled_2[i - 31] = dst_address_byte_array[i];\n        }\n\n        out[6] = Field::from_be_bytes::<31>(dst_address_byte_array_filled_1);\n        out[7] = Field::from_be_bytes::<31>(dst_address_byte_array_filled_2);\n\n        out[8] = self.src_receiver.inner;\n        out\n    }\n\n    fn unpack(fields: [Field; 9]) -> Self {\n        assert(false, \"unpack not implemented\");\n        TokenCommitted {\n            Id: fields[0] as Field,\n            amount: 0 as u128,\n            token: AztecAddress::zero(),\n            timelock: 0 as u64,\n            dst_chain: \"00000000\",\n            dst_asset: \"00000000\",\n            dst_address: \"000000000000000000000000000000000000000000000000\",\n            src_receiver: AztecAddress::zero(),\n        }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenLockAdded {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub timelock: u64,\n}\n\nimpl Packable<4> for TokenLockAdded {\n    fn pack(self) -> [Field; 4] {\n        let mut out = [0 as Field; 4];\n        out[0] = self.Id;\n\n        let hb = self.hashlock;\n        let mut h1 = [0 as u8; 31];\n        for i in 0..31 {\n            h1[i] = hb[i];\n        }\n        out[1] = Field::from_be_bytes::<31>(h1);\n\n        let mut h2 = [0 as u8; 31];\n        h2[0] = hb[31];\n        out[2] = Field::from_be_bytes::<31>(h2);\n\n        out[3] = self.timelock as Field;\n        out\n    }\n\n    fn unpack(fields: [Field; 4]) -> Self {\n        let Id = fields[0];\n\n        let b1 = fields[1].to_be_bytes();\n        let b2 = fields[2].to_be_bytes();\n        let mut hash = [0 as u8; 32];\n        for i in 0..31 {\n            hash[i] = b1[i];\n        }\n        hash[31] = b2[0];\n\n        let timelock = fields[3] as u64;\n\n        TokenLockAdded { Id, hashlock: hash, timelock }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenRefunded {\n    pub Id: Field,\n}\n\n#[derive(Serialize)]\npub struct TokenRedeemed {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub secret: [u8; 32],\n}\n\nimpl Packable<5> for TokenRedeemed {\n    fn pack(self) -> [Field; 5] {\n        let mut out = [0 as Field; 5];\n        out[0] = self.Id;\n\n        let hb = self.hashlock;\n        let mut h1 = [0 as u8; 31];\n        for i in 0..31 {\n            h1[i] = hb[i];\n        }\n        out[1] = Field::from_be_bytes::<31>(h1);\n        let mut h2 = [0 as u8; 31];\n        h2[0] = hb[31];\n        out[2] = Field::from_be_bytes::<31>(h2);\n\n        let sb = self.secret;\n        let mut s1 = [0 as u8; 31];\n        for i in 0..31 {\n            s1[i] = sb[i];\n        }\n        out[3] = Field::from_be_bytes::<31>(s1);\n        let mut s2 = [0 as u8; 31];\n        s2[0] = sb[31];\n        out[4] = Field::from_be_bytes::<31>(s2);\n\n        out\n    }\n\n    fn unpack(fields: [Field; 5]) -> Self {\n        let Id = fields[0];\n\n        let b1 = fields[1].to_be_bytes();\n        let b2 = fields[2].to_be_bytes();\n        let mut hashlock = [0 as u8; 32];\n        for i in 0..31 {\n            hashlock[i] = b1[i];\n        }\n        hashlock[31] = b2[0];\n\n        let b3 = fields[3].to_be_bytes();\n        let b4 = fields[4].to_be_bytes();\n        let mut secret = [0 as u8; 32];\n        for i in 0..31 {\n            secret[i] = b3[i];\n        }\n        secret[31] = b4[0];\n\n        TokenRedeemed { Id, hashlock, secret }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenLocked {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub ownership_hash: [u8; 32],\n    pub amount: u128,\n    pub src_receiver: AztecAddress,\n    pub token: AztecAddress,\n    pub timelock: u64,\n    pub dst_chain: str<8>,\n    pub dst_asset: str<8>,\n    pub dst_address: str<48>,\n}\n\nimpl Packable<13> for TokenLocked {\n    fn pack(self) -> [Field; 13] {\n        let mut out = [0 as Field; 13];\n        out[0] = self.Id;\n\n        let hb = self.hashlock;\n        let mut h1 = [0 as u8; 31];\n        for i in 0..31 {\n            h1[i] = hb[i];\n        }\n        out[1] = Field::from_be_bytes::<31>(h1);\n\n        let mut h2 = [0 as u8; 31];\n        h2[0] = hb[31];\n        out[2] = Field::from_be_bytes::<31>(h2);\n\n        let ownership = self.ownership_hash;\n        let mut o1 = [0 as u8; 31];\n        for i in 0..31 {\n            o1[i] = ownership[i];\n        }\n        out[3] = Field::from_be_bytes::<31>(o1);\n\n        let mut o2 = [0 as u8; 31];\n        o2[0] = ownership[31];\n        out[4] = Field::from_be_bytes::<31>(o2);\n\n        out[5] = self.amount as Field;\n        out[6] = self.src_receiver.inner as Field;\n        out[7] = self.token.inner;\n        out[8] = self.timelock as Field;\n\n        let dst_chain_byte_array = self.dst_chain.as_bytes();\n        let mut dst_chain_byte_array_filled = [0 as u8; 31];\n        for i in 0..dst_chain_byte_array.len() {\n            dst_chain_byte_array_filled[i] = dst_chain_byte_array[i];\n        }\n        out[9] = Field::from_be_bytes::<31>(dst_chain_byte_array_filled);\n\n        let dst_asset_byte_array = self.dst_asset.as_bytes();\n        let mut dst_asset_byte_array_filled = [0 as u8; 31];\n        for i in 0..dst_asset_byte_array.len() {\n            dst_asset_byte_array_filled[i] = dst_asset_byte_array[i];\n        }\n        out[10] = Field::from_be_bytes::<31>(dst_asset_byte_array_filled);\n\n        let addr = self.dst_address.as_bytes();\n        let mut dst_address_byte_array_filled_1 = [0 as u8; 31];\n        let mut dst_address_byte_array_filled_2 = [0 as u8; 31];\n        for i in 0..31 {\n            dst_address_byte_array_filled_1[i] = addr[i];\n        }\n        for i in 31..48 {\n            dst_address_byte_array_filled_2[i - 31] = addr[i];\n        }\n        out[11] = Field::from_be_bytes::<31>(dst_address_byte_array_filled_1);\n        out[12] = Field::from_be_bytes::<31>(dst_address_byte_array_filled_2);\n\n        out\n    }\n\n    fn unpack(fields: [Field; 13]) -> Self {\n        assert(false, \"unpack not implemented\");\n        TokenLocked {\n            Id: fields[0] as Field,\n            hashlock: [0 as u8; 32],\n            ownership_hash: [0 as u8; 32],\n            amount: 0 as u128,\n            src_receiver: AztecAddress::zero(),\n            token: AztecAddress::zero(),\n            timelock: 0 as u64,\n            dst_chain: \"00000000\",\n            dst_asset: \"00000000\",\n            dst_address: \"000000000000000000000000000000000000000000000000\",\n        }\n    }\n}\n"
    },
    "54": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "55": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "62": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "63": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "64": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "65": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "69": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "81": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "84": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n"
    },
    "85": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
      "source": "use std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // Safety: we use the randomness to preserve the privacy of both the sender and recipient via encryption, so a\n    // malicious sender could use non-random values to reveal the plaintext. But they already know it themselves anyway,\n    // and so the recipient already trusts them to not disclose this information. We can therefore assume that the\n    // sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // TODO(#12757): compute the key pair without constraining eph_sk twice (once in from_field, once in the black box\n    // called by fixed_base_scalar_mul).\n    let eph_sk = EmbeddedCurveScalar::from_field(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
    },
    "86": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "90": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_notes` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    // TODO(https://github.com/noir-lang/noir/issues/7912): Doing the following unfortunately doesn't work. Once\n    // the issue is fixed uncomment the following and remove the workaround from TS (look for the issue link in the\n    // codebase).\n    // let utility: fn(FunctionDefinition) -> () = crate::macros::functions::utility;\n    // quote {\n    //     #[$utility]\n    //     unconstrained fn sync_notes() {\n    //     }\n    // }\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[aztec::macros::functions::utility]\n        unconstrained fn sync_notes() { }\n    }\n}\n"
    },
    "91": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "94": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n"
    },
    "95": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "98": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    }
  }
}
