{
  "transpiled": true,
  "noir_version": "1.0.0-beta.7+0000000000000000000000000000000000000000",
  "name": "Train",
  "functions": [
    {
      "name": "add_lock_private_user",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::include_by_timestamp::IncludeByTimestamp",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                          "fields": [
                            {
                              "name": "recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "content",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17476367995570638746": {
            "error_kind": "string",
            "string": "NoAllowance"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "add_lock_public_user",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2722406262643068352": {
            "error_kind": "string",
            "string": "HashlockAlreadySet"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16870384257694633552": {
            "error_kind": "string",
            "string": "Function add_lock_public_user can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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Kh0LHBwKLgsAJwIdAEgnAiEEKy0IACstCgUsLQodLQAIACEAJQAAGkMtAgAALQosHgQqCx4dACocHQsnAhwAaCcCHgQrLQgAKy0KBSwtChwtAAgAHgAlAAAaQy0CAAAtCiwdBCoKHRwAKgscChwKKgsAJwIcAHAnAh4EIS0IACEtCgUiLQocIwAIAB4AJQAAGkMtAgAALQoiHQQqCx0FACoKBQstCAEFJwIKBBgACAEKAScDBQQBACIFAgotCgocLQ4LHAAiHAIcLgyARwAcACIcAhwuDIBHABwAIhwCHC4MgEcAHAAiHAIcLgyARwAcACIcAhwuDIBHABwAIhwCHC4MgEcAHAAiHAIcLgyARwAcACIcAhwuDIBHABwAIhwCHC4MgEcAHAAiHAIcLgyARwAcACIcAhwuDIBHABwAIhwCHC4MgEcAHAAiHAIcLgyARwAcACIcAhwuDIBHABwAIhwCHC4MgEcAHAAiHAIcLgyARwAcACIcAhwuDIBHABwAIhwCHC4MgEcAHAAiHAIcLgyARwAcACIcAhwuDIBHABwAIhwCHC4MgEcAHAAiHAIcLgyARwAcLQ4FCRwKHwUAHAoSCgAcChYLABwKGBIAHAoaFgAcChsYABwKERoAHAoOEQAcCgQOAC0IAQQnAhsEDAAIARsBJwMEBAEAIgQCGy0KGxwtDgYcACIcAhwtDgUcACIcAhwtDiAcACIcAhwtDgocACIcAhwtDgscACIcAhwtDhIcACIcAhwtDhYcACIcAhwtDhgcACIcAhwtDhocACIcAhwtDhEcACIcAhwtDg4cHAoZBQAcCggGABwKDAgAHAoTCgAcChQLABwKFQwAHAoPDgAcCgMPAC0IAQMnAhEEDAAIAREBJwMDBAEAIgMCES0KERItDgcSACISAhItDgUSACISAhItDhASACISAhItDgYSACISAhItDggSACISAhItDgoSACISAhItDgsSACISAhItDgwSACISAhItDg4SACISAhItDg8SACISAhIuDIBKABIuCIBFABcjAAANnA0iABeATgAFJAIABQAAEf8jAAANsS0LCQQtCwQFACIFAgUtDgUELQgBBScCBwQEAAgBBwEnAwUEAQAiBQIHLQoHCS4MgEcACQAiCQIJLgyARwAJACIJAgkuDIBHAAkrAgAHAAAAAAAAAAAXAAAAAAAAAAAt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",
      "debug_symbols": "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",
      "brillig_names": [
        "add_lock_public_user"
      ]
    },
    {
      "name": "commit_private_user",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_receiver",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 90
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::include_by_timestamp::IncludeByTimestamp",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                          "fields": [
                            {
                              "name": "recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "content",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6418028854678020178": {
            "error_kind": "string",
            "string": "FundsNotSent"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc88898xzzzz3zHPPPPfMc88898xzzzz3zHPPPPfMc88898xzzzz3zHPPPPfMc88898xzzzz3zHPPPPfM8yj+qh6kSZbkSTWpTYo871SSKImTUoNTg1ODUyPyvAa1SZHnnUoSJXGSJGmSJXlSakhqaGpoamhqaGpoamhqaGpoamhqaGpYalhqWGpYalhqWGpYalhqWGpYanhqeGp4anhqeGp4anhqeGp4anhq1NSoqVFTo6ZGTY2aGjU1amrU1Kip0VKjpUZLjZYaLTVaarTUaKnRUuPO80b/cH/yeyWVpIdGkyBOkiRNsiRPqklt0p3ng0pSapTUKKlRUqOkRkmNkholNSg1KDUoNSg1KDUoNSg1KDUoNSg1ODU4NTg1ODU4NTg1ODU4NTg1ODUkNSQ1JDUkNSQ1JDUkNSQ1JDUkNTQ1NDU0NTQ1NDU0NTQ1NDU0NTQ1LDUsNSw1LDUsNSw1LDUsNSw1LDU8NTw1PDU8NTw1PDU8NTw1PDU8NWpq1NSoqVFTo6ZGTY2aGjU1amrU1Gip0VKjpUZLjZYaLTVaarTUaKnRpkYUqw0qSZTESZKkSZbkSTUpNTLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLP28xzumae0zXznK6Z53TNPKdr5jldM8/pmnlO18xzumae03WlRkmNkholNUpqlNQoqVFSo6RGSY2SGpQalBqUGpQalBqUGpQalBqUGpQanBqcGpwanBqcGpwanBqcGpwanBqSGpIakhqSGpIakhqSGpIakhqSGpoamhqaGpoamhqaGpoa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n6ugV0Gvgl4FvQp6FfQq6FXQq6BX0fA2vPQq6FXQq2h4G156FfQq6FXQq6BXQa+CXkXH2xd8v79Br4JexcA78NKroFdBr4JeBb0KehX0Kibe2WDmmV4FvYqJd+KlVzHxJt5knulVJONNxkuvIjm+yTwn85zMc+EtvIW38BbeYp6L8RbjLcZbeBfHdzHPi3lezPPCu/AuvAvvwruY5814N+PdjHfj3RzfzTxv5nkzzxvvve4T7V74iXavIkdjfdVYXzXWV431VWN91ehVey34znOLFxww3sAbeAMvvWr0qtGrRq8avWoNb2twhwc8YbwNL71q9KrRq0avGr1q9KrRq9bx9oSZZ3rV6FUbeAdeetXoVaNXjV41etXoVaNXbeCdHF961ehVo1dt4p146VWjV41eNXrV6FWjV41eNdZXjfVVo1eNXjV61VhfNdZXjV41etXoVaNXjV41etXoVSu8xfGlV41eNXrVFt6Fl141etXoVaNXjV41etXoVdt4N8eXXjV61ehV23g3XnrV6FWnV51edXrV6VWnV531VWd91elVp1edXnXWV531VadXnV51etXpVadXnV51etUD770RFp1edXrV6VXnfLA3vPSq06tOrzq96vSq06tOr3rHe2+LRadXnV51etU5H+wdL73q9KrTq06vOr3q9KrTqz7wDo4vver0qtOrzvlgn3jpVadXnV51etXpVadXnV51zgd7cnzpVadXnV51zgc754OdXnV61elVp1edXnV61elVL7zF8aVXnV51etUX3oWXXnV61elVp1edXnV61elVX3g3x5dedXrV6VXfeDdeetXpVadXnV4NejXo1aBX414Pj3FvrsWgV4NeDXo1OB8cnA8OejXo1aBXg14NejXo1aBXI/DeW20x6NWgV4NeDc4HB9evBr0a9GrQq0GvBr0a9GrQq9Hx3htvMejVoFeDXg3OBwfXrwa9GvRq0KtBrwa9GvRq0Ksx8A6OL70a9GrQq8H54OD61aBXg14NejXo1aBXg14NejW4fjW4fjXo1aBXg14NzgdH4qVXg14NejXo1aBXg14NejUKb3F86dWgV4NeDc4HR+GlV4NeDXo16NWgV4NeDXo1Ft7F8aVXg14NejU4HxwbL70a9GrQq0GvBr0a9GrSq8n19nlv38WkV5NeTXo1OR+c9Gqyvpqsrya9mpwPTq63T65fTXo16dWkV5P11bP9+bn+OeNer5vtBQfc4A4PeMIJF7xgvB1vx9vxdrwdb8fb8Xa8HW/HO/AOvAPvwDvwDrwD78A78A68E+/EO/FyPji5fjW5fjXp1aRXk15N1leT9dWkV5NeTXo16dWkV5NeTXo16dWkV5NezcJbeOnVpFeTXk3OByfXrya9mvRq0qtJrya9mvRq0qu58N5bgjHp1aRXk15Nzgcn168mvZr0atKrSa8mvZr0atKryf3B5P5g0qukV0mvkvPB5PpV0qvk/mCyvkrWV0mvkvVVsr5KepVcb0+ut+fdfBDJ+io5H0yuXyXXr5Lr7cn6KllfJeurZH2VrK+S6+3J/cHk/mB25pn1VXI+mFy/Sq5fJdfbk/VVsr5K1lfJ+ipZXyXX25P7g8n9wRzMM+ur5HwwuX6VXL9Krrcn66tkfZWsr5L1VbK+SnqV3B9kJ3awFTvYix1sxg52YwfbsYP92MGG7Eh6lfQq6RWbsiO53p7F8aVXSa+SXrE1O5LrV0mvkl4lvUp6xQbtYId2sEU7kuvtuTi+9CrpVdIrNmpHcv0q6VXSq6RXSa/Yrh3s1w42bEdyvT03x5deFb0qesW27SiuXxW9KnpV9KroFZu3g93bwfbtKNZXxfqq6FXRq6JXbOKOYn1V9KroVdGrolds5Q72cgebuaO43l7cHyx6VfSq6BVbuqO4flX0quhV0auiV2zsDnZ2B1u7o7jeXtwfLHpV9KroFRu8o7h+VfSq6FXRq6JXbPMO9nkHG72jWF8V66uiV0Wvil6x3TuK9VXRq6JXRa+KXrHpO9j1HWz7juJ6e3F/sOhV0auiV2z+juL6VdGroldFr4pesQU82AMebAKP4np7cX+w6FXRq6JXbAWP4vpV0auiV0Wvil6xITzYER5sCY/ientxf7DoVdGroldsDI/F9atFrxa9WvRq0Su2hwf7w4MN4rE4H1zcH1z0atGrRa/YJh6L88FFrxa9WvRq0Ss2iwe7xYPt4rG43r64P7jo1aJXi16xaTwW168WvVr0atGrRa/YOh7sHQ82j8fievvi/uCiV4teLXrFFvJYXL9a9GrRq0WvFr1iI3mwkzzYSh6L6+2L+4OLXi16tegVG8pjcT646NWiV4teLXrFtvJgX3mwsTwW19sX9wcXvVr0atErtpfH4vrVoleLXi16tegVm8yDXebBNvNYXG9f3B9c9GrRq0Wv2Gwei+tXi14terXo1aJXbDkP9pwHm85jcb19cX9w0atFrxa9Yut5LK5fbXq16dWmV5tesQE92IEebEGPzfWrzfWrTa82vdr0io3osbnevunVplebXm16xXb0YD96sCE9NtfbN/cHN73a9GrTK7alx+Z6+6ZXm15terXpFZvTg93pwfb02Fxv39wf3PRq06tNr9ikHpvr7ZtebXq16dWmV2xVD/aqB5vVY3O9fXN/cNOrTa82vWLLerBnPdi0Huxaj02v2Lcem+vtm+tXbF0P9q4Hm9eD3evx2b5+rn9+9q+/f2VkfDawv/+/MvHZwd7P859ejfP8p1fjPP/p1fu36sZnF/uHj/f9P4iIzz72Dx/vPK//9OrDx5vP6x9vnsefXn044OPNM/anVx8+3vdfcY/PjvYPH2+d9/z06sPHW89r7stPrz58vHXm4enVh493He/Tqw9POOHjff89+vhsb//w/nL77G9//y8W22d/+/u3Z7bP/vYPH+/7f4LVPvvbP3y8798s3T772z9c8Ns7339rvz372z98evVzBf5wwA1+e3+uxh8e8Dx83tvp1Zff3vM/LWnP/vYv78unV/P9qz/bs7/9y8f7/my3Z3/7bOc9nF59ecLH28/7Ob368vH25zX35dOrLx/v+zPfnv3tXz7eceb29OrLEz7ecd7n6dWXj3eeuT29+vDp1c9V7sMBH+88r3l69eUBH+88r3969eXjzfOeT6++vC+fXs08n4HTqy8fb533dnr15eOtM7enV19O+HjXmefTqy8f7zre06u5z2ueXs3ns3169X28wwOecMIFL15z38frdR+v4HG8hbcGz8dbeAtvLXjfn12Md+FdeFfn+Yx3TR7Hu4rH8S7Gu/Fu5nnj3Xg33o13492Md+Pdd7zP/vbn8Wd/+5cbz+k8Pnh88njyePH4gu94n/3tX8YbeANvDBhv4A28sXgcb8Pb8LYG33l+9rd/H588njyOt+FteDvejrfj7Yy34+2Mt+Pt93P17G//Po533O/Rs7/9+zjegXdwfAfewTwPxjvwDj5Xk/HO4HG8k3mejHfinYx34p14J156Fcl4k88VvQp6FfQq6FXQq0i8ibfw0qugV0Gvgl4FvQp6FcXxpVdBr4JeBb2KxXgX3oV34aVXQa+CXsXCS69i4914N156FRsvvQp6FfQq9v08t9f9PDd61ehVo1ftNeAJJ1zwgvEGXnrVosGd5+ClV41eNXrV6FWjV41eNXrV6FVrjLfd49saXnrVWvEcxtvu8W30qvXgcbz0qnW89KrRq9YZb2e89KoNvAMvvWr0qg3mmV61gZdetYF34J0c38k806s28U7GS6/a5PjSqzbxTryJl141etXoVaNXLSfPYbz0qtGrxvqq0atWzDO9avSqFd7CS68a66tGr1rhpVdt4WV91VhfNdZXjfVVo1eNXjV61VhfNXrVWF811leN9VWjV41etc3xpVdtc3zpVadXnV71V4M7PHj+5PGEi+csHr/f3876qkfwOF7WV51edXrVA2/gDbz0qtOr3vDSq06vOuurTq96S362eBwvver0qrO+6vSq06vO+qr3yeswXtZXnfVV73jpVadXnV710XkcL73q9KrTq876qrO+6qyvOuurTq8666vO+qpPxsv6qk/Gy/qq06tOrzq96pwP9sRLrzq96vSq06tOrzrrq06vOuurTq964aVXnV51etVZX3V61VlfdXrV6VX/9Kodfrz98OOdhyeccMEL3pc/vXo44AZ3GO/Gu/FuvBvvvt7xesEBN7jDA55wwgUvGO+nV3k44AZ3+PHW4QnjDbyBN/A2xtsYb2O8jfE2xtsYb8Pb8Da8DW/H2/F2vB1vx9vxdrwdb8fb8Q68g3kezPNgnj+9eph5/vTqYbwD78A78U7GOxnvZLyT8U7GOxnvxDvxTryJN/Em3sSbeBNv4k28iTfxFt5inot5Lua5mOdinot5LryFt/AuvIvxLsa7GC+9GvRq0KtBrwa9GvRq0KtBrwa9GvRq0KtBrwa9GvRq0KtBr+brdmO+Am5wh2835mvCyWsWvGC88YIDbnCHBzxhvPRq0qtJrya9mvRq0qtJrya9mvRq0qtJr+anV2euPr063Jnnzjx/enXm8NOrh/HSq0mvJr2a9GrSq0mv5mC8g/EOxjvwDrwDL72a9GrSq0mvJr2a9GrSq0mv5qdXZ34+vXq4YOb506szb59ePYyXXk16NenVpFeTXk16NenVpFeTXs3CW3gLb+EtvIWXXk16NenVpFdz8blafH8X3981YL6/K2G89GrSq0mvJr2a9GrSq0mvJr2a9GrSq0mvJr1K1lfJ+ipZXyXrq2R9layv8nU/V/kqeMH3+5txP1f56dXDeOlV0qukV0mvkl4lvUp6lfQq6VXSq6RXSa+SXiW9SnqVrK+S9VXSq6RX2Rvc4fvfhewTxkuvkl4lvUp6lfQq6VXSq6RXSa+SXiW9SnqV9CrpVdKrpFc5Ge8c8IT5XH16debh06uH8bK+SnqV9CrpVdKrpFdJr5JeJb1KepX0KulV0qukV0mvshhvMd7ie1R8j+r2ORffI9ZXyfoqWV8l66tkfZWsr5JeJb1KepX0KulV0qukV0mvkl7lZryb8W7Gu2836nXHW6+Ar7foVdGrolfF+qpYXxXrq2J9VayvivVV0auiV0Wvil5V3PFWFLxgxtsYb2O89KroVdGroldFr4peFb0qelWcDxbng8X5YHE+WKyvqt/Pc3XG2xlvZ7z9fp5rMF56VfSq6FXRq6JXRa+KXhW9KnpV9KroVdGroldFr4peFb0qelX0quhV0auiV0Wvil4VvSp6VfSq6FXRq6JXVfe/R8X5YHE+WJwPVt3/HhXng8X6qlhfFeurYn1VrK+KXhW9KnpV9KroVS3mefG5WnyuFt+jzedq8z2iV0Wvil4VvSrWV8X6qlhfFeurxfpqcT64OB9cnA+u14DvPK9XwsVrLhgvvVr0atGrRa8WvVpxP8+LXi16tejVivv9XfRqsb5a9GrRq0WvFr1a9GrRq8X54OJ8cLG+WqyvFueDi/PBRa8W54OL9dVifbVYXy3WV2vg5frV4vrV4vrVGvd7tLh+tejVoleLXi16tejVmngnXnq16NWaeCefK65fLa5fLXq16NVKvIk38SbexJt46dWiV4teLXq16NWiV4teLXq16NWiV4teLdZXq/hcLbycD67F52rxuaJXa/E9oleLXi16tRbfI3q1Nt7NeDfj3czzZrybeT69+jmzO7zg/Zuf/e1fjsP9cIP74Tw8Dq/DE074eON1eMHHe/Z2Pvvbvxxwg4835uEBH+/Z5/nsb/9ywcfbzns+vfrw6VWePZ/P/vYvH+/Z8/nsb//y8Z59ns/+9i8nfLz9ef0FH+/Z5/nsb/9ywMd79nw++9u/fLzjvLfTqy8f7zzzfHr15QUfb545P7368vHmec+nV18+3rPP89nf/uXjzeM9vfpywcdbZ65Orz58evVztnI44AZ3+HjX+RyeXn054eNd5z2fXuXZI/rsb/9wPt4zDxnw8Z57Z8/+9i8P+HjPfbRnf/uX3956viOnV1/el0+vfs4+DgfcDp/3dnr15be3ns/z6dWXEz7eOJ+H06svH2+c+T+9+nLAx9vOuE6vvjzg423HdXr15eN9Pv+nV/V8zk+vPnx69eWAG9zhAU844YLx7t/e/uxv/3LADe7wgCeccMELxht4A2/gDbyBN/AG3sAbeANvw9vwNrzt8ebhAU/48dbhghe8L/cXHPd1eoPx9sHzJ4y34+14O96Bd+AdeAfewXgH4x14B96Bd+CdeGfADe4w4514Z8IFL3hfTryJN/Em3sSbzHMy3mS8yXgT79OrDzPPxTwX81x4C2/hLbyFt5jnxXgX412Md+FdHN/FPC/meTHPC+/Cu/FuvBvvZp43492MdzPejXdzfPed53i94ICvN14dHvCEEy54wXe8ES8YbzS4wwOeMN7AG3gDb8PbAma8jfE2xkuvoiVc8IKZZ3oVHW/H2/HSq6BXQa+CXgW9io53cHzpVdCroFcx8A689CroVdCroFdBr4JeBb2KiXdyfOlV0KugVzHxTrz0KuhV0KugV0Gvgl4FvYrEmxxfehX0KuhVFN7CS6+CXgW9CnoV9CroVdCrWHgXx5deBb0KehUL78JLr4JeBb0KehX0KuhV0KvYeDfHl14FvQp61V7X214BN7jDA55wwgUvGG+84IAb3GG8gZdeNXrV6FWjV41eNXrV6FVjfdVYXzV61ehVo1eN9VVjfdXoVaNXjV41etXoVaNXjV61jrcvmHmmV41etYF34KVXjV41etXoVaNXjV41etUm3snxpVeNXjV61SbeiZdeNXrV6FWjV41eNXrV6FVLvMnxpVeNXjV61Qpv4aVXjV41etXoVaNXjV41etUK7+L40qtGrxq9agvvwkuvGr1q9KrRq0avGr1q9KptvJvjS68avWr0qm28+3o7ver0qtOrTq86ver0qtOr/rre/lrwnedOrzq96oE38NKrTq86ver0qtOrTq86veoNb2twhwc8YbycD3Z61elVp1edXnV61elVp1e94+0JM8/0qtOrzvlgH3jpVadXnV51etXpVadXnV71gXdyfOlVp1edXnXOB/vES686ver0qtOrTq86ver0qife5PjSq06vOr3qnA/2xEuvOr3q9KrTq06vOr3q9KoX3uL40qtOrzq96pwP9oWXXnV61elVp1edXnV61elV33g3x5dedXrV6VXnfLBvvPSq06tBrwa9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NLjDA54wXnrVWF811leNXrWGt+FteOlVo1eNXjXWV+3Tq3748e43f3r18PH28/pPrz7c4QFPOOGCF7wvP736MN6Bd+AdeAfegXfgHXgH3ol34p14J96Jd+KdeCfeiXfiTbyJN/Em3sSbeJ9evfftjGd/+5cXvC8/vfpwwA3u8IAnfLzjvIenVx9+vOfz8/Tq4adXz3OeXn248ZwOD54z4cfbDuN9evVhvE+vPoz36dWH8T69+jDezXifXj3vYeN9enX42d/+vM6zv/3Ljed0ePCcCSfPKXj9fg/P/vbP4/GC8UaD8caA8T69+jDeWPC+76HhbQHjbR3G2yaM9+nVh/E2xvv06nkPHW9nnjvezjx3vJ157nj7gvEOxvv06nkPA+9gngfewTwPvIN5HnjH/Tw/+9s/z5mM9+nV8x4m3sk8T7yTeZ54J/M88Saf58SbjPfp1fMenl59+JnnPJxwwQvel59efTjgx7sOd3jAE0644AXvy59ePRww3qdXsx8e8ISP973vdzz72/d7r+N49rd/eV9+evXhgI83zzw/vcozt0+vPjzhhAte8P7Nz/72Lx/ve6/XePa3f/nxrsPH+94TMp797T9XCw8nXPCC9+WnVx8OuMEdHjDewBt4A2/gbXgb3oa34W14G96Gt+FteBvejrfj7Xg73o634+14O96Ot+MdeAfegXfgHXgH3oF34B14B96Jd+KdeJ9evffVjGd/+17nc/X06sMJF7zgffnp1YcDbnCH8SbexJt4E2/iLbyFt/AW3sJbeAtv4S28hffp1TrfzadXH25whwc84YQLXvC+vPFuvBvvxrvxbrwb78a78e7rffa3fzngBnd4wBNOuOAF4w28gTfwBt7AG3gDb+ANvIG34W14G96Gt+FteBvehrfhbXg73o634+14O96Ot+PteDvejnfgHXgH3oF34B14B96Bd+AdeCfeiXfinXgn3ol34p14J96JN/Em3sSbeBNv4k28iTfxJt7CW3gLb+EtvIW38Bbewlt46dWkV5NeTXo16dWkV5NeTXo16dWkV5NeTXo16dWkV5NeTXo16dWkV5NeTXqV9CrpVdKrpFdJr5JeJb1KepX0KulV0qukV0mvkl4lvUp6lfQq6VXSq6RXSa+SXiW9SnqV9CrpVdKrpFdJr5JeJb1KepX0KulV0qukV0mvkl4lvUp6lfQq6VXSq6RXSa+SXiW9SnqV9CrpVdKrpFdJr5JeJb1KepX0KulV0qukV0mvkl4lvUp6lfQq6VXSq6RXSa+SXiW9SnqV9CrpVdKrpFdJr5JeJb1KepX0KulV0qukV0mvkl4lvUp6lfQq6VXSq6RXSa+SXiW9SnqV9CrpVdKrpFdFr4peFb0qelX0quhV0auiV0Wvil4VvSp6VfSq6FXRq6JXRa+KXhW9KnpV9KroVdGroldFr4peFb0qelX0quhV0auiV0Wvil4VvSp6VfSq6FXRq6JXRa+KXhW9KnpV9KroVdGroldFr4peFb0qelX0quhV0auiV0Wvil4VvSp6VfSq6FXRq6JXRa+KXhW9KnpV9KroVdGroldFr4peFb0qelX0quhV0auiV0Wvil4VvSp6VfSq6FXRq6JXRa+KXhW9KnpV9KroVdGroldFr4peFb0qevXZ3/7+fc7js7/9/fdWxtnf/nPz8HW4w+PwPjzhfHPk4YIXvN987rud/e0/3A4HfLzn/trZ3/6bj7fNv//6w//+57/9+Z//5S9/+l9/+G//+fOv/+M//vWP//7nv/7r51///f/82/dP/uVvf/7LX/78P//p3/721z/+6b//x9/+9E9/+esf33/2h9fnH/+wfi6a/lo/Vw//8dcfft7FP+z3rxTeP/+V+/n3fv58zp8/z/n+8/cP/CzK+q+ff6z3A+cnXj8P/Pxj/uPfz0v85/m53n6N9v2ZGb9mvv+4vf/4PPRzM7Gdh/rvh37mqMX7ofF9kbZ+9fV9kTF+jf3+4/n//kTe1x2/2nlW3YfqV2/vh9b9wf2rjfdD+zsPP/cjf/3cl/uM+udSZf0Wt7fmx/MZ789d0p9/rTPa39P4c+vrxzs+Pz5fv/L1+8d/JrA9/3p+PN8j7+fH4/vj8TNdMfvnxyN+/q39nr34+QBE+z3f8XNNOJ7pjPZffYH+ewA/V8d/7gP+nuz6Ndt9y+vXz/2/8wPjzmH9TMN5bP7/D3rco/NzGfr5JL1fdtWv9XOo/v73f/z7/wU=",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "random",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "commit_public_user",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 90
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_receiver",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3559210201980528457": {
            "error_kind": "string",
            "string": "Function commit_public_user can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "10870837545714573535": {
            "error_kind": "string",
            "string": "HTLCAlreadyExists"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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AQ8nAhAEGAAIARABJwMPBAEAIg8CECcCEQQXACoREBEtChASDCoSERMWChMTJAIAEwAAB00uDIBHABIAIhICEiMAAAcsJwIQADcnAhIEEy0IABMtCgwULQoOFS0KEBYtCg8XAAgAEgAlAAAeHi0CAAAtChQRLQsRDAAiDAIMLQ4MEScCDgQSLQgAEi0KERMuCIBJABQACAAOACUAAB7hLQIAAC0KEwwtCxEOACIOAg4tDg4RJwIOBAwnAhMEFC0IABQtChEVLQoOFgAIABMAJQAAHuEtAgAALQoVEgEiABGASQAULQsUExwKExQEHAoUEQAcChETBScCHgQfLQgAHy0KDCAACAAeACUAACAPLQIAAC0KIBEtCiEULQoiFS0KIxYtCiQXLQolGC0KJhktCicaLQooGy0KKRwtCiodJwIoBCktCAApLQoSKgAIACgAJQAAIA8tAgAALQoqDC0KKx4tCiwfLQotIC0KLiEtCi8iLQowIy0KMSQtCjIlLQozJi0KNCcMKg0TEhYKEg0cChITBhwKDRIGBCoTFA0EKhIeEwAqDRMSJwINBgAKKhINEyQCABMAAAjGJQAAIVAeAgANBigCABIFA4QAKg0SEw4qDRMUJAIAFAAACOklAAAhYgwqEwYNJAIADQAACPslAAAhdC0LCw0AIg0CDS0ODQsnAhIEKC0IACgtCgspLgiASwAqLgiARQArAAgAEgAlAAAbcS0CAAAtCikNCyIADYBHAAsLIgALgEUAEiQCABIAAAlQJQAAHT8nAhIEKC0IACguCIBFACkuCIBHACotCgorLQoNLAAIABIAJQAAHVEtAgAALQopCy0IARIAAAECAS0OCxItCAELAAABAgEuDIBGAAstCw8TACITAhMtDhMPJwIUBCgtCAAoLQoSKS0KCyotChArLQoPLAAIABQAJQAAHh4tAgAALQopEy0LEwsAIgsCCy0OCxMnAg8EKC0IACgtChMpLgiASQAqAAgADwAlAAAe4S0CAAAtCikLLQsTDwAiDwIPLQ4PEycCEAQoLQgAKC0KEyktCg4qAAgAEAAlAAAe4S0CAAAtCikPASIAE4BJABAtCxAOHAoOEgQcChIQABwKEA4FJwIuBC8tCAAvLQoLMAAIAC4AJQAAIA8tAgAALQowEC0KMRItCjITLQozFC0KNB4tCjUoLQo2KS0KNyotCjgrLQo5LC0KOi0nAjgEOS0IADktCg86AAgAOAAlAAAgDy0CAAAtCjoLLQo7Li0KPC8tCj0wLQo+MS0KPzItCkAzLQpBNC0KQjUtCkM2LQpENy8KAA0ADxwKDzkEHAo5OAACKg84OSwCAA8ALV4Ji4K6N7Q7maExYRj9INQvUWbJ6fE/teplqW0eCm0EKjkPOBwKODoEHAo6OQACKjg5OgQqOg84HAo4OwEcCjs6ABwKOjsBAio4OjwsAgA4ADAz6iRuUG6Jjpf1cMr/1wTLC7RgMT+3ILKeE55cEAABBCo8OD0cCj0+BBwKPjwAAio9PD4EKj4PPRwKPT4BHAo+DwAcCg8+AQIqPQ8/BCo/OD0cCj0/BBwKPzgAHAo4PQUWCj44HAoPPgUcCjg/BQQqPj04HAo8PQUWCjs8HAo6OwUcCjw+BQQqOz08HAo5OwUeAgA9BgwqPTtAJAIAQAAADAojAAAL8hwKOgwFBCoMPBEAKhE+DC0KDAkjAAAMIhwKDwwFBCoMOBEAKhE/DC0KDAkjAAAMIgAqPQkRDio9ERUkAgAVAAAMOSUAACFiDCo9DgkWCgkOHAoJFQAcCg4WAAQqFRAXBCoWCxAAKhcQCxwKCRAGHAoOFwYEKhASGAQqFy4SACoYEhkEKhUTEgQqFi8TACoSExUEKhAUEgQqFzATACoSExQEKhAeEgQqFzETACoSExYEKhAoEgQqFzITACoSExgEKhApEgQqFzMTACoSExoEKhAqEgQqFzQTACoSExsEKhArEgQqFzUQACoSEBMcCgkQBRwKDhIFBCoQLBcEKhI2EAAqFxASHAoJEAIcCg4JAgQqEC0OBCoJNxAAKg4QCS0IAQ4AAAECARwKERAAJwIRACAnAhwEPS0IAD0tCgo+LQoRPwAIABwAJQAAIYYtAgAALQo+FwQqORcRACoQERcnAhAAQCcCHAQ9LQgAPS0KCj4tChA/AAgAHAAlAAAhhi0CAAAtCj4RBCo6ERAAKhcQERwKPBAAJwIXAEgnAh0EOS0IADktCgo6LQoXOwAIAB0AJQAAIYYtAgAALQo6HAQqEBwXACoRFxAnAhEAaCcCHAQ5LQgAOS0KCjotChE7AAgAHAAlAAAhhi0CAAAtCjoXBCoPFxEAKhARDxwKOBAAJwIRAHAnAhwEHS0IAB0tCgoeLQoRHwAIABwAJQAAIYYtAgAALQoeFwQqEBcKACoPChAtCAEKJwIPBBgACAEPAScDCgQBACIKAg8tCg8RLQ4QEQAiEQIRLgyARwARACIRAhEuDIBHABEAIhECES4MgEcAEQAiEQIRLgyARwARACIRAhEuDIBHABEAIhECES4MgEcAEQAiEQIRLgyARwARACIRAhEuDIBHABEAIhECES4MgEcAEQAiEQIRLgyARwARACIRAhEuDIBHABEAIhECES4MgEcAEQAiEQIRLgyARwARACIRAhEuDIBHABEAIhECES4MgEcAEQAiEQIRLgyARwARACIRAhEuDIBHABEAIhECES4MgEcAEQAiEQIRLgyARwARACIRAhEuDIBHABEAIhECES4MgEcAEQAiEQIRLgyARwARLQ4KDhwKGQoAHAoUDwAcChYQABwKGBEAHAoaFAAcChsWABwKExcAHAoSEwAcCgkSAC0IAQknAhgEDAAIARgBJwMJBAEAIgkCGC0KGBktDgsZACIZAhktDgoZACIZAhktDhUZACIZAhktDg8ZACIZAhktDhAZACIZAhktDhEZACIZAhktDhQZACIZAhktDhYZACIZAhktDhcZACIZAhktDhMZACIZAhktDhIZHAoICgAcCgYIAC0IAQYnAgsEDAAIAQsBJwMGBAEAIgYCCy0KCw8tDgUPACIPAg8tDgoPACIPAg8tDgcPACIPAg8uDIBHAA8AIg8CDy4MgEcADwAiDwIPLgyARwAPACIPAg8uDIBHAA8AIg8CDy4MgEcADwAiDwIPLgyARwAPACIPAg8tDggPACIPAg8uDIBKAA8uCIBGAAwjAAAQew0iAAyAUQALJAIACwAAGl8jAAAQkC0LDgktCwkLACILAgstDgsJLQgBCycCDAQEAAgBDAEnAwsEAQAiCwIMLQoMDi4MgEcADgAiDgIOLgyARwAOACIOAg4uDIBHAA4rAgAMAAAAAAAAAAAXAAAAAAAAAAAtCAEOJwIPBAUACAEPAScDDgQBACIOAg8tCg8QLgyARwAQACIQAhAuDIBHABAAIhACEC4MgEcAEAAiEAIQLQ4MEC0IAQwAAAECAS0OCwwtCAELAAABAgEtDg4LLQgBDgAAAQIBLgyARgAOLQgBDwAAAQIBLgyARQAPLQsJEAAiEAIQLQ4QCS4IgEYABiMAABF/DSIABoBSABAkAgAQAAAaFSMAABGU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",
      "debug_symbols": "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",
      "brillig_names": [
        "commit_public_user"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "get_htlc_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "view",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "key",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "Train::HTLC_Public",
            "fields": [
              {
                "name": "src_receiver",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "amount",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "token",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "hashlock_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "hashlock_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "secret_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "secret_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "ownership_hash_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "ownership_hash_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "timelock",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "claimed",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "9174444391250494040": {
            "error_kind": "string",
            "string": "Function get_htlc_public can only be called statically"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_htlc_public"
      ]
    },
    {
      "name": "is_contract_initialized",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "is_contract_initialized"
      ]
    },
    {
      "name": "lock_private_solver",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "ownership_hash",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 90
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::include_by_timestamp::IncludeByTimestamp",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                          "fields": [
                            {
                              "name": "recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "content",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6418028854678020178": {
            "error_kind": "string",
            "string": "FundsNotSent"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc88898xzzzz3zHPPPPfMc88898xzzzz3zHPPPPfMc88898xzzzz3zHPPPPfMc88898xzzzz3zHPPPPfM8yj+qh6kSZbkSTWpTYo871SSKImTUoNTg1ODUyPyvAa1SZHnnUoSJXGSJGmSJXlSakhqaGpoamhqaGpoamhqaGpoamhqaGpYalhqWGpYalhqWGpYalhqWGpYanhqeGp4anhqeGp4anhqeGp4anhq1NSoqVFTo6ZGTY2aGjU1amrU1Kip0VKjpUZLjZYaLTVaarTUaKnRUuPO80b/cH/yeyWVpIdGkyBOkiRNsiRPqklt0p3ng0pSapTUKKlRUqOkRkmNkholNSg1KDUoNSg1KDUoNSg1KDUoNSg1ODU4NTg1ODU4NTg1ODU4NTg1ODUkNSQ1JDUkNSQ1JDUkNSQ1JDUkNTQ1NDU0NTQ1NDU0NTQ1NDU0NTQ1LDUsNSw1LDUsNSw1LDUsNSw1LDU8NTw1PDU8NTw1PDU8NTw1PDU8NWpq1NSoqVFTo6ZGTY2aGjU1amrU1Gip0VKjpUZLjZYaLTVaarTUaKnRpkYUqw0qSZTESZKkSZbkSTUpNTLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLP28xzumae0zXznK6Z53TNPKdr5jldM8/pmnlO18xzumae03WlRkmNkholNUpqlNQoqVFSo6RGSY2SGpQalBqUGpQalBqUGpQalBqUGpQanBqcGpwanBqcGpwanBqcGpwanBqSGpIakhqSGpIakhqSGpIakhqSGpoamhqaGpoamhqaGpoa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0ysOq7fN+mrTq02vNr3a9Ioj640z641D622z3775fnDTq02vNr3i6Hrb7F9terXp1aZXm15xgL1xgr1xhL1t9ts33w9uerXp1aZXHGRvm/2rTa82vdr0atMrjrM3zrM3DrS3zfpqs77a9GrTq02vONbeNuurTa82vdr0atMrDrc3Trc3jre3fffb++t+P9hft1f9dXvVX7dXnfPt/XX3r/rr9qq/bq/66/aqv26vOufbO+fbO+fb+6vhvd8P9tftVX/dXvXX7VXnfHt/Nbwdb8fb8d5edc63d863d86391fHe78f7K/OPA/meTDPA+/AO/AOvAPvYJ4H4x2MNxhv4A2ubzDPwTwH8xx4A2/gDbyJN5nnZLzJeJPxJt7k+ibznMxzMs8T78Q78U68E+9knifjnYx3Mt6Jd3F9F/O8mOfFPC+8C+/Cu/AuvIt5LsZbjLcYb+Etrm8xz8U8F/NceAvvxrvxbrybed6MdzPezXg33s31pVeNXjV6xfn23u7+VW/0qtGrRq8aveJ8e+d8e+d8e28N7/1+sDd61ehVo1ecb++t4aVXjV41etXoFefbO+fbO+fbe+t47/eDvdGrRq8aveJ8e28DL71q9KrRq0avON/eOd/eOd/e28AbXF961ehVo1ecb+8t8NKrRq8avWr0ivPtnfPtnfPtvSXe5PrSq0avGr3ifHtviZdeNXrV6FWjV5xv75xv75xv723inVxfetXoVaNXnG/vbeGlV41eNXrV6BXn2zvn2zvn23srvMX1pVeNXjV6xfn2zvn2zvn2zvn23ugV59t723g3XnrF+fbO+fbO+fb+Pd/eDz/jzR/+nm+vw8f7/r+y9M/59vcf0++f8+3xPP943/8zrf453/7h433//yP653z7h483n9ffl59ezfP6T6/m83iHB3y87z/I3z/n2z98vO8/yt8/59s/fLzrvOenVw8/vVrnNZ9efbjDx1tnHp5effh463ifXn14wQUf7/vvC+if8+0fbvDx7vOen17t8z6fXn34ePeZ56dXH35783Xe2+nVl/fl06t8nXk+vfry25vtvIfTqy8HnIfPezu9+vLxtvPeTq++fLzvv/a7P+fbv9zg4+3ns3F69eXjPZ/t53x7jvMeTq++vODjHef9nF59+PQqx3nN06svd/h4n8/86dWXj/f5PJ9efXnBxxvnfZ5effj0KvPM7enVl483z9hPr758vHle8/TqyxM+3nxev+DjfX5fnF59ucHHu85n4PTqy8e7zns7vfry8daZ29OrLxd8vHXm+fTqy8dbx3t6lfu85ulVPp/t06vv4wlPeMEF79/8nG9/XvM53/59vPP44PGAE548f/F4wXjbC273Z1vncbwNb0ueP3l88Tjetu/jHW9nvB1vHzwfb8fb8Xa8HW9nvAPvYLwD72C8I3gO8zyY58E8P736PI438AbjDbyBN/AG3mC8gTfwBt7kc5V4E2/iTeY5mefEm8xzMs+Jd+KdeCfeiXfinYx34p2Md+KdfK4W87zwLn4fLbwL78K7uL4L72KeF+MtvMXnqhhv8XkuvMU8F+MtvMV4C+/Gu/HSq7EZ7+ZzRa8GvRr0atCrQa/i9YKvN16dxwcccMKTn108XvC9vkGvgl4FvQp6FS14Dt6Gt+GlV0Gvgl5Fx0uvouPteDteehUdL70KehX0KkaD7+c56FXQq6BXMfDSqxh46VXQq6BXEXjpVQTXN5Ln4KVXQa+CXgW9CnoV9CroVdCrSMabXN/ES68iub6T8U6uL72KOXgcL72KiZdeBb2KyXgX46VXsfAuvPQq6FUs5plexcJLr6LwFt7i+hbzTK+i8BbjpVdRXF96FRvvxrvx0qugV0Gvgl7FXjyH8dKrpFfJ+irpVb7uPCe9SnqVrwkvnl88jpdeZcNLr7LhZX2VrK+S9VWyvkp6lfQq6VWyvkp6layvkvVVsr5KepX0KnvxHMY77vVNepX0KulVDrz0KllfJb1KepWD8dKrjMbjjDcYL71K1ldJr5JeZeANvImXXiW9ysRLr5JeJeurpFeZzDPrq6RXSa+SXiXrq6RXSa+S9VVOPlf0KllfJeurXHjpVdKrpFe5+FzRq6RXSa+SXiXrq2R9layvkvVV0qtkfZWsr7IYL+urLMbL+irpVdKrpFfJ/WBuvPQq6VXSq6RXk15N1leTXk3WV5NezVfy/Mnji8eLx+94J72arK8mvZr0an56FYcfbx5+vOvwggvelz+9erjBHR5wwAnj7Xg73o534B14B96Bd+AdeAfegXfgHXgDb+D99KoODzjghB/vPrxgvIE38SbeZLzJeJPxJuNNxpuMN/Em3ol34p14J96Jd+KdeCfeiXfiXXgX3oV3Mc+LeV7M86dXDzPPn149jLfwFt7CW4y3GG8x3mK8xXiL8RbejXfj3Xg33o134914N96Nd1/ver3gBnf4zvN6BZzwhO88r1fBeBvehrfhbQMOOOEJL7hgvPRq0atFrxa9WvRq0atFrxa9WvRq0atFrxa9WuN2Yw3meTDPg3ketxtrMM/0atGrRa8WvVrBeIPxBuMNxhuMNxgvvVr0atGrRa8WvVr0atGrRa8WvVr0atGrRa/Wp1dnrj69eph5nszzp1dnDj+9ehgvvVr0atGrRa8WvVr0ai3GuxjvYrwL78K78NKrRa8WvVr0atGrRa8WvVr0an16debn06uH9+XNPH96debt06uH8dKrRa8WvVr0atGrRa+KXhW9KnpVrwEHnPCEF1wwXnpV9KroVbX7uaoWcMITvr9/qxWMl14VvSp6VfSq6FXRq6JXRa+KXhW9KnpV9KpYXxXrq2J9VayvivVVsb6qcT9XNe7nquIFN/h+rurTq4fx0quiV0Wvil4VvSp6VfSq6FXRq6JXRa+KXhW9KnpV9KpYXxXrq6JXRa9q8rmafK7m/e9CTT5X9KroVdGroldFr4peFb0qelX0quhV0auiV0Wvil4VvSp6VfSqivEWv4/oVdGr+vTqzMOnVw/jZX1V9KroVdGroldFr4peFb3a9GrTq02vNr3a9GrTq02v9uuOd78Kvr+PdnvBt8+7dRgv66vN+mqzvtqsrzbrq02vNr3a9GrTq02vNr3a9GrTq02vdme8nfEOxjsazHjHgPHSq02vNr3arK8266vN+mqzvtqsrzbrq02vNr3a9GrTqx2MNxhvMt5kvMl4k/HSq02vNr3a9GrTq02vNr3a9GpzP7i5H9zcD27uBzfrqz35PE/GOxnvYryLz/NivPRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06t9ezVet1fjdXs1Xq/f/z0ar3s/OF73fnC87v3geL1+//dovO794Hjd9dV4vfA2vA3vXV+N1+3VeN1ejdft1XjdXo3X7dV4tbrvre3L/QU3uN/33AeMt+PteDvezng74x2MdzDewXgH8zyY58E8jwkzz6NgvIE38AbeYJ6D8QbjDcYb676HYJ6DeU7mOdt9b8k8J97Em3gTbzLPyTwn4514J9d38nmezPO9Hxyvez84XhPvxDvxTryLeV7M88K78C6u7+L6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6dWH8QbjfXr1vIfA+/Tqw3ifXn0Y79OrD+N9evVhvMl4n1497yHxJvM88U7meeKdzPPE+/Tqw3gn43169byHiXcxzwvvYp4X3sU8L7xPrz6MdzHep1fPeyi8xTwX3mKeC28xz4W3+DwX3mK8T6+e97DxbuZ5493M88a7meeNd/N53tf7nG//cvv9Hp7z7d/HB3y9z/n2L0+es+DiOffz/Jxv/zynNbjf9/D06sOPdx9OeMILLnhffnr14eN9/11k4znf/uUBB5zwhBdc8L789OrDeJ9enTMtz/n2Lwf8eNfh4z1nWp7z7V8ueF9+evXh4z1r4Od8e53zLc/59i8HnPCEF1zwvvz06pxDe863f/nt/fmkHR6Hz/s5vfpywhNecMH78unVlxvc4cdbhwNOeMILLnhfXi+4wR3Gu/AuvAvvwrvwLryFt/AW3sJbeAtv4S28hbfwbrwb78a78W68G+/Gu/FuvPu3N57z7V9ucIcHHHDCE15wwXgb3tOr/T7TGM/59p+qHB5wwAlPeMEF78unV19uMN6Ot+PteDvejrfj7XgH3oF34B14B96Bd+AdeAfegTfwBt7AG3gDb+ANvPF4z/WKgvflfLzjcIM7POCAk9eZMN6nV5/n78sT78Q78U68E+/EO/FOvJPxTsa78C68C+/Cu/A+vfrwhBfMeBfep1cfbnCHB4y38Bbewlt4i3nejHcz3s14N96nVx9mnjfzvJnnjXdf73O+/csN7vCAA054wtf7nG//8p3n53z7lxuMt+FteBvehrctuGDG2xlvx9s7POCAE8bb8Xa8He/AO5jnwXgH4x2Md+AdE2aeB/M8mOfAG3gDb+ANvME8B+MNxhuMl1615Pom85zMczLP9Kol3sSbeOlVo1eNXjV61ehVm3gn15deNXrV6FWbeCdeetXoVaNXjV41etXoVaNXbeFdXF961ehVo1et8BZeetXoVaNXjV41etXoVaNXbePdXF961ehVo1dt49146VWjV51edXrV6VWnV51e9df19teEF1zwnefe8Da89KrTq06vOr3q9KrTq06vesPbX3CDOzxgvB0vver0qtOrTq86ver0qtOrPvCOgJlnetXpVR94B1561elVp1edXnV61elVp1ed9VVnfdXpVadXnV511led9VWnV51edXrV6VWnV51edXrVJ97J9aVXnV51etUn3omXXnV61elVp1edXnV61elVX3gX15dedXrV6VUvvIWXXnV61elVp1edXnV61elVL7yb60uvOr3q9KpvvBsvver0qtOrTq8GvRr0atCr8bre8Qo44QkvuHgdvPRq0KtBrwa9GvRq0KtBr0bD2wq+8zzo1aBXo+PteOnVoFeDXg16NejVoFeDXo2Bd3SYeaZXg16NgXfgpVeDXg16NejVoFeDXg16NQJvcH3p1aBXg14N7gcH94ODXg16NejVoFeDXg16NejVSLyT60uvBr0a9GpwPzgmXno16NWgV4NeDXo16NWgV2PhXVxfejXo1aBXg/vBsfDSq0GvBr0a9GrQq0GvBr0ahbe4vvRq0KtBrwb3g2PjpVeDXg16NejVoFeDXgW9itf1xqvDAw444cnrLLhgvPQq6FXQq6BXQa+i4W0TXnDBd56D+8HoeOlV0KugV0Gvgl4FvQp6FR3veMHMM70KehXcD8bAS6+CXgW9CnoV9CroVdCrCLzB9aVXQa+CXgX3g0GvgvVVsL4KehXcD0biZf8q6FXQq6BXwfoqPr3Kw8f7/vPU8Zxv//LxjvP6T68+nPCEF1zwvvz06sMN7jDehXfhXXgX3oV34S28hbfwFt7CW3gLb+EtvIV34914N96Nd+PdeDfejffp1fvcTjzn2x9+zrd/ucEdHnDACU94wcf7/v+CxXO+/cNPr97n7uI53/7lznMGHDwn4clzFvx44zDep1cfxvv06sN4n159GO/Tqw/j7Yz36dXzHgbep1cfxvv06sN4n159GO/Tqw/jHYz36dXzHgJvMM+BN5jnwBvMc+B9evVhvMl4n1497yHxJvOceJN5TrzJPCfep1cPT7yT8T69et7DxDuZ54l3Ms8T72SeJ97F53nhXYz36dXzHhbexTwvvIt5XngX81x4i89z4S3G+/TqeQ+Ft5jnwlvMc+HdzPPGu/k8b7yb8T69et7D06sPP946XPD+zc/59i83uMMDPt732cJ4zrd/ecILLnhffnr14QZ3eMB4n15lHp7wgh/vPPx495ufXn24wR0e8PG+zz3Gc7795xvwwxNecMH78tOrDze4w8c7zzw/vfrw8a4z9qdX67yfp1drHS54X3569eEGd3jAASc8YbyBN/Am3sSbeBNv4k28iTfxJt7EO/FOvBPvxDvxTrwT78Q78U68C+/Cu/AuvAvvwrvwLrwL78JbeAtv4S28hffp1ftcTTzn23edz9XTqw8XvC8/vfpwgzs84IATxrvxbrz7ep/z7V9ucIcHHHDCE15wwXgb3ob36dX7vFA859u/HHDCE15wwfvy06sPNxhvx9vxdrwdb8fb8Xa8A+/AO/AOvAPvwDvwDrwD78AbeANv4A28gTfwBt7AG3gDb+JNvIk38SbexJt4E2/iTbwT78Q78U68E+/EO/FOvBPvxLvwLrwL78K78C68C+/Cu/AuvIW38Bbewlt4C2/hLbyFt/BuvBvvxrvxbrwb78a78W68+3qf8+1fbnCHBxxwwhNecMF4G96Gl14VvSp6VfSq6FXRq6JXRa+KXhW9KnpV9KroVdGroldFr4peFb0qelX0quhV0auiV0Wvil4VvSp6VfSq6FXRq6JXRa+KXhW9KnpV9KroVdGroldFr4peFb0qelX0quhV0auiV0Wvil4VvSp6VfSq6FXRq6JXRa+KXhW9KnpV9KroVdGroldFr4peFb0qelX0quhV0auiV0Wvil4VvSp6VfSq6FXRq6JXRa+KXhW9KnpV9KroVdGroldFrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06tNrza92vRq06t9e5Wv26t83V7l6/YqX7dX+bq9ytftVb5ur/J1e5Wv26t8vfA2vA1vw9vwNrwNb8Pb8Da8DW/H2/F2vB1vx9vxdrwdb8fb8Q68A++nV+vw492Hf7z99f6z4XnOt//m+eb3n+nOc779N9fheXhffvfqN7c39+N99+qHz2u+e/Wbj/f9XVue8+2/+Xh7/v3XH/73P//tz//8L3/50//6w3/7z59//R//8a9//Pc///VfP//67//n376/8i9/+/Nf/vLn//lP//a3v/7xT//9P/72p3/6y1//+P61P7w+//iHn/Xi/vWzIHz9468//Ly7f/hpRv36CcT8+fdxfv1nO/LnSfn+9fcP/Gw6jl8//6j3A+cnfj4mv37+kf/49/MS/3l+7udLpujfn8n2K+f7l/v7l89Dvf3q56Hx+6GfOert/VB8X6TXr1HfF/nZEo79/uX8f39i3teNX/08a92H1q/R3w/V/cH9q8f7of2dhz5+fjDzM+qfbcv1W9zfmh/PZ7z957vP3tcZ7e9p7Gv8eOPz4z+7vPP1+8d/JrA//3p+fL5HPs6Pt++Pt5/pajk+P97az7/137PXfj4Arf+e75bx89wzd63/V19g/B5A/Axyrt+TvX5lv2+5fvX1Oj8Qdw7XzzScx/L/f9HbvTrzZ2Ly+7K1ftXPpfr73//x7/8X",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "random",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "lock_public_solver",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "ownership_hash",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 90
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "10870837545714573535": {
            "error_kind": "string",
            "string": "HTLCAlreadyExists"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "15001264570739363109": {
            "error_kind": "string",
            "string": "Function lock_public_solver can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "lock_public_solver"
      ]
    },
    {
      "name": "process_message",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec",
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext",
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec",
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "vb3friW5cWf9Ln3ti00yIkjqVQYDQ/ZoBgIEyZDlD/hg+N1nM5jkijrlw8qz9+m5US91V8XKf/ztTJLJ/M/f/tef/uU//s8///mv//tv//7bH/7Hf/72L3//81/+8uf/889/+du//vEff/7bX5//9j9/e4z/SbX+9ofyT89/tt/+oOOf/bc/1Oc/2/M/9/HP9NsfUhqQnzD+Wa5/yvVPff5zVGi2oC5oC/oF/bEgLcgLygJZsCr3Vbmvyn1V7lfl/HgsSAvygrJAFugCW1AXtAWrclqV06qcVuW0KqdVOa3KaVVOq3JaldOqnFflvCrnVTmvynlVzqtyXpXzqpxX5bwql1W5rMplVS6rclmVy6pcVuWyKpdVuazKsirLqiyrsqzKsirLqiyjch1QF7QF/QJ9LEgL8oKyQBboglVZV2UdlduAfoE9FqQFeUFZ8Kyc04Bn5awDbEFd0Bb0C+pjwbNy7gPygrJAFjwrl8cAW1AXjMrjQI3m5zDa34Rn5TIUowFOKAtkgS6wBXVBW9AvGG1wwqrcV+W+KvdVua/KfVXuq3JflftVuTweC9KCvKAskAW6wBbUBW3BqPw8p2W0wQlpQV5QFsgCXWAL6oK2YFXOq3JelfOqnFflvCrnVTmvynlVzqtyXpXLqlxW5bIql1W5rMplVS6rclmVy6pcVmVZlWVVllVZVmVZlWVVllVZVmVZlWVV1lVZV2VdlXVV1lVZV2VdlXVV1lVZV2VblW1VtlXZVmVblW1VtlXZVuXRBuUxoF8w2uCEtCAvKAtkgS6wBXXBqlxX5bYqt6uyjMM7WqWMwytpwPjr/m/agn7BOJgT0oK8oCyQBbrAFqzKuirrqmyrsq3Ktirbqmyrsq3Ktirbqmyrsq3KdVWuq3JdleuqXFfluirXVbmuynVVrqtyW5XbqtxW5bYqt1W5rcptVW6rcluV26rcV+W+KvdVua/KfVXuq3Jflfuq3FflflXWEWhiA9KCvKAskAW64FlZHwPqgragXzACTdOAtOBZWWVAWSALdIEtqAvagn7BCLQJacGqnFflvCrnVXkEmuqAuqAt6BeMQJuQFozKdUBZIAuelW3s6Qi0CXVBW9AvGIE24VnZxvaMQJtQFsiCUXnYR6BNqBeMhqZtwPjr41yMZmX+b55/uI7jPJrVhLagXzCa1YS04FmnjsqjWU2QBbpgVB6u0awmjMp9QL9gNKsJaUFeUBY8K7dx1Y1mNcEW1AXPym0chNGsHEazamMzRrOakBeUBaPyUIxmNcEW1AVtQb9gNKs+pKNZTcgLyoJn5T42YzSrCbZgVB5XwmhWE/oEG21nwvjrOuD5h3sbMG7e8oDnH+7PzbDRUiakBXlBWSALdIEtqAvaglU5r8p5Vc6rcl4b5nfdj8cg21Q3tU19kd96P2RQ2pQ3lU2ySTe5YxwHvwOf1Db1RX4T/hgb6nfhk/Km4UhjW/xGfJJuGg4/xH4vPm7PzW/G09hfvxt38tvxSWlT3lQ2DUcelf2efJJtqpvapr7Ib8wnpU15U9m0HbYdth22HdXrjX2raVPeVDbJJl3kz7Hjt938QXaSVx5npu8t7XtL+9rS6s+c4zmg+kPnpLJJNukm21Q3tU19kT98TtqOtB1pO9J2pO1I25G2wx85sw3yv1sH+d/tg3STbaqb2qa+yK/2SWlT3lQ2bUfZjrIdZTvKdpTtkO2Q7ZDtkO2Q7ZDtkO2Q7ZDtkO3Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7bDtsO2w7bDtsO2w7bDtsO2w7bDtqNtRt6NuR92Ouh11O+p21O2o21G3o21H2462HW072na07Wjb0bajbUfbjr4dfTv6dvTt6NvRt6NvR9+Ovh19OdrjsSltypvKJtmkm2xT3dQ2bUfajrQdaTvSdqTtSNuRtiNtR9qOtB15O/J25O3I27HbedvtvO123nY7b7udt93O227nbbfzttt52+287Xbedjtvu5233c7bbudtt/O223nb7bztdt52O2+7nbfdzttu522387bbedvtvO123nY7b7udt93O227nbbfzttt52+287Xbedjtvu5233c7bbudtt/O223nb7bztdt52O2+7nbfdzttu522387bbedvtvO123nY7b7udt93O227nbbfzttt52+287Xbedjtvu5233c7bbudtt/O223nb7bztdt52O2+7nbfdzttu522387bbedvtvO123nY777ud993O+27nfbfzvtt53+2873bedzvvu5333c77bud9t/O+23nf7bzvdt53O++7nffdzvtu5323877bed/tvO923nc777ud993O+27nfbfzvtt53+2873bedzvvu5333c77bud9t/O+23nf7bzvdt53O++7nffdzvtu5323877bed/tvO92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",
      "brillig_names": [
        "process_message"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "772057049813214347": {
            "error_kind": "string",
            "string": "HTLCNotExists"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2570651705007895968": {
            "error_kind": "string",
            "string": "HashlockNotMatch"
          },
          "2722406262643068352": {
            "error_kind": "string",
            "string": "HashlockAlreadySet"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3559210201980528457": {
            "error_kind": "string",
            "string": "Function commit_public_user can only be called internally"
          },
          "3564161243949231814": {
            "error_kind": "string",
            "string": "Function refund_public can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6012086182631426650": {
            "error_kind": "string",
            "string": "NotAnOwner"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "9174444391250494040": {
            "error_kind": "string",
            "string": "Function get_htlc_public can only be called statically"
          },
          "9323748002447105156": {
            "error_kind": "string",
            "string": "NotPassedTimelock"
          },
          "10870837545714573535": {
            "error_kind": "string",
            "string": "HTLCAlreadyExists"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "15001264570739363109": {
            "error_kind": "string",
            "string": "Function lock_public_solver can only be called internally"
          },
          "16870384257694633552": {
            "error_kind": "string",
            "string": "Function add_lock_public_user can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17814817983036354427": {
            "error_kind": "string",
            "string": "Function redeem_public can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "redeem_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "ownership_key",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::include_by_timestamp::IncludeByTimestamp",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                          "fields": [
                            {
                              "name": "recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "content",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+xdB3wcxdVflZMs2bLPvYNlG3eb27uT7kQ1vXcwvZyumGLcDRiwfXLFxh33AjYdAgEChJYQUiEhpJAC6QVICHzpldRvBt+cnp7e7u3p3sg74Pn9nrS3M/Of/7yZeVN2drbM2ucu7GJZb1Ttuy4TUpH7Xy5kGLqn/sPrABGulrjXjbjXnbgXJO71Ju71FTIZ3RsgJIvuDSTuHUTgHUzcG0bcqyfuDSfSGEHcG0ncO4S4N4pIY4yQLujeWOLeOOLeeOLeBOLeROLeJOLeocS9EHHPJu6FiXsR4l6UuNdA3Gsk7sWIe3HiXhNx7zDi3uHEvSOIe0cS944i7h1N3JtM3DuGuHcsce844t7xxL0TiHsnEvdOIu6dTNw7hbh3KnHvNOLe6cS9M4h7ZxL3ziLunU3cO4e4dy5x7zzi3vnEvQuIe1OIexcS9y4i7l1M3LuEuHcpce8y4t7lxL0riHtXEveuIu4liHvNxL0kcS9F3EsT9zLEvam5e9CV5f5Pzv2PhBqj0XQsnLYjdiIUbmqON4SiDc2NcTtuN8QbUuF4JJKOR+OxpuamWKjJjkbSdqahKZIJ7XOnVbRihUpy4aROnqd3mGc0jO9Ibr2EVAKuUg//zV2Ptlqvx4Dr03NhVLwzxO8zhZwl5OyK1vvKVSAdhEpz9lhGrDMq+MrmHLY6FArp1N84RqwzGfV3riH6G8+IdRaj/s5j1B9lG84BtuFccH0euD4b2Ybzxe8LhEwRcmEn2IYJjFjnM5bNRYbU7YmMWBcw6u9iQ/Q3iRFrCqP+LtFsGy4CNuBicH0JuL4Q2YZLxe/LhFwu5IpOsA2HMmJdylg2VxpSt0OMWJcx6u8qQ/RnM2Jdzqi/hGbbcCWwAVeB6wS4vgLZhmbxOykkJSTdCbYhzIjVzFg2GUPqdoQRK8mov6mG6C/KiJVi1N/Vmm1DBtiAqeD6anCdRrbhGvH7WiHXCZnWCbahgRHrGsayud6Qut3IiHUto/6mG6K/GCPWdYz6m6HZNlwPbMB0cD0DXE9DtmGm+D1LyGwhczrBNsQZsWYyls1cQ+p2EyPWLEb9zTNEf4cxYs1m1N8Nmm3DXGAD5oHrG8D1HGQbbhS/bxIyX8jNnWAbDmfEupGxbG4xpG4fwYh1E6P+bjVEf0cyYs1n1N8CzbbhFmADbgXXC8D1zcg2LBS/FwnJCmnpBNtwFCPWQsayWWxI3T6aEWsRo/6WGKK/yYxYWUb9LdVsGxYDG7AEXC8F1y3INiwTv5cLWSHktk6wDccwYi1jLJuVhtTtYxmxljPqb5Uh+juOEWsFo/5u12wbVgIbsApc3w6ub0O2YbX4vUbIWiHrOsE2HM+ItZqxbNYbUrdPYMRaw6i/DYbo70RGrLWM+tuo2TasBzZgA7jeCK7XIdtwh/i9SchmIVs6wTacxIh1B2PZbDWkbp/MiLWJUX/bDNHfKYxYmxn1t12zbdgKbMA2cL0dXG9BtmGH+L1TyC4huzvBNpzKiLWDsWzuNKRun8aItZNRf3cZor/TGbF2Mepvj2bbcCewAXeB6z3gejeyDXvF77uF3CPk3k6wDWcwYu1lLJv7DKnbZzJi3c2ov/sN0d9ZjFj3MOrvAc224T5gA+4H1w+A63uRbXhQ/H5IyMNCPtEJtuFsRqwHGcvmEUPq9jmMWA8x6u9RQ/R3LiPWw4z6+6Rm2/AIsAGPgutPgutPINvwmPj9uJAnhHyqE2zDeYxYjzGWzZOG1O3zGbEeZ9TfU4bo7wJGrCcY9fe0ZtvwJLABT4Hrp8H1p5Bt+LT4/YyQZ4U81wm2YQoj1qcZy+Z5Q+r2hYxYzzDq7wVD9HcRI9azjPr7jGbb8DywAS+A68+A6+eQbfis+P2ikM8JeakTbMPFjFifZSybzxtSty9hxHqRUX9fMER/lzJifY5Rf1/UbBs+D2zAF8D1F8H1S8g2fEn8/rKQrwh5uRNsw2WMWF9iLJtXDKnblzNifZlRf181RH9XMGJ9hVF/X9NsG14BNuCr4Ppr4PplZBteFb+/LuQ1Id/oBNtwJSPWq4xl801D6vZVjFhfZ9TftwzRX4IR6zVG/X1bs234JrAB3wLX3wbX30C24XXx+ztCvivke51gG5oZsV5nLJvvG1K3k4xY32HU3xuG6C/FiPVdRv29qdk2fB/YgDfA9Zvg+nvINvxA/P6hkB8J+XEn2IY0I9YPGMvmJ4bU7Qwj1g8Z9fdTQ/Q3lRHrR4z6+5lm2/ATYAN+Cq5/Bq5/jGzDz8XvXwj5pZC3CNtQzlw2oyw+fb7Np08bnn8scYdp1sPbjPXqHU16eCenh0qkA+jKmPVSZumxMRYvzxSFzX749K/YCjbcrJPnrxl4Ju1QYyyasnXyfLfDPKMRfIcywL8ChvbXFfTB3u8iA/wb8fs9Ie8L+b9OGJyNYcT6DaMR+60hgwvOw9DfY9Tf7wzRH+dh6O8z6u/3mgdnvwX24Hfg+vfg+v+QbfiD+P1HIX8S8udOsA2cB63/gbFs/mJI3eY8DP2PjPr7qyH64zwM/U+M+vubZtvwF2AD/gqu/wau/4xsw9/F738I+UDIPzvBNnAetP53xrL5lyF1m/Mw9H8w6u/fhuiP8zD0Dxj19x/NtuFfwAb8G1z/B1z/E9mG/4rf/6vYd6OsUr9t4Dxo/b+MZVNeaUbd5jwM/X+M+qswRH+ch6FblXz6q6zUaxtk/VY2oAJcV4Lrssq2tiEgLqqEVAvp0gm2gfOg9QBj2dQYUrc5D0OvYtRfrSH64zwMvZpRf10124YaYANqwXVXcN0F2YZu4qJOSHchPTrBNnAetN6NsWyChtRtzsPQ6xj119MQ/XEeht6dUX+9NNuGILABPcF1L3DdA9mG3uKij5C+Qvp1gm3gPGi9N2PZ9DekbnMeht6HUX8DDNEf52HofRn1N1CzbegPbMAAcD0QXPdDtmGQuBgsZIiQoZ1gGzgPWh/EWDYHGVK3j2LEGsyov4MN0R/nYehDGPU3TLNtOAjYgIPB9TBwPRTZhnpxMVzICCEjO8E2TGbEqmcsm0MMqdvHMGINZ9TfKEP0dywj1ghG/Y3WbBsOATZgFLgeDa5HItswRlyMFTJOyPhOsA3HMWKNYSybCYbU7eMZscYy6m+iIfrjPAx9HKP+Jmm2DROADZgIrieB6/HINhwqLkJCbCHhTrANnAetH8pYNhFD6jbnYeghRv1FDdEf52HoNqP+GjTbhgiwAVFw3QCuw8g2NIqLmJC4kKZOsA2cB603MpbNYYbUbc7D0GOM+jvcEP1xHoYeZ9TfEZptw2HABhwOro8A103INhwpLo4ScrTk1gm2gfOg9SMZy+YYQ+o252HoRzHq71hD9Md5GPrRjPo7TrNtOAbYgGPB9XHgejKyDceLixOEnCjkpE6wDZwHrR/PWDYnG1K3z2bEOoFRf6cYoj/Ow9BPZNTfqZptw8nABpwCrk8F1ych23CauDhdyBlCzuwE28B50PppjGVzliF1m/Mw9NMZ9Xe2IfrjPAz9DEb9naPZNpwFbMDZ4PoccH0msg3niovzhJwv5IJOsA2cB62fy1g2Uwyp25yHoZ/HqL8LDdEf52Ho5zPq7yLNtmEKsAEXguuLwPUFyDZcLC4uEXKpkMs6wTZwHrR+MWPZXG5I3eY8DP0SRv1dYYj+OA9Dv5RRf1dqtg2XAxtwBbi+ElxfhmzDVeIiIaRZSLITbAPnQetXMZZNypC6zXkYeoJRf2lD9Md5GHozo/4ymm1DCtiANLjOgOsksg1TxcXVQq4Rcm0n2IYrGLGmMpbNdYbUbc7D0K9m1N80Q/R3FSPWNYz6u16zbbgO2IBp4Pp6cH0tsg3TxcUMITOFzOoE25BgxJrOWDazDanbzYxYMxj1N8cQ/SUZsWYy6m+uZtswG9iAOeB6LriehWzDPHFxg5AbhdzUCbYhxYg1j7Fs5htStzkPQ7+BUX83G6I/zsPQb2TU3y2abcN8YANuBte3gOubkG24VVwsELJQyKJOsA2cB63fylg2Wc1lkwVlsABcLwTXi1DZtIiLxUKWCFmaK5vKXNgKy9lNZslHNPzhPhlNaeCzm7kPBR9t8dsqbo5jDOA41gCO4wzgON4AjhMM4DjRAI6TDOB4qAEcQwZwtA3gGDaAY8QAjlEDODYYwLHRAI4xAzjGDeDYZADHwwzgeLgBHI8wgOORBnA8ygCORxvAcbIBHI8xgOOxBnA8zgCOxxvA8QQDOJ5oAMeTDOB4sgEcTzGA46kGcDzNAI6nG8DxDAM4nmkAx7MM4Hi2ARzPMYDjuQZwPM8AjucbwPECAzhOMYDjhQZwvMgAjhcbwPESAzheagDHywzgeLkBHK8wgOOVBnC8ygCOCQM4NhvAMWkAx5QBHNMGcMwYwHGqBo46eLZo2lOed+XMhN9h/FjqMr7M22pTsPwvcYdZ+zYLl1vtN3XrKMgy6+Nd4bh5vlNhBs8KS3MDxoRLbXTL+SpAWCfPFZ1UUUvleVvHeYbxDerNieXgDQm5q19drwD3b0NvTqwUF6uE3C5kNXhzohvIv5tOQqU5eyXz2yTKranUSHgN6CYmM1UOCVlh0a+rfFx7oJWG9EC9GfU5BPBcm6tn63L/1+f+b8j935j7f0fu/6bc/825/1ty/7fm/m/L/d+e+78j939n7v+u3P/duf935v7flfu/J/d/b+7/3bn/9+T+35v7f1/u//25/w/k/j+Y+/8QfDerLJfBLLq3gbi3kbh3B3FvE3FvM3FvC3Fva67SwXtScV3QvR1E3F3Evd3EvTuJe3cR9/YQ9/YS9+4mON9DcL6XCCcLqwzdu58I9wAR7kEi3EOg0SpXnfuv7odKc/a9xRoG29nrvuKwbDfP+ztusNrhPtBRLILhg6Ub0jzqQ4zvkj5syMjtEx3macfwHWrk9jAYoa0F1+vA9SfQyO0RcfGokE8KeaxS//vI6xmn4I8w1qHHNdUhbv1tYNTfo4z6e8IQ/W1k1N8nGfX3KeYZDLYNjwMb8AS4/hS4fgzZhifFxVNCnhby6U6wDXcwls2TjGXzjCF1exOj/p5i1N+zhuhvM6P+nmbU33OabcMzwAY8C66fA9efRrbheXHxgpDPCPlsJ9iGLYxl8zxj2bxoSN3eyqi/Fxj19zlD9LeNUX+fYdTfS5ptw4vABnwOXL8Erj+LbMPnxcUXhHxRyJc6wTZsZyybzzOWzZcNqds7GPX3BUb9fcUQ/e1k1N8XGfX3smbb8GVgA74Crl8G119CtuEVcfFVIV8T8mon2IZdjGXzCmPZfN2Qur2bUX9fZdTfa4bo705G/X2NUX/f0Gwbvg5swGvg+hvg+lVkG74pLr4l5NtCXu8E23AXY9l8k7FsvmNI3d7DqL9vMervu4boby+j/r7NqL/vabYN3wE24Lvg+nvg+nVkG74vLt4Q8qaQH3SCbbibsWy+z1g2PzSkbt/DqL83GPX3I811+4egDv8IXL8Jrn+A6vaPxcVPhPxUyM+Ius39HPLnbDr48NiuvCtnrkMrGcv9F5ryzF02v+w4zwi+QdXPn4N6KEVd/wLc/yWqn2+Ji7eFvCPkV5Wtu/sqQZm76SRUmmPdGKWT51uMtqUK8Px1riDezf3/Te7/e7n/71fuy8uYXPj/E79/K+R3Qn4v5A9C/ijkT0L+LOQvQv4q5G9C/i7kH0I+EPJPIf8S8m8h/5F1QMj/ZBoBgS+kXEiFkEohASFVQqqFdBFSI6RWSFch3YTUCekupIeQoJCeQnoJ6R2w2m70keSHWZ27XfRd5k5AuT4BjYQlODdu3wCf5dKV776BVgUz4YY6s7L9RlNl6xfQSLifhsrW3+eVTea7v+GV7T1NlW1AQCPhARoq20CfVzaZ74EaKpsOrtIC9w/wj3UHBcxsZO9ramSDAxoJD9bQyIb4vJHJfA8xpJFJYzBIQyMbGuDNt1OjKpXnQR3nGcU3qInvu2CC+xtw/T64lhzgxPdg8XuYkHohwwP6Fx0Ze2/7YMa2OSLAa/Bw2YwItJbBMHBdD66Ho7IZKX4fImSUkNGBtnic9VLaj6Ea2uUYPp3aMu91Vue89fdrTQvQFivPcFwfdihcBnSrFl3GivIcJ2S8kAlCJgqZJORQISEhtpCwkIiQqJAGIY1CYkLiQpqEHCbkcCFHCDlSyFFCjpb1RMgxQo4VcpyQ44WcIOREIScJOVnIKUJOFXKakNOFnCHkTCFnCTkbL7qMDbR/C2sccW88cW8CcW8icW8Sce9Q4l6IuGcT98LEvQhxL0rcayDuNRL3YsS9OHGvibh3GHHvcOLeEcS9I4l7RxH3jibuTSbuHUPcO5a4dxxx73ji3gnEvROJeycR904m7p1C3DuVuHcace904t4ZxL0ziXtnEffOBsZdubG5/5Nz/0OluTZGs9SOYyxDx57O7HPj+LBS4/mwmibwYdkT2bDS9iQ2rKR9KBtW3A6xYYVsmwsrHbLDXFjJkB3hwoqH7CgXlmjbDUxYaYHVyISVlI8pmbDiAivOhCVtYRMPVlpiHcaDlZRYh/NgxSXWETxYH/YdR7JgpT/EOooFK/kh1tEsWPEPsSazYO3ra4/hwErvwzqWAyu5D+s4Dqz4PqzjObByY5MTGLBSOawTGbCac1gnMWDlXpu3Ty4dK5wbf9mnlI5lK6xTS8aKZxTWaaVjNSus00vHUuNV+4ySsWJ5rDNLxmrIY51VMpadxzqbbzGnzaII3lHlh7mDwjqHL88ffpWce6FKLhCO0bBwdy5zWXPvmpO7f8Yylo0s53M16PE8A/TIWcfHatLj+Yx6lNzw4rwsJ7UIf37A23mAF4hwU4RcKOSigPPifKg0Z8tdbuM06DRVrfdhYan8ZJ4v0JDvdLWefqySudwvYOzHLmZs44z1xjalLH7LuLZ5SUBPG/ZTu6Bs7MXArl7i0cZeKsJdJuRyIVdotLFyF/F4DbYm43MbK/N8qYZ8TzWkXV/K2BavZLSxjPXGNqUsfsdoY68K6GnDfmoXlI29EtjVqzza2IQI1ywkKSSl0cbKtzQmaLA1V/vcxso8JzTk+xpD2nWCsS2mGW0sY72xTSmL3zPa2ExATxv2U7ugbGwa2NWMRxs7VYS7Wsg1Qq7VaGPlW3ATNdiaa31uY2Wep2rI93WGtOupjG3xOkYby1hvbFPK4g+MNnZaQE8b9lO7oGzsdcCuTvNoY68X4aYLmSFkpkYbK98ynqTB1kzzuY2Veb5eQ76vN6RdX8/YFmcx2ljGemObUhZ/ZLSxswN62rCf2gVlY2cBuzrbo42dI8LNFTJPyA0abaw8xeFQDbZmus9trMzzHA35nmFIu57D2BZvZLSxjPXGNqUs/sRoY28K6GnDfmoXlI29EdjVmzza2Pki3M1CbhFyq0YbK0/JCWmwNTN9bmNlnudryPcsQ9r1fMa2uIDRxjLWG9uUsvgzo41dGNDThv3ULigbuwDY1YUebewiES4rpEXIYo02Vp5CZmuwNbN9bmNlnhdpyPccQ9r1Isa2uITRxjLWG9uUsvgLo41dGtDThv3ULigbuwTY1aUebewyEW65kBVCbtNoY+Upj2ENtmauz22szPMyDfmeZ0i7XsbYFlcy2ljGemObUhZ/ZbSxqwJ62rCf2gVlY1cCu7rKo429XYRbLWSNkLUabaw8RTeiwdbc4HMbK/N8u4Z832hIu76dsS2uY7SxjPXGNqUs/sZoY9cH9LRhP7ULysauA3Z1vUcbu0GE2yjkDiGbNNpYeUp5VIOtucnnNlbmeYOGfM83pF1vYGyLmxltLGO9sU0pi78z2tgtAT1t2E/tgrKxm4Fd3eLRxm4V4bYJ2S5kh0YbK78C0aDB1tzscxsr87xVQ75vMaRdb2VsizsZbSxjvbFNKYt/MNrYXQE9bdhP7YKysTuBXd3l0cbuFuHuFHKXkD0abaz8yk6jBltzq89trMzzbg35XmBIu97N2Bb3MtpYxnpjm1IWHzDa2LsDetqwn9oFZWP3Art6t0cbe48Id6+Q+4Tcr9HGyq+YxTTYmoU+t7Eyz/doyPciQ9r1PYxt8QFGG8tYb2xTyuKfjDb2wYCeNuyndkHZ2AeAXX3Qo419SIR7WMgnhDyi0cbKr0TGNdiarM9trMzzQxry3WJIu36IsS0+ymhjGeuNbUpZ/IvRxn4yoKcN+6ldUDb2UWBXP+nRxj4mwj0u5Akhn9JoY+VXeJs02JrFPrexMs+Pacj3EkPa9WOMbfFJRhvLWG9sU8ri34w29qmAnjbsp3ZB2dgngV19yqONfVqE+7SQZ4Q8q9HGyq+cH6bB1iz1uY2VeX5aQ76XGdKun2Zsi88x2ljGemObUhb/YbSxzwf0tGE/tQvKxj4H7OrzHm3sCyLcZ4R8VsiLGm3sfytbv4MHcUvV6XKf21iZ5xc05HuFIe36Bca2+DlGG8tYb2xTyuK/jDb2pYCeNuyndkHZ2M8Bu/qSRxv7eRHuC0K+KORLGm3s/ypbvysKcUvV6W0+t7Eyz5/XkO+VhrTrzzO2xS8z2ljGemObUhb/Y7SxXwnoacN+aheUjf0ysKtf8WhjXxbhXhHyVSFf02hjrUDrd5ohbsnv9Pncxso8v6wh37cb0q5fZmyLrzLaWMZ6Y5tSFhZjWXw9oKcN+6ldUDb2VWBXv+7Rxr4mwn1DyDeFfEujjS0LtH73HuKWqtPVPrexMs+vacj3GkPa9WuMbfHbjDaWsd7YppRFGWNZvB7Q04b91C4oG/ttYFdf92hjvyPCfVfI94R8X6ONLRfYR2uwNWt9bmNlnr+jId/rDGnX32Fsi28w2ljGemObUhbljGXxZkBPG/ZTu6Bs7BvArr7p0cb+QIT7oZAfCfmxRhtbIctEg61Z73MbK/P8Aw353mBIu/4BY1v8CaONZaw3tillUcFYFj8N6GnDfmoXlI39CbCrP/VoY38mwv1cyC+E/FKjja0U2MdosDUbfW5jZZ5/piHfdxjSrn/G2BbfYrSxjPXGNqUsKhnL4u2Anjbsp3ZB2di3gF1926ONfUeE+5WQXwt5V6ONDQjsYzXYmk0+t7Eyz+9oyPdmQ9r1O4xt8TeMNpax3timlEWAsSzeC+hpw35qF5SN/Q2wq+95tLHvi3D/J+S3Qn6n0cZWCezjNNiaLT63sTLP72vI91ZD2vX7jG3x94w2lrHe2KaURRVjWfwhoKcN+6ldUDb298Cu/sGjjf2jCPcnIX8W8heNNrZaYB+vwdZs87mNlXn+o4Z8bzekXf+RsS3+ldHGMtYb25SyqGYsi78F9LRhP7ULysb+FdjVv3m0sX8X4f4h5AMh/9RoY7sI7BM02JodPrexMs9/15DvnaacC83YFv/FaGMZ641tSll0YSyLfwf0tGE/tQvKxv4L2NV/e7Sx/5HhhPxPiFWlz8bWCPwTNdiaXT63sTLP/9GQ792mvCPP2BbLqvh4MdYb25SyqGEsi/IqPW3YT+2CsrGyDipbWl7lzcZWSLsqJCCkSqONrRXle5IGW3Onz22szLPUMTfuXabsF2Jsi9WMNpax3timlEUto43tUqWnDfupXVA2thrY1S4ebWyNCFcrpKuQbhptbFdRvidrsLF7fG5jZZ5rNNjYvaaMnRjbYh2jjWWsN7YpZdGV0cZ2r9LThv3ULigbWwfsanePNraHCBcU0lNIL402tpso31M02Ni7fW5jZZ57aLCx9xjSrnswtsXejDaWsd7YppRFN0Yb26dKTxv2U7ugbGxvYFf7eLSxfUW4fkL6Cxmg0cbWifI9VYONvdfnNlbmua8GG3ufIe26L2NbHMhoYxnrjW1KWdQx2thBVXrasJ/aBWVjBwK7OsijjR0swg0RMlTIQRptbHdRvqdpsLH3+9zGyjwP1mBjHzCkXQ9mbIsHM9pYxnpjm1IW3Rlt7LAqPW3YT+2CsrEHA7s6zKONrRfhhgsZIWSkRhvbQ5Tv6Rps7IM+t7Eyz/UabOxDhrTresa2eAijjWWsN7YpZdGD0caOqtLThv3ULigbewiwq6M82tjRItwYIWOFjNNoY4OifM/QYGMf9rmNlXkercHGfsKQdj2asS2OZ7SxjPXGNqUsgow2dkKVnjbsp3ZB2djxwK5O8GhjJ4pwk4QcKiSk0cb2FOV7pgYb+4jPbazM80QNNvZRQ9r1RMa2aDPaWMZ6Y5tSFj0ZbWy4Sk8b9lO7oGysDexq2KONjYhwUSENQho12theonzP0mBjP+lzGyvzHNFgYx8zpF1HGNtijNHGMtYb25Sy6MVoY+NVetqwn9oFZWNjwK7GPdrYJhHuMCGHCzlCo43tLcr3bA029nGf21iZ5yYNNvYJQ9p1E2NbPJLRxjLWG9uUsujNaGOPqtLThv3ULigbeySwq0d5tLFHS10JOUbIscDGKlfOXM49LD59Hl2lp25XMOf5rUq+PL/LiHUco/5kvelmtfYl0HH315y8Id/jqzQSPr6KH/cERkOnK98nVLUqmAn3w8om3/0vt/RXNth4QyU6nTzfrdTTKE4E9Zb/NBfGUZPkVpHjqEjLilJldY5V4iwAWLFPyjWgk2WedBTAiRos04nMXbOufJdrzHfJr9Zo1mGoNGfLinmKhunjqczduzIKEjebw+XWxcmadHGaJl2c5qILjnp7qgZdPLl/l1OSBfjZMt+nacj3U9X+tgOy4ztFgy1lLG+bU4dyUCHgyNGnVaQOCtUpiMldbqdqmkad7jZiDJXm7FM0GURIukjOdqF0JOfTNRiGp32ytlfMQKbk/W1V/jQwT1frqZdngI66o+VTSOec5XMmwLIjEdE2UjE7k8pEGmJN4Wa7MdLYmIlmYo3xaCrTEE2kYmk7moiEm9KxUMaOp9Oxhkgy1phpSiUbM9Bo26lIJJpqak7aDeHGRHMonookQploLBIOJVKRWCoViTc2JiKRVGM8E2+Kh8OJTCQeaojFmkKN4UhTWFf5nJkrn86cab6laaZ5Vm6mebYpBlwXv7M0GOtzNHVc52ic1UhdnK1BF+dq0sW5mmc152jQxTMGzGrO1ZDvZ30+q3lL06yGsbztZw/MarCzz9E0qznPxFnNeZpnNedpMAzPfQxnNedX+dPAPKdp1Hy+YbOaCxhnNc8yzmp0lc8FYFbj1Cn4eTlKJ09dHcwUEzuYKZo7mCkaOpjnNXUwAWaenAbsQkYszmUzzs7qeU3G8EIPnVWpOr2oiq9TaLNs5qPOSlf5XPQRWoK7OLcEdwm12SNUmrOdNj1w7uIp+dsjjCNhHQWvdFhhiA5LxbrU5+UhG8ylGgYJl2kaMF2mcbn2Ek26uFyTLi7XuFwr9XCZBl181ufLtTLfl2vI94sGLNdeqmG5lrG87RcPLNdiZ3PbWeWu0DmbvlSTQbxC42xacr5Cg2H4nCHLtZcyDoqurPKngfmcphnWlZ2wXMtZPlcxLte+yDgD1lU+V+2HGbCu1x0SuRlwsykGXBe/hAZjndTUcSU1zmqkLpo16CKlSRcpzbOapAZdfN6AWU1KQ76/YMDWeh2zGsbytr9wYFaDnZ3UNKtJmzirSWue1aQ1GIYvfgxnNZkqfxqYL2oaNWcMm9VMZZzVfIFxVqOrfKbuh00ol1XpafemdDBXm9jBXK25g7laQwfzJUM2oXAasGsYsTiXzTg7qy9pMobXdMImlGsZN6G8WO3PzkpX+VxLlA/3HgHGTSf2e4znSF3HaNc78xyp6zR1otOqNBKeVsWPez2jYdaV7+urWhXMhNup50i9Z8g5Upw722CjmF6l8Ryp6xmnrtCqK9Ifha2FM3INaGaVhnOkZAFM12CZpmt+UMOV73KN+S6V4yyfP+ySFXOWhinWbE3TzdkaH3bN1KSLOZp0MUfjwy6ph9kadPGyzx92yXzP0ZDvVwzYwjdLgy1lLG/7lQMPu7CzZ2uaRs3VuRY5S5NBnKtxLVJynqvBMHzVkIddsxgHRfOq/GlgvqppfWpeJzzs4iyfGxgfdr3CuH6oq3xu2A9b+N7TNNO8MTfTvMkUA66L340ajPV8TR3XfI2zGqmLmzTo4mZNurhZ86xmvgZdvGrArOZmDfn+us9nNe9pmtUwlrf99QOzGuzs+ZpmNbeYOKu5RfOs5hYNhuG1j+Gs5tYqfxqY1zSNmm81bFazgHFW83XGWY2u8lmwH7bwza7S0+5N6WAWmtjBLNTcwSzU0MF8w5AtfJwGbBEjFueyGWdn9Q1NxnBRJ2zhyzJu4Xul2p+dla7yyX6EluBacktwi6nNHqHSnO206YFzF0+pWIwbR7ScW6R0yL1HVJcOS8Va4vPykA1miYZBwlJNA6alGpdrF2vSxTJNulimcblW6mGpBl182+fLtTLfyzTk+3UDlmuXaFiuZSxv+/UDy7XY2dx2VrnlOmfTSzQZxOUaZ9OS83INhuE7hizXLmEcFK2o8qeB+Y6mGdaKTliu5Syf2xiXa19nnAHrKp/b9sMMWNfrDitzM+BVphhwXfxWajDWt2vquG7XOKuRulilQRerNeliteZZze0adPE9A2Y1qzXk+/sGbK3XMathLG/7+wdmNdjZt2ua1awxcVazRvOsZo0Gw/DGx3BWs7bKnwbmDU2j5rWGzWrWMc5qvs84q9FVPuv2wyaUpVV62r0pHcx6EzuY9Zo7mPUaOpg3DdmEwmnANjBicS6bcXZWb2oyhhs6YRPKRsZNKK9X+7Oz0lU+GzWugAwUjXpIgN8G3aF5FYzD9txB7LUIleY4+yH7Dkabtsnn5SHPFNykoS/czLzHhHt/k1yF4eT4bg7P4q3XWlagfpPjyl3mWxjremeePbdF08B7a5VGwlur+HG3MRo+Xfne9jFvZNs1zWa5DSxnXdrh887kx6KsOTnKMt7RSfW81LzfV7mvTXI/zuCsPzsN7Zju13T+464qjYR3aeiYdvu8Y5L53m1IxyQb7E4NHdOdPt9/IcvnTg2Gaidj3bzL57PFBwww9nsMNfYPajL2e6s0Et6rwdjf7XNjL/N9tyHGXjbYPRqM/T0+N/ayfO7RYKj2MNbNe32uw7WV5sy21xnEdb1BXDcYxHWjQVzvMIjrJoO4bjaI6xaDuG41iOs2g7huN4jrDoO47jSI6y6DuO42iOudBnG9yyCuewziutcgrncbxPUeg7jea1K/JXjepWG95j6frzXI8rlPQ763+Tzfcj3pXg35vt+A8r7/Y1jeD2myRfJBRXeLfp+Cew20L2N5PdTxhx7ttvkTWWfDhnp9IFd+D1blKojaL/xArkLDew+CCqlcsS8kFSKrq0CKxArhtzEfYFwsf7CKt6LoeNDygAaD9pDPnwj3zdV77v3cnHWasx4+zLjNC9oJiMu9Pe2hXN1kq+tV+/hyl3kJtse1nErF+oSmd9wgro5teQ9oeAB6H2MZPWLAbhcdOnyAUYePMutQR145bY/cfCHzzP2eHGeZcOb3E4x27JPM26iV4+6vOPvrx5jzzD1ulGXymIZx4+Oa+iyFS0042W2HXBTi2xVny/5G7tTlPuf5vkp/1v3H+eZMbdq7VVo5u06un8hNrj+FJ9dPEJPrT7kMoEKluQ+3dD+ioWG+5fPjqe7TNJGd0oU338pxDwRMaMylYl2oqSxKPKii3QLSE4x5/hTjQICxDduM7cIuoVzbGXwvHTxH++CeUFIdfKg0Z3MOQjgnB6UM8jLIWYRjqkttOvgncx38U7iDf5Lo4J8iVs+5jcyTjEbmqSo9AwXOznd/dh5UpeMewMjZ1BMaBjBPV+npNLmNKmd9/rTPZ8+yTD6tYYXuaUYdPuPzR9Iyr89oaC/PMugwnbMTnfke3rPMKyfKPVelkfBzVfy4zzM2Al35fr6qVcFMuFq4Ppbjyt3IXvD5IxSVb24D/Rhj3fyMzx+h3Mf8CEWtbH1clkE/yzyIYZ8Fa3hE9lCVnuV4rjy/6PM2J2fWjLbVljbmsxrs/+cY9WjqHsJ7DdxD+FJu3PJ5vAryErEK8nnD9hDey7iH8CVGo/P5Kt6Kwr6HUPB7UYOReM/nj5zkYO5zGvL9vk8++FDAsba9LzB2Woz1xn7f53VQ2pkvaKiDX9S0D+OLGvcOSvv9kob9nSV01O2wOPuFLzFiwTL6kmH99pc/JrZDOe6JHGed/IrPV95lXfmKBnv5siZ7+bLLvjWn+hAqzdmcduVl5rErdlzYUK+v5CY5X8WTnFeISc5XO8FY6iqQUic5rzDy+ipjRSmmsXB2wqHSnG1iY/larrG8ihvL14jG8qqHxuLXAim1sXyNsbG86vMVAdnDvqKhl/26IXsZOMv6NZ+PqGSZvKZh2f7rjDr8hs/3Msi8fkNDe/mmoXsZvqlpL8O3qjQS/paGvQzf9vleBpnvb1e1KpgJV1un9G0Njex1n+9lUPnmNtBfYayb3/H5c1U5qPwO88DydQ118bs+16M855RziUie6faSBj1+j/n5dGd1nN/T1HF+v0oj4e9r6Djf8HnHKfP9hqaOk7vRbmFutHs1Ndo3DW20b2pqtD+o0kj4Bxoa7Q993mhlvn9oSKNdy9xot2tqtD9irvy9rNYlRfn7NLH2+N/ctUyLuv5l5b5rFe/Hwu8nQn4q5GdV++5L6WK1Plym3GSefITLrPZr19x1mVPvJnHUwfPHOnSpY0Skw3jJhlFjtb7faFn8xkwanp2MuzCkYVxfya8Li3ClYkdDoXi6IZ6yDKvAOnguqzSDZwUfVpuHbT/Ptd9fVBlkIOADQJmBYVZbx20sfs44ivylzx++qDJjP+3F5w9MZLm8pSHfb2vaxvM2qPfc9X0980h/p6aR/jvM0/Naq3Om57/QMD0vAzx/BXTNTv4tZvJu06tfgSnVisrW69vQ9OrXIty7Qn4j5L2q1vvcDeMXOSMxmakCS6xfGzL9X8dsFHZoMgrvd9KOjlBJLtzMWY/+z+d5bkpkoplYOsqZ59/6fEAh8/q+hvr9O8329/+Azf0tuP4duD4o0Nb+/l74/UHIH4X8CSxvOW2ZZNZ1mKNPym1KSRF0S8XO75CDuvhzzu7/BW9z/HNV+22OfyFmOcwvpYQZGmdYbU38M2ND/wtz4eqY2fxZw24ITmP5V58/xZd5/VUVL97vq/i2Ye7bspZq5CyTv1XxDSaoeh0qzdlO9ZpzJaBUrL/7fDVF1UNum/MP5pmv5gOsP+xbGG3Qh3h/Z2/fmfRfq/iwGOqmGjhwHjqNsdsMSj7IDUr+iQclHxCDkn+CQYmOEd1fNTScf/v77et8xebO9380vTlaxcRTdwMsdUD7AWOn9U/GTouxPtsMdaSNwdIx0P7A5wPtfxmwKvEHHXaVId9qlUhXvj/w+WD2PwYMZnXUnf9qWr0M8OY/wjiAjfydsd78r0rP+MhPYw4vkxQO2/0/5vb8v6pWviXqQvWtYYtwTNhtJgNW9b5/ZfI/HPhLDzwZkIGGGVYwTDzzg0SLsfGUVfNWGB2DMZlfPw/Gyn1+1NZbuUcm3Dp8n1GHFQbokKqHfhrYVTJO0nTWQ24bEWCuO9ztRA7o/sY46JaDun9o0GOVz/Uo++d/M+pR9s//1aDHap/rUfZXjPbWlnYnUM2vxy4G9Al/Knl8F0/hA3c4+4Sajuswim9Q2zikzVDbNarBdRdwXVPddhtHrfjdVUg3IXXVrds4ulqd8pZSpMwlnVLTgItLSkeM3G0d2864Of5KA0cdPGur9enS1/thdfF72+er5t0ZCxwuSnQHixLK+Xmi0IN5osCdV/m2FGN911Y34VtdpeY5yLyKKfNaabV33O3+nY+xsdfB821D9Mn5piDmaPTLJNJR1/hd/Z6iQvYS0ltIn+qP5rv6jFjaRqs6OOrg2bMzR6ul9mZvMPbe1Hv6upSsqzezmHh2xjv1PQ3pKT/u79T3zT037VdtSEOGU6a+1c6bOjk4S/wKDbhcuujL+Ay3f7WeMurv8qw9VJr7cETGOB235ZQ2qGENeoDP16Alno7zBAYasPb+joZ8D/J5vis0lfdgn+dbHvSjI99DfJ7vX2jK91Cf51stAXLn+yCf5/vnmsr7YAPsea2G/nuYAfl+W0N51zMvJ3fWmTX9mB/RKI7qerhJkyW3Zcbh1d7OrBkhwo0UcoiQUdVt8bjz3k9DA+7Wxd8NWOZ7RDX/tzv7MU4QRzBOtLjLQzmuZ4jqFXrOc9RHs+lv3yv03HluaAg1h+J2ijPPYxjy7PamFYe9ed/nm5rHMndmuD8YDfqAMeB6bLXzGTrjhN94IROETKwu/gydUr/GxNFH5qAyBN1Ssck3VCblVloPxW+oTCLeUDm0uvAZOpxKLPVtkkmMHc2h1byFq6OznqR5ZbhULM7yCPl8o4/U2/BqXrxx1dzfsQ03cw7shzOWyThG3dmaZ8ocZTtJw0Cbs2w5227YgPIYp+HNPM46HTHk1WDYr4eqefHCGt5aC/mrnnf6+UXR3ICwAQ8Io8SAsEHDo25cYbgbd48u/jQ+uGJz5zuoaXWjipmnrgZY6mQiysirgXN7AF+52gx1xPX8olBp7sMBTdTnkxzOetLIPMnRMVAar2GgNJ5RhzEDVvuiPh/8c9bpuAGDf7/X6SZN+1iZz3uyORdpwoz6O4wRC/a/fhqjdcZ5T7J/OozZNhxW3cq3RF10+nlPh+e4H4EnT4cTk6cjqvWd96SrYJh45gfVhzNyPKKat8LoGLwe7vPBK2d5HGnA4HWChoEX4zkG9gTG8jjKgIHX4T4fCHO2j6MNKI8JGgbCnHV6MrMOufMqB8A28yA4omFx8Bif61GOZ2KMepTjmSYNejzW53qUfTJjP2B/aMM06PE4A2zjxNL7qnbnUHH2VRMZ7ezxmrd7HQO2dR0Lro8D18dXt93udYL4faKQk4ScXH3grK0inBFnbQ2v5ueog+cJ1fp06et9/Lr49a/29wvO/RkN6ymMnTFcXDpFw5N5XEbsL2oa8D7EAA0TVM76dCpjfRrMvBotB7MHzu1q5XmCIR1cf0N4duq5XX7riJUrZ+bJWUBXW3oqEneeyxjzfI0heS5nzPO1huSZ0WDY13VSnkOlOXsao/5+XmFGx3C9ZQbP6YbwnGEIz5mMdV1icNufl8QY4IuMT2+/IrC+W8Wvx1mGlPdsQ3jOMYTnXEN4zjOE5w2G8LzREJ43GcJzviE8bzaE5y2G8LzVEJ4LDOG50BCeiwzhmTWEZ4shPBcbwnOJITyXGsJzmSE8lxvCc4UhPG8zhOdKQ3iuMoTn7YbwXG0IzzWG8FxrCM91hvBcbwjPDZp4+vm55cZOynOoNGffwai/tw15nrXJMoPnZkN4bjGE51ZDeG4zhOd2Q3juMITnTkN47jKE525DeN5pCM+7DOG5xxCeew3hebchPO8xhOe9hvC8zxCe9xvC8wFDeD5oCM+HDOH5sCE8P2EIz0cM4fmoITw/aQjPxwzh+bghPJ8whOenDOH5pCE8nzKE59OG8Py0ITyfMYTns4bwfM4Qns8bwvMFQ3h+xhCenzWE54uG8PycITxfMoTn5w3h+QVDeH7REJ5fMoTnlw3h+RVDeL5sCM9XDOH5VUN4fs0Qnq8awvPrhvB8zRCe3zCE5zcN4fktQ3h+2xCerxvC8zuG8PyuITy/ZwjP7xvC8w1DeL5pCM8fGMLzh4bw/JEhPH9sCM+fGMLzp4bw/JkhPH9uCM9fGMLzl4bwfMsQnm8bwvMdQ3j+yhCevzaE57uG8PyNITzfM4Tn+4bw/D9DeP7WEJ6/M4Tn7w3h+QdDeP7REJ5/MoTnnw3h+RdDeP7VEJ5/M4Tn3w3h+Q9DeH5gCM9/GsLzX4bw/LchPP9jCM//GsLzf4bwlIAm8CwzhGe5ITwrDOFZaQjPgCE8qwzhWW0Izy6G8KwxhGetITy7GsKzmyE86wzh2d0Qnj0M4Rk0hGdPQ3j2MoRnb0N49jGEZ19DePYzhGd/Q3gOMITnQEN4DjKE52BDeA4xhOdQQ3geZAjPgw3hOcwQnvWG8BxuCM8RhvAcaQjPQwzhOcoQnqMN4TnGEJ5jDeE5zhCe4w3hOcEQnhMN4TnJEJ6HGsIzZAhP2xCeYUN4RgzhGTWEZ4MhPBsN4RkzhGfcEJ5NhvA8zBCehxvC8whDeB5pCM+jDOF5tCE8JxvC8xhDeB5rCM/jDOF5vCE8TzCE54mG8DzJEJ4nG8LzFEN4nmoIz9MM4Xm6ITzPMITnmYbwPMsQnmcbwvMcZp7lzPxkft+oasUr9fvsEmtgdXuepeKWMeb5XJ+XidThO8xlMqian+d5ZXwcYX5DJTqqHXeUXyKTidmJWFTq8K0qfh2ez1AXo6FQPN0QT3G0Y5VfHfW6QoOtGazB1lQw5vkCA2xNz2reMhmiwdZMYbQ1ML+hEh2nrYE6HCo4VjDr8EJGHfZjrDPduvi7jSyr5LdbB2loIxcxlq/Ms5/LROqwL7PdOlhDmVzMWCZ9me2WctxznksMmZtdagjPywzhebkhPK8whOeVhvC8yhCeCUN4NhvCM2kIz5QhPNOG8MwYwnOqITyvNoTnNYbwvNYQntcZwnOaITyvN4TndEN4zjCE50xDeM4yhOdsQ3jOMYTnXEN4zjOE5w2G8LzREJ43GcJzviaeft6rcPPHMM+3GJJnzufEt3ZSnkOlOXsB4/OMlkoz8ryQc59LhRl1m3GPlL3IkPZ8HmOes4bkmXF/it2iea8LxzPeYXzPUD98Bn2ChmfGixntzQkG7HWp17DXZQmjDvsz7jMY3EWPXeAeay81ZE6wzBCeyw3hucIQnrcZwnOlITxXGcLzdkN4rjaE5xpDeK41hOc6Q3iuN4TnBkN4bjSE5x2G8NxkCM/NhvDcYgjPrYbw3GYIz+2G8NxhCM+dhvDcZQjP3YbwvNMQnncZwnOPITz3GsLzbkN43mMIz3sN4XmfITzvN4TnA4bwfNAQng8ZwvNhQ3h+whCejxjC81FDeH7SEJ6PGcLzcUN4PmEIz08ZwvNJQ3g+ZQjPpw3h+WlDeD5jCM9nDeH5nCE8nzeE5wuG8PyMITw/awjPFw3h+TlDeL5kCM/PG8LzC4bw/KIhPL9kCM8vG8LzK4bwfNkQnq8YwvOrhvD8miE8XzWE59cN4fmaITy/YQjPbxrC81uG8Py2ITxfN4Tndwzh+V1DeH7PEJ7fN4TnG4bwfNMQnj8whOcPDeH5I0N4/tgQnj8xhOdPDeH5M0N4/twQnr8whOcvDeH5liE83zaE5zuG8PyVITx/bQjPdw3h+RtDeL5nCM/3DeH5f4bw/K0hPH9nCM/fG8LzD4bw/KMhPP9kCM8/G8LzL4bw/KshPP9mCM+/G8LzH4bw/MAQnv80hOe/DOH5b0N4/scQnv81hOf/DOFplZvBs8wQnuWG8KwwhGelITwDhvCsMoRntSE8uxjCs8YQnrWG8OxqCM9uhvCsM4Rnd0N49jCEZ9AQnj0N4dnLEJ69DeHZxxCefQ3h2c8Qnv0N4TnAEJ4DDeE5yBCegw3hOcQQnkMN4XmQITwPNoTnMEN41hvCc7ghPEcYwnOkITwPMYTnKEN4jjaE5xhDeI41hOc4Q3iON4TnBEN4TjSE5yRDeB5qCM+QITxtQ3iGDeEZMYRn1BCeDYbwbDSEZ8wQnnFDeDYZwvMwQ3gebgjPIwzheaQhPI8yhOfRhvCcbAjPYwzheawhPI8zhOfxhvA8wRCeJxrC8yRDeJ5sCM9TDOF5qiE8TzOE5+mG8DzDEJ5nGsLzLEN4nm0Iz3MM4XmuITzPM4Tn+YbwvMAQnlMM4XmhITwvMoTnxYbwvMQQnpcawvMyQ3hebgjPKwzheaUhPK8yhGfCEJ7NhvBMGsIzZQjPtCE8M4bwnGoIz6sN4XmNITyvNYTndYbwnGYIz+sN4TndEJ4zDOE50xCeswzhOdsQnnMM4TnXEJ7zDOF5gyE8bzSE502G8JxvCM+bDeF5iyE8bzWE5wJDeC40hOciQ3hmDeHZYgjPxYbwXGIIz6WG8FxmCM/lhvBcYQjP2wzhudIQnqsM4Xm7ITxXG8JzjSE81xrCc50hPNcbwnODITw3GsLzDkN4bjKE52ZDeG4xhOdWQ3huM4TndkN47jCE505DeO4yhOduQ3jeaQjPuwzhuccQnnsN4Xm3ITzvMYTnvYbwvM8QnvcbwvMBQ3g+aAjPhwzh+bAhPD9hCM9HDOH5qCE8P2kIz8cM4fm4ITyfMITnpwzh+aQhPJ8yhOfThvD8tCE8nzGE57OG8HzOEJ7PG8LzBUN4fsYQnp81hOeLhvD8nCE8XzKE5+cN4fkFQ3h+0RCeXzKE55cN4fkVQ3i+bAjPVwzh+VVDeH7NEJ6vGsLz64bwfM0Qnt8whOc3DeH5LUN4ftsQnq8bwvM7hvD8riE8v2cIz+8bwvMNQ3i+aQjPHxjC84eG8PyRITx/bAjPnxjC86eG8PyZITx/bgjPXxjC85eG8HzLEJ5vG8LzHUN4/soQnr82hOe7hvD8jSE83zOE5/uG8Pw/Q3j+1hCevzOE5+8N4fkHQ3j+0RCefzKE558N4fkXQ3j+1RCefzOE598N4fkPQ3h+YAjPfxrC81+G8Py3ITz/YwjP/xrC83+G8LQqzOBZZgjPckN4VhjCs9IQngFDeFYZwrPaEJ5dDOFZYwjPWkN4djWEZzdDeNYZwrO7ITx7GMIzaAjPnobw7GUIz96G8OxjCM++hvDsZwjP/obwHGAIz4GG8BxkCM/BhvAcYgjPoYbwPMgQngcbwnOYITzrDeE53BCeIwzhOdIQnocYwnOUJp7liGck1BiNpmPhtB2xE6FwU3O8IRRtaG6M23G7Id6QCscjkXQ8Go81NTfFQk12NJK2Mw1NkUwOexRjnkcz57mcuUzeqLKsU6r5dCfxTq3m5zmmgo8jzG+oRKezHlYy6m+sIW0vwJjncYbkuYoxz+MNyXM1Y54nGJLnLox5nmhInmsY8zzJkDzXMub5UEPy3JUxzyFD8tyNMc+2IXmuY8xz2JA8d2fMc8SQPPdgzHPUkDwHGfPcYEieezLmudGQPPdizHPMkDz3Zsxz3JA892HMc5Mhee7LmOfDDMlzP8Y8H25Invsz5vkIQ/I8gDHPRxqS54GMeT7KkDwPYszz0YbkeTBjnicbkuchjHk+xpA8D2XM87GG5PkgxjwfZ0ieD2bM8/GG5HkYY55PMCTP9Yx5PtGQPA9nzPNJhuR5BGOeTzYkzyMZ83yKIXk+hDHPpzLmWUDJ14Wtt3IZvlrINUKuFXKdkGlCrhcyXcgMITOFzBIyW8gcIXOFzBNyg5AbhdwkZL6Qm4XcIuRWIQuELBSySEhWSIuQxUKWCFkqZJmQ5UJWCLlNyEohq4TcLmS1kDVC1gpZJ2S9kA1CNgq5Q8gmIZuFbBGyVcg2IduF7BCyU8guIbuF3CnkLiF7hOwVcreQe4TcK+Q+IfcLeUDIg0IeEvKwkE8IeUTIo0I+KeQxIY8LeULIp4Q8KeQpIU8L+bSQZ4Q8K+Q5Ic8LeUHIZ4R8VsiLQj4n5CUhnxfyBSFfFPIlIV8W8hUhLwt5RchXhXxNyKtCvi7kNSHfEPJNId8S8m0hrwv5jpDvCvmekO8LeUPIm0J+IOSHQn4k5MdCfiLkp0J+JuTnQn4h5JdC3hLytpB3hPxKyK+FvCvkN0LeE/K+kP8T8lshvxPyeyF/EPJHIX8S8mchfxHyVyF/E/J3If8Q8oGQfwr5l5B/C/mPkP8K+Z8QufmrTEi5kAohlUICQqqEVAvpIqRGSK2QrkK6CakT0l1IDyFBIT2F9BLSW0gfIX2F9BPSX8gAIQOFDBIyWMgQIUOFHCTkYCHDhNQLGS5khJCRQg4RMkrIaCFjhIwVMk7IeCEThEwUMknIoUJCQmwhYSERIVEhDUIahcSExIU0CTlMyOFCjhBypJCjhBwtZLKQY4QcK+Q4IccLOUHIiUJOEnKykFOEnCrkNCGnCzlDyJlCzhJytpBzhJwr5Dwh5wu5QMgUIRcKuUjIxUIuEXKpkMuEXC7kCiFXCrlKSEJIs5CkkJSQtJCMkKlCrhZyjZBrhVwnZJqQ64VMFzJDyEwhs4TMFjJHyFwh84TcIORGITcJmS/kZiG3CLlVyAIhC4UsEpIV0iJksZAlQpYKWSZkuZAVQm4TslLIKiG3C1ktZI2QtULWCVkvZIOQjULuELJJyGYhW4RsFbJNyHYhO4TsFLJLyG4hdwq5S8geIXuF3C3kHiH3CrlPyP1CHhDyoJCHhDws5BNCHhHyqJBPCnlMyONCnhDyKSFPCnlKyNNCPi3kGSHPCnlOyPNCXhDyGSGfFfKikM8JeUnI54V8QcgXhXxJyJeFfEXIy0JeEfJVIV8T8qqQrwt5Tcg3hHxTyLeEfFvI60K+I+S7Qr4n5PtC3hDyppAfCPmhkB8J+bGQnwj5qZCfCfm5kF8I+aWQt4S8LeQdIb8S8msh7wr5jZD3hLwv5P+E/FbI74T8XsgfhPxRyJ+E/FnIX4T8VcjfhPxdyD+EfCDkn0L+JeTfQv4j5L9C/idEdqxlQsqFVAipFBIQUiWkWkgXITVCaoV0FdJNSJ2Q7kJ6CAkK6Smkl5DeQvoI6Sukn5D+QgYIGShkkJDBQoYIGSrkICEHCxkmpF7IcCEjhIwUcoiQUUJGCxkjZKyQcULGC5kgZKKQSUIOFRISYgsJC4kIiQppENIoJCYkLqRJyGFCDhdyhJAjhRwl5Gghk4UcI+RYIccJOV7ICUJOFHKSkJOFnCLkVCGnCTldyBlCzhRylpCzhZwj5Fwh5wk5X8gFQqYIuVDIRUIuFnKJkEuFXCbkciFXCLlSyFVCEkKahSSFpISkhWSETBVytZBrhFwr5Doh04RcL2S6kBlCZgqZJWS2kDlC5gqZJ+QGITcKuUnIfCE3C7lFyK1CFghZKGSRkKyQFiGLhSwRslTIMiHLhawQcpuQlUJWCbldyGoha4SsFbJOyHohG4RsFHKHkE1CNgvZImSrkG1CtgvZIWSnkF1Cdgu5U8hdQvYI2SvkbiH3CLlXyH1C7hfygBD57Xv5XXn5zXb5PXT5rXH5HW/5jWz5/Wn5bWf53WT5TWL5vV/5LV35nVr5DVj5fVX57VL5XVD5zU35PUv5rUj5HUb5jUP5/cCXhMjv3slvysnvtclvocnvjMlveMnvY8lvT8nvOslvJsnvEclv/cjv6Mhv1Mjvv8hvq8jvlshvgsjvbchvWcjvRMhvMMjvG8hvB8hz+eWZ9/I8eXlWuzwHXZ4xLs/v/rkQee60PNNZjvnkWcTynF95hq48n1ae/SrPVZVnlsrzQOVZm/IcS3lGpDx/UZ5tKM8NlGfyyfPu5Fly8pw2eQaaPF9Mnt0lz8WSZ07J85zkWUnyHCJ5xo88P0cONuW5L/JMFXleiTwLRJ6zIc+wkOdDyLMX5LkG8swA+T6+fNddvkcu39GW7z/Ld4vle7vynVj5vql8l1O+JynfQZTv98l35+R7afKdL/k+lXxXSb4HJN+xke+vyHdD5HsX8p0G+b6A3Isv97nLPeRyT7XcDyz3tMo9nnLPo9wDKPfEyT1ics+UHDDLPTVyj4nccyH3IMhn8vIZtXxmK59hymd68hmXfOYjn4HIZwJyjfzDNWMhck1RrrHJNSe5BiPXJOQcXc5Z5RxOzmnkGL9833DJkvt1pbvaanU5U/rh2F36y/2tcr+n3P8o9wPK/XFyv5jcPyX3E8n9NXK/idx/IfcjyOfz8nm1fH4rn2fK53vyeZd8/iOfh8jnA3K9XK4fy/VUub4o19vk+tMwIfVChgsZIUTO5+T8Ru5vHy1kjJCxQsYJGS9kgpCJQiYJOVSInGjZQsJCIkKiQhqENAqJCYkLaRJymJDDhRwh5EghRwk52to39zlGyLFCjhNyvJAThJwo5CQhJws5RcipQk4TcrqQM4ScKeQsIWcLOUfIuULOE3K+kAuETBFyoZCLhFws5BIhlwq5TMjlQq4QcqWQq4QkhDQLSQpJCUkLyQiZarV354HrR3L/+759zMBZX3vgBBjuky5+chzs5Nc757e71w3Z0dNli291U3K/bjn+yMgdbz68CPpdlfO766GDnh78dvkl0K/Zxe9aF79pLn4zXPxmufjNd/G7xcUv6+K32MVvuYvfbS5+6138Nrr4bXbx2+rid5eL314Xv/td/B508fuUi99TLn6fcfF70cXv8y5+X3Txe9XF7zUXv9dd/L7r4vemi98PXfx+6eL3tovfr138fuPi90cXvz+7+P3Dxe+fLn7/zfk9/+Vb/rX3By9dB/1kny/dC/Evn/rmAz36Qb9eOb/Xzt353Sm9bgxCv94ufn1c/Pq6+PVz8evv4jfAxW+gi98gF7/BLn5DXPyGuvgd5OJ3sIvfMBe/ehe/4S5+I1z8Rrr4HeLiN8rFb7SL3xgXv3EufhNc/Ca6+EVzflQf3pjzO+4/Pz7p8Y3Lx0C/I1ziXebid4ULZrNLvGUufk+4+D3v4vd7B78euf9dR+37X5P7rQYxcmgjo07O/Q6V5uwagMuNHw8lojVWW8fMP1IDMDXghxV+pR78D9/Pku7ubFt8C6Vbl/tdBnSp4ig/ONC9J+fXJeevrlty1zUIT0e5Q07ceutN8C8HeZPuuKyOtMNJhX98Dt9qg52JxiKpWKIx2RxPNUeS0UQ8Fk3EEg1NjbadSoRSTU2h5nAylIhl4uJBWTpjN6fTdrIpkQnFGxIRhX0C4M74fmpI4Z+oBz9vT07Sgx9W+CdnKd1H0s2xUKQh0RhvtjOJxkyoORqLRxKZWCyVSDWJ55UNoZSdbLSTYTsTjycaGhLJhibbzqSbGjLxRoV9ComdjseTTc2xTCiTyDSFxTPPULg5mco0iAehsXgmnWzIZCLRplBDJJ5KJFOxpN2UjMTDmWS6KRNqypfrqSR2KtyQyCRTqeZoKNMUiSVicVF3mmLNAiBuRxrtRLJJ1KmMnU4kY8nmRDok0krbiVTMTsUiDQr7NKBzvvrein+6FvzWOnOGFvxws8I/M0vpvjiu+IbCPksLdzuPf7aess3r5hxSN3E7IexXKhW146lkKhJKRzLCcsUT0VSjHZdNKxJvTkUaYmlh8Ox4IhZuSDc0JhKijSWSdr5czyWx0+FYNBppsmNRO9aYijSmU6F4MhNPReyEbTfbqVQmI+xms2i0mcZYU6NoV+lkOpaONzeKxptvT+eR2KU5hX2+Fp2H8twvILjb8Ug4HIvIPRPxVMiOppLheDgsDYNQfDKcboraTZloOBpJpkQHE40nbGmQkk2ZeFvuU/Rwz9vfC/Xg58eLFwH8Movf1lysBz9ftpfowc/r/1I9+s8o/Mu04NsxhX+5Fv1E8n34FVr4R/L188ocvsWFbbe23au4sUOhfB+ecMbusOlR2M0EdjgRSYbECCjRILqHdLxB2H0x9E03x9OZxnCiORkNhVO2baej4k84nYo2NYuupbkxLbqSZpFcXifJrI7ytPNj+RQzfmMi1JRubMzX9zQzfnNzYywh9KnwM8z4kWRjOhOJ5e3NVGb8REM0k2mIJBT+1cz4DXYo3RCO5evmNcz4Tc2hhkYxI1D41zLji/lJJNWUyI/PruPWT3M6lEzZTWptYFoOX6UhnUr7eua0c66pDKVnWW3XPiyUfi3iyj0PKUPpQT5QP2qdQeluerY91yDhlwK8sV8FcU+lQ2GlGbEyjFhTGbGuZsS6hhHrWkYs1a71trVovh+drgU/Elf4M7Tgh9IKf6YOfDD2mgXwLT7+efzZAL9MA/4cPfrP48/Vo5/8vGxeDl8H9g382Pnx0Y169J4f392kBz8/X5qvBz8//r1ZD37e7tyiB79J4d+qBz8//l2gBz8/flyoBz8//l2kBz+l8LNa8O28floAPp9dDuft5mI9+Hn9LNGCH8nzX6oHP2+bl2nBj+bxl+vBz9vnFXrw8/b5Nj34+XHVSi34Dfn59yot+I358r1dD36+f1+tBz+/XrxGD35+vXKtHvx8/V+nBz9f/9frwc+PTzbowc+PTzbqwc+PT+7Qg5/vHzfpwc+PHzbrwc/3j1v04Oft51Y9+Hn7uU0Lfizfv2/Xg5+3nzv04Oft5049+Hn7uUsPft5+7taDn7efd+rBz9u3u/Tg5+3bHj34efu2Vw9+Sr5vJPfddR24D4/ar8g43gqpvYBq36BKA6YdAPcZ51IpL+v5MP1axFXHej5MT/HB+oHr+dKviuAaJPxwGVYR6VQR6QQJPzw+KwVrOyPWOkasrYxYnHnczIi1kRFrCyPWekasFkYsTt1ztqEdPsVaxYjFWSc4dc9Zv9YwYnG2bc46sZoRi9NG72bE8mv/qMa9NRY9Ppic+x0q0Sn8LnrwI0oX1S66gOmrsRIcW5U5/FdY2E+lVYuwmPNmu+UN8sflXA34QB04YVUXiVVD+Oko0yqXfOP0ncJT42UVvsYFH4bvYbWvwzVIF7V6dBF2Kzf4DpxKvxvgmUo3z5t6+ox2Rxk4jf+HoHDqmXy51V7fXRywLPR7CLpXAfCgk7zVO4SZ9Nzk1ecnpk5NpwT7OShku6jHZ+n7eFoEw2iuwuGOmhJNZtj2YialU1VeFkfX3PW0GYnUcYmZc+ZNS5cjVcIZMFYnhMPZxkVVBihZLuGOz7b9rd7sqbCcnVKlwusC/CgVKEzV6p1qPS6uSiJdda+cCF+NsKqJeIp7hUt8iAHj4ark1hy8VFeVD+moVQX8xqfbSo6eZmdHOtrsdK/kuJUV1Kve0ZIddmsDXQj9qLKsIfwUlup5AhbdM3UBecQ9ZS3gEUD3/pj7H0SY0qm3p9x6cnhP6VfW1/dR3mDZ4Hqqpxyittd6qtKvtbR2V7ZbvaBGhzVW+3Lm3PXppVwhX1WWtYSfwlLdGaynMHwNyCMMD69VfHjvf7n/Qat9ncb1tJbID7wH6+kHuesah/xMzv0OleRiMdzGVRowbT2jWzvptR2o9FU70FPvWtsBVU6UPVG660pwDRJ+eLTclUinK5FOkPDDqwGlYG1lxFrNiLWWEWuHT7E2MmJtYcRaz4jVwoi1iRGLs977UV9u/WCxWNJx1tWdjFgbGLE46ypnHlcxYvm1be9hxFrCiKV2WeBxpsKXrsZq3/a4524wPZUPeA+mX4u48vJpHStReqXGtEo/3fToJ8+nG8GnG6EfVZZ1hJ/C6p77DecMMHw3kEcYHl6r+PDeKbkCCyJM6fCcoY7ID7wH5wzHlbXNGywbXE91lgNMT/GG92D6tZbOdhNyrRdU+6+x2pczo35CXsoV8lVl2Z3wU1hq5RzWUxi+DuQRhofXKj68dyGqp7BO43rancgPvAfr6TmonsKywfVUSznYGc/1VKVfa+lsN631lKoX3Qg91ljty5lRPyEv5Qr5qrLsQfgpLPUmMaynMHx3kEcYHl6r+PBeGtVTWKfxm6s9iPzAe7CeXpnDrXHIz+Tc71BJriFKlSUffsyuI/KJ2xnUNV+9jnhuZyr9Wqt9vdDRzoKIj1M9ULrrSXANEn64jvQk0ulJpBMk/PC8phSstYxYLYxYqxmxNjFirWLE2siItZkRi7NOrGHEWsmItYMJi7LPpfDazsRLup2MWJxtew8jFqct5GyPWxixOMtxLyMWZ53g1D1X27aY88hZJ7YyYvnVTnDy+jiMmQ70aftP95ztcR0jFmce7/QpL87xBGce8fMBOLcsy/2vsdq3PcZ5tloCyaen8gHvwfRrEVdePq3zbEqvQUKvSne9CK5Bwg/Ps3sR6fQi0gkSfrjPKAVrLSNWCyMWZx43MmJtYcTayYjFqfs9jFgHyrE4rL2MWJx1Yg0j1lZGLE77tYMRi1P3nHWVU/d+tV+cdZWzfm1mxOIsR876xdmGOOvXdkasVYxYnHn061iOM4+c4wm/lqNfx3J3MmL5dZzDOcY8MJ74aLQhTjvByYurfslrvK5aCq9dTLyk49Q95xhA9bV4v5vCl07vGlrY8x5bvIamZQ9WgTU0am9djdW+HjLqx/ZSzpCvKsvehJ/C6pP7DfeEwfC9QB5heHit4sN7F+eUEkSY0uE9Yb2J/MB7Sr9yT9h5uR81DvmZnPsdKs3F8XqoSgOmDfXEWO88feEGpl9r6ax3re2AKifKvijd9SG4Bq32dQfXhz5EOn2IdA5g+QvrIiYsNxum/KWrIeJx21uYnsoHvAfTr7W02gXbTa+UvVT66atHP/k9yn0JPn0J/aiy7Ef4Kaz+ud+wP4Lh+4I8wvDwWsWH9xag/qgfCIvbQD8iP/Ae7I9uLG+bN1g2uJ7qKQfv73yo9Gstne2mtZ5S9YJq/zVW+3Jm1E/IS7lCvqos+xN+CmtA7jespzB8P5BHGB5eq/jw3u2onsI6jetpfyI/8B6sp8tyP3pYzu3TS3uGuJTdxjqE8XB70FLedjrktT2o9Gstne2ztT3086hXpZ/+WvSTynipP5CvKssBhJ/Cyh1U3aY9wPD9QR5heHit4sN7u1B7gG0Ht4cBRH7gPdgetiC7DcsG11Mt5RAKZbzWU5V+raXTTrbWU6peUP1fjdW+nBn5pL2UK+SrynIg4aewBuV+w3oKww8AeYTh4bWKD+89jOoprNP4Xb2BRH7gPVhP70XzXZyfybnfoZJc2qbKkg8/kT+JdKAW/HBTDVFefPjNcYU/WA9+o8IfogU/ni/foVrwG/L6OUgPfkrhH6yn/uT5D9OCH4ko/Hot+Ok8/+Fa8KN5/BFa8Jvz7XekFvymfP0/RI9+8uU7Sgt+pkHhj9ajnzz/MXr45+3/OIDPuRah8CdowW89FXm81eoqiDyp9NVYZCwIX+bwX2FhP5VWLcLSNe6j8gb543nfeMAH6sAJa3yRWDWEn44yHeeSb5h+nQtXnA/p8Bk4HdWJdGsYsW5jxNrOhEWNbUvhtTTLx2sAEy9q/FsK1iBGrAomLOmWZ/l4DWbiJa+H+BRrKCPWQYxYBzNiDWPEqmfEGs6EJR3+ml0pvEYw8trGyGskEy95fQgjFlffIa9HMWKNZsQaw4QlHV479QuWeoasd70r2qR3vSuS0LveFU3pXe9qiOhd74rG9K53RaN616OiSTUXUH2kSgPW3WHgPt+8Jer5XVOVfi3iysundf44DPHB+sH7g+oJrkHCD9uAeiKdeiKdIOGH9wqXgrWbEWsVI9YmRqyNjFhrGLFaGLE2M2KtZcTa4VMszrq6nhGLS/fyGo8L/FJXOdvjTkYsv7bHXYxYnG3Ir7rfwIjFaSc4+1pOG82pe059+bV+cY5NOMuRU/cfBzuxhwlLXuM5cim8ljPyGsTEixNLumVZPl6DGXlx6V66lYxYnHUCr9WXglXBhCUdV52Q7jYmLHmN13f8Uo6cvLjqqrz2qy2sY+TFVVe5y5GTlx/1JR1nXcVrq36oq9Jx2S/p9jJicY6/1jFica4pcI7JOecKnGuPanyv1rGHAr+y3H+9zwBCHX4GMFQPH9dnAEMJvVL7YRn5pLyUM+SrynI44aewRuR+w3cHYPh6kEcYHl6r+PDeZ3IFF0SY0uF3B4YT+YH3lH7luwOfrmibt2EgHK6nesrB+zdmVfq1ltZ2Y7vVi2GEHql6oeIGCT88pvdaXlTZ4711pWBtZcRazYi1lhFrh0+xNjJibWHEWs+I1cKItY0Ri7MNcZbjbkasVYxYOxmxONs2Z/3ibEOcdvXjoPvNjFicNlrZQvV+fL3Vih2w2qZTT6RT75IOjK/C6X0frCGs932whka974NFM2rcNRLotQzpDu7T5Bsjxj2fp6HSr0Vcefm0jllHIT5YP3jMOprgGiT88P6q0UQ6o4l0goQftq2lYO1mxFrFiLWJEWsjI9YaRqwWRqxtjFjbGbE4de/XurqTEWstIxZn/eK0OVsZsT4Out/MiMWZxx0+xeJs2+sZsbh0L6/x3km/1FW/jgE4sQ702wf6bVP6jgP99oF++0C//dHUvV/r6i5GLE59cdocTt1vYMTibEOc/bZfbbRfxxOceeQc+3KWI6fuPw52Yg8TVpnVfg9FKVj1jFhc6+TyejgTlnTLsny86hh5Lc/yYa1kxLqNCUtej7D4sD7qupfXeH97KViDGLEGM2FJx6mvQ5h4cdZV6TjbkF/rvV/z+FG3hZy8pDvQd5jfd0i3gglLXnPueeDSl7w+iImXvB7CiMXV10rH2T9y6Us6P/Yd0u1lxOKc861jxOJ8psO5DsC5PsG5Pwe/gwT3hpXl/lNnhst0Jud+h0pyYc/vdqj0axFXXj6t++QovY4i9Kp0N4bgGiT8sD0dQ6QzhkgnSPjh+l4K1g5GrNWMWFsZsXYzYq1lxNruU15rGLFaGLH2MGItYcTay4jFqa8tjFic7XEnIxZnvee0hZzluI4Ri9PmcNaJzYxYnLpf5VNe2xixOOsE59iEs9/mLEe/2i/O+sXZHv1qozmxOOvXekYspXv8Xo/Cl476fhPjXC9ahtJT+YD3YPq1iCsvn9a5HqVXag6tdDeO4Bok/PAzaOobQeOIdIKEH7bNpWBtZcRazYi1lhFrh0+xNjJibWHEWs+I1cKItY0RaxUjFmd73MmIxVm/OPW1iRGLs35xtiFOu8pZJzjtql/bNmd75GxDuxmxONvjx6F+bWbE4hwD4HMi4HgbnxNR7Jgfxlfh6oh4Zbn/er+p2uT5HASVfi2hEx1j/nEe9VrM9zrlNef3J3HfVArWbkasVYxYmxixNjJicX4rtYURi+s7fNJxfXdVOk7d+7Wu7mTEWsuIxVm/OG3OVkasj4PuNzNiceZxh0+xONv2ekYsLt3La67vRkvHWVf9OgbgxPJrv82pe84xAKeN5hxP+LWuHui391+fdmBMXhzWgTH5/qtfB8aF+69++XFcKB2nvvxaV3cxYnHqi9PmcOp+AyMWZxvi7Dv8aqP92qdx5pFz7MtZjpy6/zjYiT1MWGVW+z1OpfBaluXjVc/ES17XMWJxPh/i1NdBjLxWMvGS7jYmLHk9wuLD4qoT0i3P8mFx6Z6zbXO3R642JK+HM2FJx9kePw71C5/jUgrWIEaswUxY0nHq6xAmXpy2UDpOG+3Xeu/XPH7U+1pOXtIdGJuY33dIt4IJi3M8IR2XvuQ115hcXg9hxOLqa6Xj7B855zB+7Duk28uIxbmmsI4Ri/O5Fec6E+f6F+f+QnyOC9zbWpb7X2O1by8yncm536HSnOdzXFT6tYgrMx/bTa/UPm2lnwl6+DSXIXzIZwKhH1WWEwk/hTUp9xt+SxqGnwDyCMPDaxUf3vtp1b7/QYQpHf6W9EQiP/Ce0q+EfLOqbd5g2eB6qqcc7JTXeqrSr7W0thvbrV5Q7Z+qFypukPDDazhey4sqe7w3oRSsrYxYqxmx1jJi7fAp1kZGrC2MWOsZsVoYsbYxYnG2Ic5y3M2ItYoRaycjFmfb5qxfnLw4y5GTF6ed4KwTnOW4mRGL097j9w3h2Aq/b+g2PqXSgfFVuDoinhpb1Vj0GGVy7neoJBdvKEPpqXzAezD9WkInOsZ3Ez3qVeluEsE1SPjhtatJRDqTiHSChB9uo6Vg7WbEWsWItYkRayMj1hpGrBZGrG2MWNsZsTh179e6upMRay0jFmf94uTFWY6cvDjtKmed4CzHzYxYnLrf4VMsTjuxnhGLS/fyGr+76Je66tfxBCfWgTHAgTGATrt6YAxwYAxwYAxwYAxQCItTX36tq7sYsTj15Vc7sYERi7MN+bXv8OvY16/1i3MczVmOnLr/ONiJPUxYZVb7fRClYNUzYnGt38vr4UxY0i3L8vGqY+S1PMuHtZIRi4sXdzly6us2JizuOsFVjvJ6IBMveT2IEWswE5Z0nPo6hImXvB7BhCWdX+vqgfa4//Lox/ol3YF+6EC9x34rmLDkNeceEc76dRATL3k9hBGLq9+WjrOv5dKXdH5sj9LtZcTinIuuY8TifG7FuT7BuW7CuZ8Jv99UAfzKcv/VvkJoz2W4ybnfodKc52+XqfRrEVdmPvl9hXVWe71WEHpVuutPcA0iP+nwez79iXT6E+l0FhZV3lIm536HSnINDXVE2riuwf0NfGVrx73WNZV+rdW+bHXUtQGIj1O5Kd0NJLgGCT9chgOJdAYS6QQJP/yctRSsOxixOHltZcKS110sHizuPLYwYm1mxNrBiLWeEYtTXzsZse5ixNrGiLWWEYtT9xsZsdYwYnHmcQ8j1hJGLDX3wGML6Sbn/odCmWgskoolGpPN8VRzJBlNxGPRRCzR0NRo26lEKNXUFGoOJ0OJWCbeEG9IZ+zmdNpONiUyoXhDIqp37NAQq7Ha23jGsYmt8AfpwQ8r/MF68CMK/yA9+PnyrdeD36Dwh+vBb1T4I/Tgx/W+/2U3KfxJevATCv9QPfgphR/Sg59W+LYe/IzCD2vBD4cUfkQPft6+RfXg5+1bgx78vH1r1IOft28xPfh5+xbXg5+3b0168PP972F68PP283A9+Hn7eYQe/Lz9PFIPft5+HqUHP28/j9aDn7efk7XgR/L28xg9+Hn7eawe/Lz9PE4Pft5+Hq8HP29/TtCDn7c/J+rBz9uHk/Tg5+3DyXrwkwr/FD34eftzqh78vP05TQ9+3v6crgU/mrcPZ+jBz9uHM/Xg5+3DWXrw8+Ors/Xg58dX5+jBz9u3c/Xg5+3beXrw8+Or8/Xg5+3nBXrw8/Zzih78ZoV/oR78vH2+SA9+3j5frAc/b58v0YOft8+XasFvyI8PL9ODn7f/l+vBz9v/K/Tg5+3/lXrw8/b/Kj34efuf0IOft//NVqvjwW5de07q4G5n8nU/RXKPpJtjoUhDojHebGcSjZlQczQWjyQysVgqkWqKpmMNoZSdbLSTYTsTjycaGhLJhibbzqSbGjLxfL+VBtzL2HQTz3PPaMEP5evlVC26T+Xt2tWE7sPRVGNzIhTLxBKJeEZ0QuGU+NcoNJ9pCCeaIsmEKIlUczohHsc0hZOpcCqSjou2mo40NabTrTb/GrJcS3GRfH94LYmdjseTTc2xTCiTyDSFE2L9MtycTGUaQo2CcSadbMhkItEmQTWeSiRTsaTdlIzEw5lkuikTasrr/DoSOxVuSGSSqVRzNJRpisQSsbjQQVOsWQDE7UijnUg2iedUGTudSMaSzYl0SKSVthOpmJ2Ktc5Dp2mpL63r/Nez15f4h3/lUcJP5zYvqHPtpoO0qlC+ZuR+q7OSpZuTbQ0zHfjD8E/12Pdf4j2XS8/LPrRK9nx/qNemMpSeZdF7g1T6nbUPrRLxwfrBe4MCBNcg8pMOPysOEOkEiHQorL2MWC2MWNsYsdYyYm1hxFrDiLWREYszj+sZsfxav1YxYm1nxNrJiMVZvzj1tYkRi7N+cbahrYxYnHWC067i/ezQD48j4DiGsd8Oex1HqPRrrfb9to5xRJXlTa/dhHTNXU+bkUgdl5g5Z960dDlSJRyGYXVCOJxtqBboh4d8ONzJ2ba/T8+2j2cR2BUArwb4USpQmGrYC/NU4xAP6sIi7pUT4asQVhURT3GvcIlvWdqrc35poFYPfsStbGCeVPp1Vnudlzn8V1jYT6VVa9E6n8ykO7e8Qf7YpNUAPni6RWHVFIlVQ/jpKNMql3zD9OtcuFL5CCCdUF0GNUVS4WtdeMHwPYi0VVylw67Aj7sbcdIhbIsqfWm21SsHqXTzvKmnz5hqIVeB9KD0NgCFU3aw3HK3gxDLQr8HoHsVAA86tym/l/aseEoXJLDUUsSBIUHeHRgSfLSHBJSpxVWpxmqf18m5/6FSnN3YUENwasWO24loIp5KRe14KpmKhNKRTDKUiCfEUrQdlwv/kXhzKtIQS6diCTueiIUb0g2NiYR4ApBI2mGJWZ9TPGWesVlSpjJgte8uoY4CKPxlYHXykFwE2QyCOf/medOuOzc9d/Y16RvSwtLOsZArVHfPybb9fW62fTzKuQ1//GrGdA+v3Oq+dEWaMVyFdJsxVfTKcZmxSgLTixnDxUWlK105Ed7NjOGF8gqX+NLVEfdwVdc0gvVc1fFMQtcszK2coX5KrOpQnRAOZ3t/9tjU4L2KwHQbvLtVT4u4V2gg7NYLVTikV+OSnuqNqKYRQGGPzQFpbhKhXgAX5+FAr5R3B3qlj3avVEHEw9xKXaNS+ZAuaDnnv8Zqr4/Juf+hUDoci0YjTXYsascaU5HGdCoUT2biqYidsO1mO5XKZKKJWHM0Hcs0xpoaGyLxdDIdS8ebG8N2Jko12zKL73UeiXuBy0AeTybxQF46uM2gBvjD8JfmPGR6F4OBvHpN9YbEtGtSibnpE6bPmpeel06dOWNues4x01Mn3JCePrfoYf0p2ba/T822j0c5aQCUFnoCfKwFaIQrUHjpVItS4Xvn7ldZrRxgGBU3gMJfldOUXFHqmXvjmaqJik8diq/8pVM1qQ/iPjn3O1Sa89wBqPRrEVddHUAfxAfrp8gOAFYLrE4Ih7O9PzuAvsCPUgHuAGCe+jrEw1Ue3ysnwvdBWH2IeLgDoOJDDBgPVyXc/ODqQy8ibdz8ZoHm12egc7q9rPZ6wE2wgkhPNde+KKx0qrn2QxiTc79DJbmGmNfmqtKvRVx1Ndd+iA/WT5HNFVYxCD8FwakwMCx0UwAlyyEcVewJIh52eLzSD/lJp6qDniOwbM/WW6Vfa+msnq3VgTpKDeqnHOlH05FlrkeEDSD0o8pyKOGnsA7O/YZmCYYfAPIIw8NrFR/eW5EzW0GEKR0+qm4okR94T+lXjlxaatqmp9rWNjC2W4nGkrD9wbriZM77EGkHifgqHJVOdYnpVBPp4Gej0s3KtvWrdfGDzyf7IcxuIB5+TgaP6DkP+XUHmNUIs4cLZpDAlGU3oWsrnpTRIBxlivGwYRTgA+PC3wEUVrp52bZ+KuyDoF7tRvUKdkO4vPsW4O1W3iqc0hWsJ7hMYXvGZQrtBNY/1R6V38FEvpTfMBfMkQSm1NuIrm3DQb3jvmU0uM841Gj02reo9Gut9vVJR99C1W+oH9y3jNGjn4YyhA/5jCH0o8pyLOGnsMblfsO+BYYfA/IIw8NrFR/e+zTqW8aCsLhvGUvkB96DfcvjNW3zhu0H9V/h4nu4fUPdqPKlxlqqTUk+L9S0zYuKB/UJ+6OrgD8Mfwp4gPmiiw3D5TcK5bGQ7e1H5NGrHZ+CsEa58BpTAOt8hAXjj0FYYwtgXYiwYPyxCGtcAawbERaMPw5hjS+AdRPCgvHHI6wJBbDmIywYfwLCai6AdTPCgvGbEVayANYtCAvGTyKsdAGsWxEWjJ9GWJkCWAsQFoyPXw2cWgBrIcKC8acirKsLYC1CWDD+1QjrmgJYMxAWjH8NwrquANalCAvGvw5hTSuAdRbCgvHxa3bXu2DJa3V8Yw8ivopbR2ApO6/6ZPhK3P6YD6v0axFXXj6tY5bpVnu9Qv3g19BmEFyDhB+em80g0plBpENhjWLEGs2INYYRaywj1jhGrPGMWBMYsZoZsZKMWGlGrAwj1lRGrKsZsa5hxLqOEQv3P27jZ3mtjvftYbW3f6NQPGiD8HonnjfC8BDDaXwOH1OMLsB5MOLc0XG6vD4IYXV0nC6v6xFWR8fp8no4wiplnH5Zti1WR8fp8noE4tXRcbq8noiwOjpOl9eTEFYp4/Rsti1WKeP0JMLq6DhdXh9qtcXq6DhdXocQVkfH6fLaRlgdHafL6zDC6ug4XV5HEJbbOH16AawowoLxpyOsGQWwGhAWjD8DYc0sgNWIsGD8mQhrVgGsGMKC8WchrNkFsOIIC8afjbDmFMBqQlgw/hyENbcA1mEIC8afi7DmFcA6HGHB+PMQ1g0FsI5AWDD+DQjrRhcs6c7ItsWC8W9EWDcVwDoOYcH4NyGs+ZZ7Ho9EeYTx5yOsmwtgHYWwYPybEdYtBbCORlgw/i0I69YCWJMRFox/K8JaUADrGIQF4y9AWAsLYB2LsGD8hQhrUQGs4xAWjL8IYWVdsKS7ItsWC8bPIqyWAlinISwYvwVhLbbc83i81RYLxl+MsJYUwDoBYcH4SxDWUhcs6aZn22LB+EsR1rICvE5EvGD8ZQhreQGskxAWjL8cYa1wwZLu7GxbLBh/BcK6rQCvkxEvGP82hLWyANYpCAvGX4mwVhXAOhVhwfirENbtBbBOQ1gw/u0Ia7ULlnTXZ9tiwfirEdaaArxOR7xg/DUIa20BrDMQFoy/FmGtK4B1JsKC8dchrPUFsM5CWDD+eoS1oQDW2QgLxt+AsDYWwDoHYcH4GxHWHQWwzkVYMP4dCGtTAazzEBaMvwlhbS6AdT7CgvE3I6wtBbAuQFgw/haEtbUA1hSEBeNvRVjbCmBdiLBg/G0Ia3sBrIsQFoy/HWHtKIB1McKC8XcgrJ0FsC5BWDD+ToS1qwDWpQgLxt+FsHYXwLoMYcH4uxHWnQWwLkdYMP6dCOuuAlhXICwYX8WtI7DKcv/VM6M94D7fM5qoXYbSU/mA92D6tYgrL5/WZ0Z7rPZ6hfrBz4z2ElyDhB9ec9xLpLOXSIfCGsOINZYRaxwj1nhGrAmMWM2MWElGrDQjVoYRayoj1tWMWNcwYl3HiDWNEWs6I9YMRqyZjFizGLFmM2LNYcSay4g1jxHrBkasGxmxbmLEms+IdTMj1i2MWLcyYi1gxFrIiLWIESvLiNXCiLWYEWsJI9ZSRqxljFjLGbFWMGLdxoi1khFrFSPW7YxYqxmx1jBirWXEWseItZ4RawMj1kZGrDsYsTYxYm1mxNrCiLWVEWsbI9Z2RqwdjFg7GbF2MWLtZsTCa46F9smpz2C57ZNT8Zzex6oAYai9cRDDaR9eBeBcaD/eVYgzlSb1fuPcbFs/+H4j3pMP33nG7z7Cd5jx+1bw/Ua8ZjsM+OF33UYCP5Uf6v3GGpf8wPN68Xu98P1c/A53N+A3APnVAb+hyA++n3sw8usB/IYhvyDwGwnyqt7PDaC8Hpq7r/mEF/LoMbf3o8sc/ltW+3Vx6XC7hecQlaF0+jCmA7HU0XhuR3N0NB3YRvGaez/GdPC7HDCdAUQ6qt7AdstYbzy/S6PSr7Xa2xgdz0Wosw8GEHr1eNQIPt4BqhPC4WxDtUC/CnQPh+M4GQgeI0GpAL9mCvN0sEM8qAuLuFdOhB+KsJyOzahwSI8qShgPV6UydN/pZKD+wB+GPy1XH+TJQP0HtoZ3SgvqAx8Oprg7HQ6GOajwZwEOPQfSmJUO+RrggNnctZXLuV1pTIvApPJ1MMoX5jAUcVDhp4B8DUKnLh1MxLcc7in9W0Rc/JuqM71Q+GEF8oPLSYW/zKWc+hMcYJvEOh2GOOAwBztwuIrgAM1acsbM+TmzZiGHT08sQ7+xyvEJSP0JHCen1CCzp6piBcLFJgqnA3EwJ5llNWJLpael56YdMo1tdZlDYuUW7fAQ2rLad7eaujfP3a1Kv9ai6+JkHj6uRydB/eAhEXUUUpDwgxUDV0C3dLpZrUP7OXNnzHaqC1774TKCD45vFcBSvw/Un47XH4/DNVxtoDohHM62U5EVqiYch267DXMgphquuQ2xYHH1JtJV98qJ8AMQ1gAinuLuNhyDGDAe1S3iLpbqguFBjzD8QtD9qYMccRz1OwWu8UGNnT97sj3vKvuIzp6CCE6FgWGhCwJKlkM4qsqrwy28NEe9B0I1Nqvqdh3BQfnBTTV4wQoeQoEXrOAGGvg1GuwqiLyr/MpmNHRgKy4Oh7nCpj0N+cFmgxcZ4Qh9OvIbBvxmID+4WDgT+cGXpmchP7j4qjbO4DNht6LFNk29HrnYptLqYbXXK1zAxPW7griHF41g/N4u6XQvMZ3uRDqadWnrba+tH9pzG6HA9HG7UP7Uf4WF/fDoS/cx2m5dtnS4nKnVIDesAUViaR4FR/CQg8o3ZV8prlQ+8OqHejgxIjclkVPgR10ebuDhh54Pg0Y8H96o0q9FXHXVR+r7M9QHOKkHPCoutn3Srci2hsN+FcS9chesrYxYuxixtjBirWHEamHE4swjZzly5nE1IxZnHjczYm1jxNrEiLWWEWsnI9ZGRizOOsHZHjnbEGed4NTXekasHYxYnLpfx4jFqfvtjFic+uK0hasYsTj15VdbyKkvTpvzcRgzcdYJzn6bS/fyuovFgyUdZ73n1P0GRizOes+ZR047wTkG4NTXHkasvQjL67xeha8jwlPrUmotE27mVHHVGgpcm+R+ouqkJ7iBVKUvOSp7kEo3z5t6+gx4RmI+PtSD0lsDCqceCZZb7W1ONwcsC/1uQPcqAB508GOSXh6Z6VmPjXh+gq3S76xHZtRmc2rdk/rAh4obJPwOAdfQD6ZDfXgjSPjhfrsUrM2MWNsYsTYxYq1lxNrJiLWREYuzTmxhxGphxOKsE5z6Ws+IxamvdYxYnPraxYjFWVfXMGJ9HMpxOyMWp744+6FVjFic+vJrP8SpL057z1m/OG0OZ3vkrBOcYyYu3ctrvAbjl3rPqfsNjFic9Z4zj5x2wq/jrz2MWGoNhnphGG+TdvtIJZUOjD/GAxY1H1bhxxPh3dZ6qA9+1OR+wwP0dKz1UOUxHqSp0u/IWo/Sm43C4bUeaNvGOWBZ6LeN7jmt9eB9S1tyi0lKv5r2o5H7IvF+RbgXaiTKH7W+CO/h+gvj17qk07XEdLoS6VAfllb51qznVBlKT+UD3oPp1xI60bGG1tujXpV+NK3pJcus9vaqgkhT8VVl6WZbVXuFrzfA8PiD8LB9Q3sTQPcezrXNoNXe7uKP9nq173Kt995ubfPW0f2sEJfqN7y0h46mA7HUB4Cp12ewHSl2DyuMP8ABS5W7dOrjpNIff1BRlUclgSmd+lB5AIV/Jldesr9ZCvbvyzBwnyv8EPJz3dy5wriQK35jenyPVszP5DApPatyp+oBfguwlkiXwsS2udiy60pwcMOC5dUNhYeHl1Dh8ZvZKvxXQNkNQm8R449TSwfrzwAHDrD+wA/mOdWfr3Wg/ny9mztXXH+6WW3Tzh8gA+rPN1H9gTp2qz/dkB+sP0pHVN+O33kotm+H8d3GEH2RH+TeD/n1JfJVhvwgv74u/LoRHFT/iT9WODn3O1SSK/4dp+7ID77j1AP5wXecgsgPHvqL+5WZwA/32/BQXnyYDzxkdxjymwP8uiE/eAgufv0Uugr0G5aLbIsringXC9Yb/C4WdeATrvPwRAmqzeN5wW/B+wyv1rVNz21cCw9IYqx3ES/jBJh+Z41reyA+TjaFOiRKxQ0iP+mWZVvDYb8K4l65C1YLI9Y2RqxVjFjbGbF2MmJtZMTi1NcmRizO+rWFEWsrIxZnnVjLhCWvqyweLOl2MPGSjrNO4Pdl/FInNjNicdpVzrbNVVel86td5awTnPaLsw1x1glOfa1nxOLU1xpGLM66ysnrQL+9//TFOV7ltNGcY4BdjFic9suvdYLTTvi1H+Kcw3Dm8S5GrAN29aNhvzjL8XZGLE59+dXm+HVcuI4Ri7M9cva1nOXo1/HqYkYsTl6cdnUDIxannfCrjebkxal7v9qJTYxYH4d5LWe/vZsRi5MX57yWsxw52yPnHIZz3ZcTi7NO4DaknnvCo+XV3hXp5uauAyj813LPoWtQGmUW67PmqNu+OJX2ME1pl6H0LIt+zq3Sp85VxXs7oV9lCVyb0rGGSDidshPJeHO6Ob+Xchjiiu/h/eCjiPBue0E1ndcbVvsuKrKt+PDDV9JVAr9hyC8A/OAZu9fUt+WvaS9O2Iv+YfpBIjzeR+qGJZ0qm15W27oG2yO1ZwTuk8BtSU87jnjeM6LSr0Vcefm07hmhbGkPQsd1LjoOEn5DwDW2XxXEPae9u9Lh8X4pWDsYsVYzYm1lxNrNiLWWEWu7T3mtYcRqYcTaw4i1hBFrLyMWp762MGJxtsedjFic9Z7TFnKW4zpGLM5y5LRfnPraxoi1ihGLU1+cbYhzPMGpr02MWAfs6v6zq1y6l9f4PAG/1HtO3W9gxOKs95x55LQT6xmx/DpeXcqIpcareK1QXsP3T/Sup4XCeteQWr83Qq1pwTxxfkNGpdVZ35Ch8uZWD+B61zBw7YQ1qkgsvetqrWU6zHLON0y/zoUrlY8go06GIiyva0vFlm0Pq315qria21h+nXOoi55g+h05m0PpLYzCTcm26gHre5gDloV+h9G9CoAHndIxXH/EH4WnbHI3cA9/ShLWtd4Iq18BrCkIq7cLr6EFsM5HWDA+rsPDCmBdiLCoMnGr3xDrRoQF4zu9v++EdRPCouqmwhpbAGs+woLxxyKscQWwbkZY1PkyCmt8AaxbEBZ1Vo/CmlAA61aERZ2zo7CaC2AtQFgwfjPCShbAWoiwYPwkipcEfvBMAepdWfh+/dTubTlR5zPAd1edvmh/b/dWzGu7t+UN49dYbf1qgF8fxBnqQtkoZePhudfcNh6mZ1n02EelX4u4MvPJj32oc8qhflT/6PFzqfhIC6hOCIezDdUC/SrQPfxqdg2K15GvF3cHfl66HOpodBwP6sIi7pUT4esQVh0RT3GvcIkPMahj1XH+4dEW6n4vIu0ACn9rLvNyKNIfHf1BpQX1oXSK64k6fgSHwRxU+Czg0HMgjVnpkK9uDphbgMlZ0p3GtAhMKl/dUb4wh/yjdhR+BcjXIPRlaFhfcRuYl23LrQeRluVwD2LDuNjPLd1CceV1T3CN/ah62wuFh4/hvdRXFX69S13pSnCA+cXlijngMN0dOGwiOEDTmpwxc37OtFrIwd1ElCnERYmLoCuB4+SUGmT2tnSncdRvt+oHTVg3Io1uDhxh3G7gOpWelp6bdlAQ7ltqHRIrt2iHP8mp4klXY2ntjj0PD1T6tRZdbyfz8LGxHVd8sH7wVo7uBNcg4QcrRjHpdANh58ydMdupLngdN1D9FY5vobhlxD3p4GdGOuuoNiqdbiWm081jOjqOL6PS6V5iOt2JdDAWNS2R7vpsqz8M/ySw43PracxyB0y1VKDCZ4j8UMdiqfBTifAZIo9Kl2ngN9UqnDbUJe73ri6S6zVE+KtBmAziCvldUyTXKZ3MdQDBtY5IG/chMF/7ow9R6dcSedTRh7jpVboip5iwqmN1QjicbagW6Ie7ih4o3CnZtr87MsWEp8lRKsBTTJin6xzi4SaB75UT4a9BWNcQ8RT3Cpf4EAPGw1WJiid/X0vE8dJ0rkP4k3O/QyU5u8Fr01Hpd1bTKVRv8PBrGsE1SPjBaSH0g+lMI9KhsA5mxEozYgUZsXozYvVjxBrKiDWMEWsUI9YYRqyxjFjjGLHGM2JNYMRqZsRKMmJNZcQawIhVx4g1GmFR0x6nYVS33HUxU2S8XnSNQ/p9iPgWiluG7vVxwFI48h4cy+BphyJfZblPeQIovMoUXEatQGEwHy9fCMVjpcm536HSnOchvEq/s74QWmjqhcchUwmuQcIP9/dpj+lw1HHp1Ni+jOCD41sIq4y4B/2oOg6XAVQdx09SYVz4JJV66q7GJdRT9FrEh3oiD8P3R+HHAQ5UePhVCBi+N9HmqKfpXR3Sg/zgPbflo3EOWE6nuQ904D4QcMfLOtTOAWqJUoWfQISH/bziQ+kG9+HjifzA8lRP9AMo/MFEftzeClXLopXAj9GepCSPGwEPrNdAtm2+3XQoHdY5tYsC6lLpLIjCQ/1TO6bHIz/YtvD4lNqRA3eE4nZPfaUCfqHA7WsUfmr3tsd2P9IhPcjPrd3D+MW0e+nULhrMPVZkux9J8PNTuz/SY7tXdepAuy+93VP9vdd2D/v75xy+TKJwIZb0x+sJihesM3DMkAD+MPwZLm2AsiFuS+lUm4Zzb/xVHKjLccgPcldzov3XhzU0UnW5zVeust51IR3WHWVvoI1Q5R202tuWMcgPziHx2gfVT8Eds7i+wnoG+6kX0CNP+GhV1dcDj9bzruhH6x4fi+BuHz/RLvWxCA53crbt7448FnHbsQYxqQ8q1TnEg7qwiHvlRPhuCKsbEU9xr3CJDzGcPsII8w93Kqn7NUTaART+emCq+wx0ThfvjqSaYIpIb/9tlLVtr83V8I2yuLkq+CCCU2FgWOiCgJLlEA4Xu3RnZdvHw06pUu83PYv/5hauptcDv27ID35zKwCusasg8q7yK5vZ0CK+ZQWb+zTkB5vN9cgPblSZjvzgE7sZyA8+6ZqJ/OBmy1nID26aVN8Kw6ZmRS5hVQc0fW+K/H4uLucDo4ePzOjhnGzb3x0ZPVCvinkdPfR2iAd1YRH3/DB6oOLJ31VEHC9NR9PrtZ6PJ1Ppd1bTKVRv8MOMPgTXIOGH20UfIp0+RDoUFn6QWGikXOqDkTL0u5tD+uVEfMsFC8YpI3i7PRjBtqjKcm8f+P2Ue10e/lHxpTvQ1bRvL8XuAac2/QcJP9zn1HpMh6OOS6f6oDKCD45vFcAq85AXOBvDdVzls8oqbib4KaKOK11XEPElfj1asLkBhMOf27sR/K5A4al83ITygcPcgPKhwj8H8tET5QNyUnzqUHzlL51qp/MR98m536HSnOd2qtKvRVx1tdP5iA/WT5FDQlgtsDohHM62U9Mo1ByPz7b93ZEh4c3Aj1IBHhLCPN3sEA9XeXyvnAg/H2HNJ+Ip7hUu8SEGjIerEm5+cEHpRiJt3Py+5rKgBNO90WqvB9wE64j0VHO9GYWVTjXXW1CeJud+h0pyDXGvzVWlX4u46mqutyA+WD9FNldYxSD8hQhOhYFhobsQULIcwlHFPoCIh51SZQBxfitX/aSl/27uuofVvqpXIj6Qg5vFCxLxVTgqneoS06km0sELUtKpQ+Gpj8BXongzQbw5KN4s4Hce8ptN5At/BJ7CnOuCOY/wk2V3Zs/WtJzMGKzi2BxTJtBrc8GHucD4tyCsWwtg4cNcYPxbEdaCAlj4MBcYfwHCWlgACx/mAuMvRFiLCmDhw1xg/EUIK1sACx/mAuNnEVZLASx8mAuM34KwFhfAwoe5wPiLEdaSAlj4MBcYfwnCWloACx/mAuMvRVjLCmDhw1xg/GUIa3kBrEUIC8ZfjrBWFMCagbBg/BUI67YCWJciLBj/NoS1sgDWWQgLxl+JsFa5YMlrtY2wBxF/FcK6vQDWIIQF46u4dQRWWe6/GkatBvcZn8t5Xs1T6dcirrx8WodRq632eoX6wasTawiuQcIP9kXQD6azhkiHwprPiHULI9atjFgLGLEWMmItYsTKMmK1MGItZsRawoi1lBFrGSPWckasFYxYtzFirWTEwn2Z27heXg/OXbuN61U8aM/wsga1fELNA5zmDXBp5JYCnA9CnDs6f5DX9Qiro/MHeT0cYZUyf7gs2xaro/MHeT0C8ero/EFeT0RYHZ0/yOtJCAvGxza30Pwhm22LBeMXO39IIqyOzh/k9aFWW6yOzh/kdQhhdXT+IK9thNXR+YO8DiOsjs4f5HUEYXV0/iCvowirlPlDA8Jymz+sLoDViLBg/NUIa00BrBjCgvHXIKy1BbDiCAvGX4uw1hXAakJYMP46hLW+ANZhCAvGX4+wNhTAOhxhwfgbENbGAlhHICwYfyPCusMFS7ozsm2xYPw7ENamAljHISwYfxPC2my55/FIqy0WjL8ZYW0pgHUUwoLxtyCsrQWwjkZYMP5WhLWtANZkhAXjb0NY2wtgHYOwYPztCGtHAaxjERaMvwNh7SyAdRzCgvF3IqxdLljSXZFtiwXj70JYuwtgnYawYPzdCOtOyz2Px1ttsWD8OxHWXQWwTkBYMP5dCGuPC5Z007NtsWD8PQhrbwFeJyJeMP5ehHV3AayTEBaMfzfCuscFS7qzs22xYPx7ENa9BXidjHjB+PcirPsKYJ2CsGD8+xDW/QWwTkVYMP79COuBAlinISwY/wGE9aALlnTq5LseRPwHEdZDBXidjnjB+A8hrIcLYJ2BsGD8hxHWJwpgnYmwYPxPIKxHCmCdhbBg/EcQ1qMFsM5GWDD+owjrkwWwzkFYMP4nEdZjBbDORVgw/mMI6/ECWOchLBj/cYT1RAGs8xEWjP8EwvpUAawLEBaM/ymE9WQBrCkIC8Z/EmE9VQDrQoQF4z+FsJ4ugHURwoLxn0ZYny6AdTHCgvE/jbCeKYB1CcKC8Z9BWM8WwLoUYcH4zyKs5wpgXYawYPznENbzBbAuR1gw/vMI64UCWFcgLBj/BYT1mQJYVyIsGF/FrSOwynL/1fOnz4L7fM97op7fC1Pp1yKuvHxanz991mqvV6gf/PzpRYJrkPDDa44vEum8SKRDYd3KiLWAEWshI9YiRqwsI1YLI9ZiRqwljFhLGbGWMWItZ8RawYh1GyPWSkasVYxYqxmx1jBirWXEWseItZ4RawMj1kZGrDsYsTYxYm1mxNrCiLWVEWsbI9Z2RqwdjFg7GbF2MWLtZsS6kxHrLkasPYxYexmx7mbEuocR615GrPsYse5nxHqAEetBRqyHGLEeZsT6BCPWI4xYjzJifZIR6zFGrMcZsZ5gxPoUI9aTjFhPMWI9zYj1aUasZxixnmXEeo4R63lGLLzmWGif3FW5a7d9cioeXHfCrwpWoDgwPMRw2odXATgX2o+XQJw7uh9PXuMvNVH78aj3xuZm2/rNAPHwuwIzgR9+F20W8JuP/OB7Y3j9dw7wuwX5zQV+tyK/ecBP5RW+NxZAeT0nd1/zG93k4UNYH1D/ZQ7/Lav9mrR0uM3AQ6nKUDrzGdOB+sLr0DczpgPrNM7PLYzpQKzjs/v+U+0Qf92PskO3uqQD46twVDozSkxnBpEOxlKvckun3tGE7TqAwmdybUa+yr2mvi0mZdtmgHv4fUzKtqm2uBD4cT5XUfhZPfgRpQtqfzPMk0q/jtBdMfUYplVrtbfzOp5JUXmD/HE9hM9OoA6csBYViVVD+Oko04Uu+Ybp17lwpfLh1DZhOjWETlT4rAsvGN5t/7vSYQvwY9Rh2E2HWZCmSl8eS9Ald51KN8+bevoM+GHKfHyoB6W3wSicsjvlVvs6uMgBy0K/B6N7FQAPus6y41Q6tSWmU0ukU0fEK8Y+UelQnKkTd1R/JMdwK9C7/6p+w6NI4Hs6+BMcKvwHA1oxV+UwqfeInNpkGUgPnpmATyqC488KIsxMB37rQP+KvyI+k8jzQBfOChOeSwE5q/MhMIdNaFysqS8mx8UqrR6Ir7yejvzgOHc+8oNjU/yuLfV+GbyH66vbuRHqt9M4Co6zYPhdRY6jvB4zpOJScz6sByodt378Jo/pdC0xna5EOqWOk6h0KM54zisdtEMPITuk6itskzCuOg8ggML/GtihR1zsEJ7z47Edts3YDqn0nOwQrp8q/BMudoiaO5yVdeasMKEdgpyxHVLhP43skKbxHWmHVFpUP4tPryy2n+1G6EF3P4sPrl7ImA7EUm2FGmti+1Ps2B/Gx2Ntp/b6pZ50mlR7hXU3gMI/Btrry6i9wvruNj7DfdtCIl3cZiyr/fxROjdbttABy2sfpcJ/06WPcpsLSec213fiV2nRbWp2tjXPTlgWcU+Fh/0jXv9ahMIudAnrNHeV1825a73rC3Fb1fcWq71TfosJzspvCQh/QbY1HHYV6DfMk6wP6+tbcXE4zAfqabEDJmUT5mXbhlV5LidwswgXtnOsL3WmGG7jv8vVd9nG3+pJ4+F6It1VOTy9c+h4GJcvdLh8sX6wo8pX8Zbl+7kiyjcL/JYgP2iX8Xl00J4rDKn7f6B+H+L7oS11pL0Uo0+qvVD6xM9pqP4R6jOAMAb3ag3zT1TfVRjcJ0in2o9qs0p/lUR86fD4ToX/L+hfug6n03drb5ZF2wWoB3yO5GKL5kLlWYUdkNOTqo+wjfHVx2i+Pi5FnGHayzSlXYbSsyx6rVmlX0fwUbxrCb/KErg22LFYuDGaasg0N8YbGtJlCF9xxffwOil1vkSQCK90vUKLriMpZQPg5+WWA71KVwn8liG/APBTHGUbuqa+Lf/lmvh70T9MP0iEvyHbGq6YsgwS6eB5RSlYCzuI1ctq2waovhCObXBfmAV+8MzTWK/W+5RddLN1LblrbPdhPrEdjCJbB/s/xjoUpcaj2NYt1ZS2V1un0q+znMu2lvArxdalGqJ2NNPU0JzKRNKpWKbMat8nVBD3sK2j6m0PIrxmWxGibB22Z5XAbynyg7ZOcaRsnZ5+MRLyon+YfpAIj22d17IMEulgW1cK1sIOYilbB8dBeJwKbR0ep2aJ/EBbh+dlhyGbpOlLB+Q6ILapkK90cA6dBXrC+sU48B4cN8M4eF1GhT8WjNuP7kXzU3k4j+BH7euC+Tq+l3O4LBFOri0q2zI1Pfe8qxOz06nz0snZ6bkVFk0PZxFnH0+nLBROukp0bx76jZdvZiAc1QVXWoUdrBIQiyo6iI273pNzKpMmrHtuykNtP5Nucu5/qERHTR1xV6vnEV/Y87RCpV9rta9yOrawUMuXUD+4e9Tz6CEckjNgvLwt3cxse91gHngLIfWxGi/6h/mlltpxvVHpUibQ6XFnCpisKb1aw2Mb4GXbGGwnbltnyojwaeQHH4+VueDjZZDLQDsehL7dCYc6Kh96vxoetqmvhkP7B4dRTvUfhlc6x494oE7cHo9Lfaoyd3skTz3yhN8pxfWaehyO6253Ih3dbaQ7yg+sl3jLQLGPC6n6WOix10yHNub02CsM/GH4PeCx1xxUntTwYT+2gXCxbYAqB6hrdaxnkAh/ebatH9UGKD3hujCD4ED1Q1RdmOGQjnTTsh1PB8dX4byMI/QMzb1/tlul31njiJs86lXp51Y9+gl5sS2UPaSmKAqLelRO9QPU4zg4/cPTuXU5O+K2fcCtn6Ieg0v7tBJNW3SPh9zaQ0fTgVg3Z/f9D+R+qznFdjCW2trLOb76PE0ViENtPcD5gXUI9im7UJ8CH5dQdQ0vMarwU0GfclcHxwjYjhY7RnDbHujWL0iHP/vjZdtoV4vepqq+367KWC2VPAzK+EGH6bh0sHweReUDbSFVPvjb8U7LAY+CZRnI8QnA8TGXtgc5PukQTl5fb7UPh22RZdHjF1yGWYBFhcfbA1T4ZzyO61V90DumsclxPSx/PKYp1B+puuu2pQqX82ugnD+H2itlFzvaJp3Gk062XPNre01exxx++BArNeZwajvSqfEdFT5L4FPlJtcusN0OAiyVbhdwL4vu4T7HbYwiHbQl3+pFY8D8UeMcdcQ+xPBiy4utz1Se/NBuvNRrKh23MZCu10rxK15Z4MfYtqJK9y2AJzXmhelLWQzyUIEwqPB4HRHjL0bhVfxKi94iq9oD7sd69973/8OtbKgvdcujdOqTkmUEpwoiDD4acYnVmjbF+ULEWYV/F/S9eMs5NRdpAZh4m70K/z7AnFtP87Qsb3aUejwGH4EpPtTW56UoHnwMh8ucwsaPwimcJQgH57Mc3OtJYFOPgqVMzv0OlegUnnpUCrf7Lif4BFD4D1A9vg3p1E1nUlYQ6cKjEnuidFegdD+sl8PbYipucHwPyx2XCR53Yp4Z5K/C/w+Mwf6D+r2s1epg/xjoTacN5wPLXLguJbjCNtOSbeufr+O5dD/82vdwmivkA7nuv/VDeqzdZh0j21Y/lP2gXl8o1n5Qj+qzyI8at5dZ7W2Ylz4GlgMVHm+LVOF7gnJWcyW3dUqJr/olah3C6dW6Qv0UNX+FzyH696ZxnV7ZUp+Wxc+wLgLrFoN602lLB9vgkCLTnuKQdhCkfTDSIbWWwTn+o8qqt9U2X8W+rgLj41cUdLyaBNOk+mc81i/21SQY3+kYAOUvnebxrOe5q0q/ltCJjrlr1mqvV+rVWxW+hQh/q0v4xUR4qtzg3DWbuwfnripdOHddjO6V8lpaY5F2Aa4Fw/Bv92/FbEJ2AfLCr55Bm9HHorlYlnsZBYn4eE+CrnlhH5SfW13yU+zzVhi/s17P7IPScao3J6N609HXj78M6s1pLvXG7bV6t1cdvaypu5XBTR7TWVBiOl5f3fwo16lLmerUk6BOXeEyzvuo63kRYzrUWg/ut7B+oZ9KB99zGydlUX6c6s31vek0vdYbFX4nqDczPdQbqgycjleC6XbW3pzOsoduWNTYW4WnxrZuY7AsEZ5aj6Zep1R1W+/rJN73h6j0axFXXj6t411qjaCF0F03q3XtI5GeY4fjx6eTs+fPnIsLQwEGkZLhQrR0KryFfuN4klQlCgMbGnTwjA9YkYIofhbdx/heOBUKW8ifaoQtDvm0LG+NEMYv9jxF/N6pCn8bWETxcsYCrDxezlhw27iDda3u1zrEg4vG0A/m+XSXPKvw61zyvKhAnqegPDud5QZ/43AVRB66WPQmCbdzYPpabbkXW59g/M4arPRF6Th17jsdFo+dNpBOBf4w/G2gc78Tde7U4Ft3/p3OU4L5mgrCOJ35UUlgSodf/FDhH8jlXfPCD/kOk0qLWiiFG+Af6l1YN25lrsLfDMr8EQ9l7tZ+qHPC3GyF0QMZOx3yUsdh+sYPZH5W1lbJXgcyOJ7bQAaHdWrUpQ5kKE5OYYsdyMAZQAsKW+yOERhfhdO7myrcbocyfKoDGxOekS0AeaA6aKedoGUO+LgDUPErHXSHd1io8C+BQUz/4fuuqbLq58DPsryVFYzfWbt7+qF0dKziSodXNDp7sO5UB9XbMIUGSd8sssPEb5Op8ONAh/k66jC97iLzslKL67xleVvhd2tvXtsP1lElgSmd06G0v0MDKD1vrDaE9t9TuwbPnb9K321XRS3hV9IhPLGMHWpsjEUy4UQ83dCI+0jFFd/z8kTvYCK83hWjKHkITwvQq3SVwC+L/ALADz4ZxAdTtGji70X/MP0gEX4eyEMxZUlhnd5BLHWYBDVZ31+2zGkR5ybgD8P/xWVBgzr8mDqwl8rrAhRvAcFdOmwTpZuc+1+oJmUKOJWeKp9qggt+00eF/RfcITS8bV6cdv5UOuTX7aDPMstZdziNciLu1VZbbos8cKMWniDGfAeeEqOzdqBQ6QwtMZ2hRDo6n3zBNAuNx+r6tMaB9sbpidSibKs/DD8AjMeCOUzqbV68845aWKUObse6VzvvcBhsb1T4vjlO1E7pm1CeYT7d6hkcj0HOTgtag3Ic9ueCFs5zpdW6uxfaxxOydJ4LHYiswrcALKoeYRueBfFbHLCcFs2dDv35e27lVtaVelTP1YcQnPJ/YrYtpgo/GWCOLBLzJAfMo/u0Yo5GbQd+sKG/RacnXQVxD9sHGF+FU3VR11vfCn+WHvz8h4ZmErqAeVLpl/rxOJhWrdW+jHQsJFJ5cytn+AEQ/KYUhTWzSKwawk9Hmc5wyTdMv86FK5UPPAai0ulP6ESFn+3CC4ZXbRjWfRVX6RB+uJFRh2G38oYfklTpd+TjUUpv/VE4/PEoqPtZDlgW+t0f3auw6I9HSZvZklt860HkbzzCpcoO3sP1H8ZX4ah0AiWmEyDSccMaT2Dhvh2GDxDhVT7gB0I7Z227tX7OIbhSa3QdqZ9Kb0NQODVuKbfat8G5DlgW+j0E3XOqnxVEGviDNG7tUroeBAa263Nc0lR5lY56A1aFwwfbptF4VY+tisfwh2pVGjDtmzSl7bXPd3qOAHlTb7OXsn4YTmSiyWQkZDfZDZlEpMmtfVPPQ1R4ar1nAhFe6VrPxzDjUbdTIaj1Q3xCVgD4KY7U+qEemxWPetE/TJ86pRCvHxb7bMttbuwVS60fQruv2nZn2Ro3LGqtrwxxrrLoZ5vYlqnw08D8X715V2E568Ei7pVb7e3Umdl9/6m+FPchc4m8wntYbzC+Crf/bGWooVhbWeugk8k8fFxPFKP0ip/NwrjUs1b80Y5i1839jgXrNv6QvPKn/qt08D2cDh4vwHR0PYf30k46mg7EUmNI3c/71Vqi3r45lqbeJFUOr1VT9SYL/PBYqQX44fKBzyrxm3BLgN814Bq7CvQbjw+GDm/FxeGUozbb4X6v2I9yziD4UOtPcD1+ex86TbgeD9dAnPZHjAHrlLtc1hSd9g7BtW3I1WmvwV40V9gfH8CtIfLH2EZS1AdVlaNOTcJthPqwI9V+cBuB7QefeA4d1Q6ULmQ7mFJEO5hO5INqI3h/zUIiH1R/MB35QRu+APnB8QN+awnaSnX6WhlKTzqqveJnEG551j0eriHyuj/rLj6tahGhN691UOVJ1sG1HuogHotgbliHHZk34DDYjqrwX3B5bjgXxFGYCwGm0yll0LbCMQW2rSr8y8i2alqTI22rlxPzO2OtEKZnWfS8ww+nClLzbbl2qT6WPW1GInVcYuacedPS5UiVsOlTph6Hh2Etwq8C3ZuJwp2abftbNQfchDF2BUiX2mJKLVG4bUuillDmEumqe+VE+PkIaz4RT3F3W7KBGNSyuMKg4snf1znEcdIV7CawrtxeYF1QAAu/8+X2Ps/CAljnIyy37yYvKoB1IcJy+lCHlGwBrBsRFvVtW4XVUgDrJoQF47cgrMUFsOYjLBh/McJaUgDrZoQF4y9BWEsLYOFDmGF8fPDbsgJYtyIs6rteCmt5AawFCIv6HqLCWlEAayHCgvFXOMSDXbV0Xg7t1/OdSzvitatT6XfWof2U3qmDH5XubiO4Bgk/+GgY+sF0biPSobBmM2LdxIh1KyPWAkashYxYixixsoxYLYxYixmxljBiLWXEWsaItZwRaw4j1nRGrFmMWPMQFrW9j7K53XIi3Zy5M2anc/MLCzm3+YD8Pd8h/V5EfAvFLUP3ejlgKRx5D47x8XQdHoBJjccVHv5QxtDcsmcXq/1jvhlEfOnctgRq3r7oeWqr0u+sLYezEB+sH9zfzya4Bgk/vCQyw2M6HHVcOjXnLSP44PgWwioj7klHbUGjltLKkJ9KD99zWy7Er42o8cBEUO+dXqehHiFIh7f0q/AhgIkPAvf6MUgVfpFLniEfao6p4up9tBDLUEudylHL9Hh5vwX44eV9OHbAy/twLICX22DfDnWCHbXsCs9p8fIIDNcXhYvri7LV2G7CuPBRFrUNdjRKk7I38B5uEzC+CkelEygxnQCRjhvWaAJLhae2f7hty6S2JWre4pHflkltOaXWwzqyLVPpbQQKh7dlUtshMZaFfo9A9yoselsmVVdmOPBU6RaqK9TrBhgLPipQa3TSHz9+UOHTORusyn02ytvk3O9QSa4p4rb9Q++jqSbPax5OWzsgb2rLUUlbMOMR246H7HQ6FA0lUiG3tkxtOVLhqS1KY4jweh+lNIWoLZh4m2Ul8JuL/ALAT3GktmDqsU9NnvQP06e27uAtmMVuy4N+UzqIpbZgQhuPXy/QbZvw64nXEmPIzubSkvs9w2U8S/VNcOyJn31Qr99Qr3DgfBX7CscMj+mMKzGdcUQ6dUS8Mof/Kh18D6dDcS60fenWvq1xYP12mnuotf8ACv822L60KHdNbdPAa76FtgXg9qriw20Bbv2yCr8U1E+8LWA2yjPMJ1XPVJ4riXxJh7cFqPAr0dhA0zZbclsA7os7f9zgfe0Ev56h6ZU7260PoLYDedwWgKs4VCeEw9mGaoF+hZZITs62/d2RbQHUcMftUTfVdVOP6WYT6ap7hd7mwungoXSFS3yIQU1LFAYVT/5OOcRx0hU13aamhfgx1fwCWLhrpLZAKKxbC2DhbQFuJ84sLICFtwVQx/IqrEUFsPC2ALctBi0FsPC2ABi/BWEtLoBV6rYAiFXqtgCIVeq2AIhV6rYAamjgti0Ax4Pdq3ReHuXDx1SMj/I9n6+u0u+sR/mU3t0e5a8guAYJP7zkQW0ZWEGkQ2FlGbEWMGLNYcS6iRFrPiPWrYxYCxmxFjFitTBiLWbEWsKItZQRaxkj1nRGrP39yHyuQ/pBIr6F4pahe0EHLIUj78Hxr5dH5nCs6vTI/AcHHpmz9Ksf1Ufmaj5YRvDB8S2EVUbckw4+MlfhqLdoqLmLCo/fvsAY+LG2Cv+uy2Ntai7m9ljb7Q0AyIea5+LTh6l5LrVcD98Ykq4S+DHW6yT1bV+on0DWuy6kw7qj5oRwHIPfEHN7swy2FzyuKlSv3B5nq7hwaZOa7w5DaRb7RjaM73YqdaDEdAJEOm5YwwgsFZ6ao7o9zqbmqKqvwN9qn5z7HSrNhd3qGjXP7cjjbKW3wSgcfpxNfU8aY1no92B0r9DjbFimsx14qnQL1RUY361OzigxnRlEOvhx0EG5vkLzCS8Rt+8p6z1dO+75MbhKn9papHjXEn6lPAbPxMOhZCSTDjVEmpuTofxJ2tSaF7znxWaMJMLrtQtx8jH4EqBX6SqB32LkB/s+xZF6DL5EE38v+ofpB4nw+DG417KksE7vIJZ6DE6dbN3ZtkatL4zI2RrqMbhuLnq3OMZt6jNNylH2BL8FDttvsW+Bw+2IxbwFDnWO11qKfQscfrqrggiDH/eq8GFQJ/DjXuozhm5vgStM+LgXcsaPe1X4GOoDNX13nnzc6/ZJPy/PjYr9HqzePBbfDvA2C2jX8TZg2Gfhx+RwHW068oPPIfDJttTaOPWqHT5lZiXww1uLVwE/PKeHjmrLqlxke1gxsBUXh7NQmrDe4HEMtHlKv9SWj1HgGvoprvgerm8w/nSHeJCPdJpP67X1nu7UeqKy29YEqv50dDsRTKsWYXHrzi1vbtuoqO2jblhetgRCLM3bX/JlOscl35QNorhS+cDr9FQ7G0XoRIVf4MILhqfWxlRczX2d6ynE1CsoHVkfUHobj8LhU7I7cgrxeHTPaX1Ahae2Gs4nOHnZajenABbea+K0b8apvUEsvNeE0pVbvYNYeK8JVe8UVqHPpeK9JlSdUVgtBbBK3WsCsUrdawKxSt1rArFK3WsCsUrdawKxSj2CAmIVcwQFNZ+Ujlpvh9tsF6BnJyoufBYC18Hxa4Mq/Av9WjGz4Bq/zgjtwM1WWz84drwF8YfPxJRN0vsqi/fngyr9WsSVmY/tZnupbfIet4XikzOgOiEczjZUC/TDjwHxo90ZKF5HtoVSXcYsAtOty8DxoC4s4l45EX42wppNxFPcK1ziQwzqIxc4//gtMHnvRiJt/BbYHWD5oT9afqDSgvrASyDUjncYBnNQ4be6LIGoMJUO+ZrlgPkoMDk7+tGYFoFJ5WsOyhfmMBtxUOHvBPlS2x8sq319xW1ALZ/i6QHmTt2D2DAu9nNLt1BceX0DuMZ+VL29EYVX22ucdIrrigr/gEtdmUlwoLaGO3HAYeY4cPgEwQGa1uSMmfMddkRUgmvKFOKixEUwk8BxckoNMnuqOWAc9dut+lG7SSyHe7gYVFz4IfpUelp6rtOWEdy3THdIrNyiHf5gk4onnV+3D2n62JXr9iHqw1zU4ah4+xC1laTYdDq6fchp3ED1Vzi+heKWEfekk43l6S5tw7kNgaW7PtvqD8O/COwE3g6kwpQ7YKppqQpPnf5DLX2r8CuJ8HA5V6WvxkNwGXilVThtaDCwXV1VJNfbifBwCfk2xBXyu71IrlM6mesMgmsdkTa2UTBf+8NGqfRriTzqsFFuepWuyCkMrOpYnRAOZ9vJLGBThKcFp2Tb/u7IFGY18KNUgKcwME+rHeLhJoHvlRPhb0dYtxPxFPcKl/gQA8bDVYmKJ39fS8Tx0nRWI/zJud+hkpzt+Rs1Kv3OajqF6g3u3tcQXIOEH14GWEOks4ZIh8LKMmKtYMSazog1mxFrDiPWXEasBYxYixixWhixFjNiLWHEWsqItYwRazkj1nxGrJWMWDMYsWYxYuG3lKg3OJyGURxvKd3ukH4fIr6F4pahe30csBSOvAfHMnjaofqFKst9yhNA4bvmPghMvaW0gogvXR1xT+Wnhkh7fwzhVfqd9fZvoakXHoesJLgGCT/c33s9MJzrLSU1ti8j+OD4FsIqI+5BP6qOUx+5wE/tYFzqqV2WwHWbsrfk7sMlDogxI9vqD8MPAW0HL3FQT5LdptZLiPCwL87mrqknz0uQH4ynxhl1Cjvb6qfCaX7jKU298QTzG8i21QX1tBuGx7qjnmjD8YIq+yAKD/UYRPqCaWJ7B8tD1r+6Pm3DUW85eLFbMG9BAkt9n5I6ULXUdCDWLJQO3PkBn5aH+7fiQp3AdgTHzGHgD8Of2b8VsyF37bbzAx+oGwft8MvDneMrXVInmODvrcF6gMdlWSKfUH/YXqjwRwGer6Cd2rBdwu/uSVcJ/BjbZYZql9nWbLRrl5SNguFxu3Rrx1BnQat9m8VzLWr3kdO306AOq4jwEA/vBj+FGA8pfrD/ySLu84vkTvVHlJ2BB/9+s/e+6x6IA+4PnPpAeA+3/xYibxirnOAP2zUu9woibSq8qhPwMTdlvwMo/BRQVj2H05iWA4cFDpyrHMIvQRxU+EuI+uJmJ2D9X4wwVfjLASY+pLEQ5lQHzKtcxipUO20B94rtb/F4JAv8liE/yB33m0tB+rhMr8y2TR/iZK22DnN24ov73EJ8cX+k/G4E/dl1uesahMdsyyNuZTmWyI/Xslzgkn+MpeJVWu3rq1sbgvqa3Z/GDBSJOY8YE1BjnbnZ1rRvdBjPSIfHM9Jhuw1tiooLx0nU2MLpO8MLiPZKjRXgIf7SVQI/tvplp0PUWAHqIgDS9aI7bFNaiPBZEAaP4WH42dm2fm4f5ePqix/q3RZ3kQuuvB6IeGRzv6kxpLxOAn8YfrWLHad06KZzao7aAsLgt9OywG8x8qPqtN/qK9QPrq9uupCu2Pk6rq9U/0TV1xaUjlu9ks6tvqq4sr7udBk7qvSptQX8nKJQncFrxUsAByo8HgOp8HtdxlVUH0d96MVrH4e3g3jp42C7hTo5K9s2Pyr8Ax7tee5S89zPtqn2AfWK24ebDqXDOqfeDIC6VDoLovBQ/1T7WIr83N7myBIcvLYdFVfW2+uRrS/0kR48F4XjRFxfKVuvwj/jYuuzBIdS+le8NkLp1c12+K0u+8XW4zUOytZT9Q+uX1zqYazhdiJUlgi/iOBPrYtlkR+1Lrbf+nmHss8l9aHDZe/WDqQrdoyEyx7Wi4XID64RZVE6hWzKWSgfhWwKXmtV4b9XpE1xq1duuizWpkDubjalc9ZG/V2v3GxKFqXjta8qZINORuNHmCY+GS5LpOn27KtQPcL2iapHFQQvaCdrCFzpJuf+h0p0bs9kaqz25cu49uN5b55Kv5bQo45n4lS5Qv2UI/0s1sMn2tNq31akm5ltrxvMIwuuYXy1Fi7dhQAHn+wD32CFz87+4uHZGfV2NV4P+CdYO/s7wqROTvLa9lVcidvYm+YKcd1OrmkBWFT4rNU2byr8f13mgJT9pOqWCl9oDIdPx4L1we35+kKHdKi9BFS/nA8/oDWvbvPDznlmH7b39zP7bO7ayzN76oQbt7pKncyA2yuMS7XX+SBfVNuCNgFyVDykmwHC4HUTanxHnR6Ax3d9iXrkpote4F6x/TJuM8XOxalycLMZVNm025MD8o9tRguIQ43RsE5V+INddErZITedFrJD2dy1mx3yqlP8uo9Kx6tOVfhRLjqF63dedKrCj3XRKaUjN50W2meQzV1T9hvvK84SWNSJKZirV52q8CEXncITFL3oVIWP7EedwjwvRfGywA+PObG9q3WI19MFs8UBU92H8RYReXArS8qm4bI80qUsqXy1eMzXYqZ8LS4yXyr8cZryNd8hX/OLzFdLgXw5nXp8CpEvqg9zmtdSay7S4bV/Ff4Mj2O7j8uaGV4Xo8bhbnuu3OpLR+Y3Q9DaBqyfuA7AE3/c1unwvrLLPNYBeGKtdJXAT3cdgHUZ1wFqzdntmVuWCE+tOQeJ8GqeTNUBPN/iqgP9e7cNp2tvrcob1hOcR8A1CjyPWAzSpdoiDt+Su19p0eNNvP9EhZ8B6mtPsFcV6xeuacwaQKft1FbwmoYKv3RAK+bc3DX1Sjnen1Cs7YZ6drLd8w/Y7ja2W+mMst24TbvZburdD+qEaeqEW/jux65ehflnibgqPDXmg+Gd9ifc5jI2otaAoJ4iDphrQL2/fUDb/MNyVPudZLjNA3jSXu8yd6DmAtQJ7Cp8obUdvHcIzitUXJxvXFabkV2gno9gncCxKgyPx6rQD6ZfaAy+hMgj1mGVQ3hoK2H4XUQ987L3geLntV9sAVyxTXf7upB0uC64jRtgutRzJWzfqfc19t8zwnCYssUwv9gWZwlduK1ZU2WYBWGc9kRSdhraYtw+qJPlvdYVFVfWlZk5W0ytXd3kIW/wXrkLf9xWVH6eAm0F75un1lPdxu35PTgudpHKg9vzcq/PfKnxzGKXeNRzTpjW5Nz/UChTklPpKbtVTXBx6i8/B+3YcJprWTu+pTmq7yxDeoI2mNE2hMpQepbVfq6A+yaqv5nMwqf1mSy1Dki1O71fCrIz8JksrL/wmSwsG2r8QI1/4Xzkq6jvomxAFuDawB+G/yYYl33dAdOyiredcH/ul3q2xeXeo5bNXVO2ZQnyo+aHbu/rKA7U3lgYPgn8Yfg3gG1wey+yU5592pn9vjdW6YzaG4v7bqr+wbrg9AUpp3EofqdJhf+lyzjUbX/uwiK5ZwnuuJ3jtvNVD2PUUvbnDgT+MPz7RT5r7ay9dDAe/PLIh9jZVj8V7sD+3FY/+L6QSrPQ3riHkO2m3jGizrXA9dXpvflBwB+G/49L/SvULxW7XovfA/S6R3i/vwsUssP7e81Mlb2XPcLUvijq/BP4LtqKXP3TqcdYPJQf06oyVPUVu0rgD8MHc4a0FuRD/a8sgWcmlrAzkUQm0ZBIpaLJBP7SmnSqzLpqSD8cjzc2hZtD0VgqmUlFI52dfrK5sTmabk422tHGSDSU6vT8p1JpO2rHmuLpaDTV1NDZ6UcbErFkImbbTVE7HbULpi/tQddcXYTvFUvXmLsv29Uw8AW2MoSnrtU8CdoExnlbsgylZ1n0PFKlX4u4MvPJzyPLEZ8yB33XAA4a+DSXIXzIp4LQjyrLroSfwlLnZsH+uCvir/IIw8NrFR/em4TGzV1BWHW2TxnhV0HcU5xlPR2D6mklCIfP8gkQaSq/Khe/ahe/LlZb7tCvBsSbg+LVEpgffhEePU+hyhbWP3w2MK77EKtrASz8dS0YvyvC6lYAC39dC8bvhrDqCmDhr2vB+HUIq3sBLPx1LRi/O8LqUQALf10Lxu+BsIIFsPDXtWD8IMLqWQALf10Lxu+JsHoVwMJf14LxeyGs3gWw8Ne1YPzeCKtPASz8dS0YH58n2bcAFv66FozfF2H1K4C1CGHB+P0QVv8CWDMQFoyv4tYRWLh/HgDu74/+WaVfi7jq6p8HWO31CvWD+8OBBNcg4Yft1kAinYFEOhRWHSNWd0asHoxYQUasnoxYvRixejNi9WHE6suIhe1Wof760uy+/279tYoH6y4MVwHCUH00xHAaD8CxeaFxwVmIM5UmNcZUZyjhMaZKF/pVIW7Qrxr4dUV+cIyJ7X4N8OuG/OBcU+UHjjHx3A7mDecVcqQ41yI/OK8IID+ooy7ID/YfVcgP6k/lW8ecujnVmAw1RexUIhELxRrjxcyp8RwLxlP9Ma7nkzvIs61L2mUET6o/VunXIq68fFr7Y2quQM3nlH7q9Ogn5Ga/6gj9KD7dtfAJRVRdCRJpK66q34PzcRi+DugQhofXKj68twvVV2q+EUR+0uG5OjVHgvfK9xMWNd+CelNlKm3KBqQLWF/LHP4rXHwPc4Tlie16V8Z0IJZaa6Dak5TJud+hklwkrPLRnciHShvWK7620xDzautU+rWW1rZsu9VhqB889wgSXINW+zq8LNsarlD9hulQWDt9irWWEWszI9Y2RixOfW1kxNrCiLWeEauFEYszj1sZsTh5rWbE4myPnOW4hhGLsw3tYMTiLEfOurqbEYuzfm1nxLqLEYuz3vvV5nDmcQ8j1hJGrL2MWJz64hybcNYvv44LOeu9X8dyqxixNjFifRzGcn6t95xjkwN9WnFYfh3L+dUWco7lOG0hZzly6suv46+ljFh+HX+tY8TibNucbYhTX5z9EGcb8qvuOe0X57qcX9eGOOvXJkYsv44x/dh3yGv8zIqj7+jhgA2v3Z4NU+mUEZypZ8pwr0mN1T6/nM+VFX4vTfgq39Q+VJgnlT5+xqz8qf8KC/uptGoRFnPebLe8uT2Lhs/doQ6csHoWiVVD+Oko06BLvmH6dS5cqXzUMeokwIhVhbCo9k89v1Xhqf3TVD1x2z+tyhbuJWQs27Bb2VJ7sOWeBbUvK5Vunjf19BlTLeQqkB6U3qagcOdnW/WA20ZPBywL/Z6C7lUAPOg6y77XEfFUOM17hsJe7aVKv5bQiQ572d2jXqn9Rt2RzmH7uSHbeg3Dqv1Mbu/mUP2N3r63MeK1fFT6ndWfudl16XD5eLHr0i3PtoYrxRZLdycj1jZGrLWMWKsZsXYyYnHmcQ0jVgsjFmedWMWIxVkn7mDE+jjUiS2MWFsZsfzatjl1z6mvdYxYnHncxIjFWY6c9X49IxZnvd/AiMVZJ/YwYnHWiQPjr4+Gjebsa1cyYn0cbOFeRixOm3M7I9YuRizONsSpL84+za/jQr/2aX6dW3HqnrMNceqL00Yf6Ds+Gn0H59yK0xZuZ8Q6sKaw/9oQp+4583gXI5Zf50Ocut/IiOXX9ULOcc4BO7H/xhMH7MT+071f7YSX8VcXcA+fvUjtbVBYvQpg4bMXYXwv5+xBrPMRFrXHQ8Xr45AOPG+EOltPujqrfd7Kcv9rCHzu/UowPZUneA+mX0vkUcdzdurcQupbw0p3fQmuQcIP1i3oB9PpS6RDYfVEHGA976TyC3e0/Hrq4eNafpT9KLb8nM6yUv6Wj3VetR90XlWizqWbl933nzrXE+/7ozj0ITgEifgqHJVOrxLT6eUxnZ4lptPTYzo69IZ/U3u7VFmqNgLLeXLuf6g0F1X1qx/iBdPVdHap57ap0q9FXHW1TeqMWqgf3DYHEFyDhF9fpFcN5RnZj2fjei7Pj8rZuKr8ehB6xeeHUhwGEByCRPwBLun0LzGd/kQ6NUS8ybn/oZJcJIp1rNKG6Q4C9/dH/VTp11rty1xH/RyE+GD94Po5mOAaJPz0l2coU0fkAZfnYD3681yeKv1aS2v9ypfnYMQH6weX5xCCa5Dw60B5hpMZO9KQjjWEGhPRhlRjJJwKx0KpaEPGtuN2uCkaj0QyyWg8FQ9HMuFYOFlH5AGX5xA9+ot6LU+Vfq2ltX7ly3MI4oP1g8tzKME1iPykU+O7MsKvgrhX7oCF+4RSsKRT3xDR2A804LqvuMN0Yf72h91Q6ddaWuu97VZmUD+4nh1EcA0SfgNQPFienaPzSHNHda5prOqqc2q8VIzOpVuRbQ2H/SqIe+UuWKsYsTYyYm1ixFrLiLWGEauFEWsnI9ZWRizOPK5mxOLM42ZGrG2MWLsYsTjrF2d75KxfnLaQk9cWRizOev9xqBMbGLE469cORizOPHLqfh0jFme9386IdcBOfDTsBGce72LE4hxP+FX3exixDrSh4rBWMmIdaEP7T/ecc3fOOTI+awyuIeHnYMWuS8L4KhyVTv8S0+nvMZ1eJabTy2M6PUtMp6fHdKpKTKfKYzoH9NY2Ha96+6i1n49afgaWmM5Aj+kMKjGdQR7TGVxiOoM9pjOkxHSGEOnUEPEm5/7bkYgdCqVidiaViTTEmsLNdmOksTETzcQa49FUpiGaSMXSdjQRCTelY6GMHU+Lp6aRZKwx05RKNmaob9irb87JtjxlSNv8qG+Iwj3F8Jud5cAfhv/ukFbMi3PX+JulFriuQXhlFudzkrDn712r9GsRV14+rc9tyhEfrB/83KaC4BpEftLh5zYVRDoVRDoU1lZGrF2MWFsYsdYwYrUwYu1mxFrFiLWJEWsjI5Zfy5GzrnK2R05eqxmx1jJi7WDE4qwT6xixOOvEdkYsTn1x2i9OXjsZsTjLkZOXX/sOznLk1D1n2+bM4x5GrCWMWHsZsT4O/TZn29bR16q5MpzPqe+p90Dx5HVX5FcJ/CAG9IP8Kl34wfiVDvFwPtR8VNf7cwq/ix78/DcBqgldwTyp9NX8MgDClzn8V1jYT6VVi7C4deeWN8gf14NqwAeve1JY1UVi1RB+Osq0yiXfMP06F65UPiqRTqh2VkboRN3v4sILhu9BpK3iKh3WAD9GHYbddAjbokq/I99TUHobj8KpMwfKrfZ1sNoBy0K/x6N7FQAPuh4Ig7KjuD07lW/QIb50dS7p1BHxVP66Ao7DgH8XlMYwqz3HYS4cYXwVjkqnrMR0yoh0MBa1Zird9dlWfxj+J7l1UpmHufVtMesJflRZqfvDifD1IIziQ+lmuId40tURaSlOqh2PAPe5bSFMT/GF92D6tYirrj5pBOKD9YPbxkiCa5Dww3ZhJJHOSCIdCkuVZw+rffni769Q9a7eJZ06Ih29dSEcxbqETvkdQuRR+Y0CfrB+YFeBfsM8yTb76vBWXBwO84E6V9z8pqd65DcKhD8/29ZvNPBT7111RIc/K0KHsKwUb2VT1bdm3slt8Piwrx3aNow6s6BqaGuY8qFt06gn8lVntW/r+Ps1Iwk/if+LHB/V9mDdw30f1HcFcc+t7xvlgFUJsGoAljrDKIDCj8jpQ9XN0QCXr242xpTexgBOuC8Zqyltr32JSr+O4KN41xJ+lSVwzSTjoUiosTGVbow2N0QzZQhfccX38HhgHBGe+oaQ0vV4S4uuw/nvLGZb8ccBvUpXCfzGIr8A8FMcZb2/pr4t/3Ga+HvRP0w/SPjBM3CKKcsg4Tcly4MF7QEHVnUHsXpZbdsTtDmUzcT7sYq1mTD+KJd0epaYTk8iHb02NRynbKpylA3D3/wc55B/7Kg+XeVJts0JI1pxcTjMB+pccethtdcTXr8Zjfjge2771lQ4VR6w7jGWRxPWuUXkfxyRR+UHbTLUE3ZUeag8yfKYXER5QJ0rbn7T02jkB9dILsy29ZsA/Iodp0IdTutgncY61DOmCSewniyC13hCF1hP8rrYOZHKk9TTcx2sa+ORH6xrilsPy9mGdbQP60Xkg0qnZ4np9CTS0Tt2CTdT5a4cVe64P5jokH/sqDqh8lRsfwB1jsudspVlVvt6X0Hcc+sPcBvVMxZuPaMG2iSc/4lEHpXfJOAH9YQdVR5w7FxMfwB1rrj5TU/jkN8kEB73B4cCv2L7A6jDaR2s05A35F5p0WObi7P7/gdQ+HlgDWMOWsOAazoqbRnuaRRuHMFbb9l6X8dV6ddaOm1k6zrueMTHyX5QdlPFDRJ+8DkdrtMVxL1yFyy3/gm/n1Bs/9SPSMdv7bwf8oP2ENYP7Aq15WLWcam27Dc94XUraA/xOi6XPSxmHZfqU3C99WoPVfgtaN1Sk/0K9UL5gmlR8xi/21U98xF3u0rZoWLtKpwflGpXVX2kxpn4faxix5n9iXT8Zi/6Iz+ucearJdoEk8aZfrCrVN/kdUzodTx6SXbffzwefR6MR58d6szrEJD2Pw+MR7EzajyqyrKH1b6O4fHoIUQ6h7ik049I58B4tD0fqHO/2s1DkJ9J41HF3as9VOF/5KPx6CFE/vU+i/JuV1X6tVb7+qzDrlLPjSg7RD2DUXGDhB8ej1L2ezyRDoWFx6OwjPB4tNjnYP2J/Gh+vlPUswnIkerbYP3ArtAznGLsKvVswm96ws/BoD3GdnUi8CvlOdjPOtg3Oc2RC40JRxNp6C2HUNqr7cJ7gDTZ0rztGoP4OLV1uYddnXM0NT337HnN065JnpaeP+eY6amzE7PnXpOYdkwqNTs9Zw7MDUyhjsgtri04jLoOEvchxrgCucBf6oOlPA5hjS+Ahb/UB+OPR1gTCmCdj7BgfBgX/g5Y7Xmq3YHlHnBwy6V4XYh4QWuJRzOTCmDdiLBg/EkI69ACWDchLBgfxoW/A1Z7nlhfbjhS7AK85mfb8gqB+DbCChfAuhlhwfhhhBUpgHULwoLxYVz4O2C154n15YYjJVqA163ZtrwiIH4UYTUUwFqAsGD8BoTVWABrIcKC8WFc+DtgteeJ9eWGIyVWgNeibFtejSB+zCGeky2DtoFquzHgT9VVWPYwz3XEPdy7xsF9xt4s5bV3VenXWu3LRUfvGrfa6w/qB88MmgiuQcIPzwyaiHSaiHQorHGMWKMZsSYwYk1kxBrPiBVixLIZsWKMWBFGrCgjlrJj1NgLn2RX7MwbxsczPVjmfDYnkn/7AfYlyim/OJFHyvZAu4gdNZtTeZKzuSUjW3FxOMwH6lxxU3qC9Xl/6gnPMmH9Uv2y8jsM+BU7I1b5lTp8vAgdwvoUR37jibh69et9lU6lX2u1rws6+mJqDE+1YaW7MME1SPhhG+42ZoLpUFhqXEfNI/CplyEinZBLOoMIzprbWhjrEjrlFyHyqPygvYf1A7tC7amYVTqoc8XNb3oKIT8438KrdHC8WYpNKmaVDpZVBOBjHcJw8E13av5M8SojcEIorPIrJ+LiU1mhHz79lbIf8B5ub4MJvnVEPGyXoT3YH3ZZpV9rae0nbDd7SemVagdhpHOqjZQhP5hOhEiHwsJjALd+Vc/4zvsXQVX6ndWvUv0Q9UXQzqjfTuVsu/CJ6uGTf8uTWr+ixh3ybYgqq30dotbaMO8GgK/ueRnz4HXxYtctIRZeFy923RJi4XVxSgd4nfJ+8Jb+loPahlFrujtAmG25a6rPUnqQ4e5F4fD6sHQ1Vvvy2R9tX6Vfi7jqavtUOUL9wLpdbbnXMVjGTs8bJhF5xXV+YgFOuM5TaVF1QoWj6gT1VFKGe9Al3AQiHMZQ9Rc+/8KnVKiwn8hhyLHaf0bS6SoM6TTvIvFcZ/EuON27Nai1HLfdGvtz9zAHll93ZOAdXJ2x00Al2tHdGvIpuNpJIp6Ci+ffUxLTrkkl5l4zY/q56Vnz0nPmViLYQxzoqN94g6pKCuJYLnSlK0d+o5E/fBxFOS8bI2CV2h/TEpV+Z22MKPToHpuJiQTXIOEHN6k4dVcTiXQoLFVXqJe38EdFin15awjB2W+bQIcgPzg8gPUDO87Nsgde3moN09HNsrCs8BCsHoSfm23rNwLEG4XiwcPqFD48PEuFgweW1iOMg4DfCOR3MPAbCfD/MGzfdQ+CIz6cS/lJV0Hcw22yC8EHYzkdzqXKOYDCl+cyUmO11xtfnW09nMttKDpKU9pe+xhchyAfxbuW8NNxOJfXw4FUeGrTrtvhXHqGgfThXHBTqXSVwG8U8gsAPzh0w4dzaTpELuxF/zD9IOGHD+cq9qAn6pDEUrGgPeDAqu4gljqcC07zlM2hbCY+jKVYmwnjj3BJp2eJ6fQk0tFrU8MNlE1VjrJh+DCW0Q75x47q61Weij2Mheqze1jt9YQPYyn2sNoqgqsqDz1LDOFGrHOLyD91AJnygzYZ6gk7qjxUnoo9jIUaJ+ntj8Mxar5puehiJPKD8xZ8GAucTxc7flX5LfYwFlifxiC/UURcv74opae83V+UovoIqg7g/hb6Qf1DP5jOGCIdCqt37pp6ARXbpGJfQK0iOPvtAEdsk+BSZLEHBsIDHDv6Aipee/CLnvDyJbQ7eE5NHZLXER0WM6emDsH006GLUBdYT/J6OLjGrtAy73MdtN34MAZqCZh6hQiPUYu1P72IfFDp9CwxnZ4e0xlRYjojXNKBftieFjvmriI4U+mMLDEd6gMLfmpL1BjJbweYwvLA7WwkEVfzC5mex0j4hUw9czn3FzKpeQ7VJ6m41GHauE2XcjA3HiPpbtMmHaoM6wd2hdpTMWMkqj35TU94zZza4sNtk4oZI8Gywo/c4Xq6ugfH9vjQOBV+aW49XdaRxQe3Ta8epAGfGXwJhRtB8ParPRyhh4+rPaTsR7H2MACuS7WHeP0S1it8aFGx61j9iHT81s7xoUXQHha7jtVRe0i1ZZPGaH6wh1SfguutV3uowt+Hni9qsl/koUV4Le7AOFP/OBO/AlyKXXWb0+FDi4odZ/Yn0vGbvcCHFh0YZ350xplex4Re7S8+NE6F/yoYj77sMM6EPGS4mmE0fxVWugN2k9duco5HVVlSH+fE49F6Ip16l3T6EemYNB7tLLsJde5Xu1mP/EyanyvuXu2hCv+ej8aj9UT+9e5R8G5X8X63ej18bKrs3OwQ9WxYxaWe5+LxaCnPht3m+Xg8Wuw8vz+Rjub9KkXvw8DjUarP8WoT4H6Vjs7zFTe/6cltvwq2q6XsV4E6/FkH+yZskzjGhJpsl+dDNLHt0j0mpGwX1dY7fogm3G2Ac4trCw6jroPEfYgxukAu8IuTsJS9WFmIhV8WhvHHIKyxBbDwy8IwPv5sivodsNrzxIf2ueHglkvxwodoQmvp5dBRiIUP0Sz20FGIhQ/R7KxDRycV4IUP0ZwI4ns5KBRi4UM0qQM+FVaoABY+RBPGx4eNqN/4xXPpsL7ccKTYBXjhQzSLfXkfYuFDNIt9eR9i4UM09+eho5AXPkSTOkwBx3OyZdA2UG0XHs5A1VVY9jDPdcQ93LtqOrTS8yGaKv1aq3256OhdqQM0qAO1lO4aCa5Bwg/vGqUOh20k0qGwRjNijWTEGsuINY4Rawwj1kRGrEmMWFFGrBAjls2IpewYNfbCh2gWO/OG8fFMD5Y5n82JRJUNgX2JcsqvgcgjZXugXcSOms2pPMnZXDGHaEKdK25KT7A+70894VkmrF/4EE14MGexM2KVX6nDYg7RhPWpAfmNIeLq1a/3VTqVfq3Vvi7o6IupMTzVhpXuDiW4Bgk/bMPdxkwwHQpLjeuoeQQ+RHMikc5El3QGEZz11oVwBusSOuVHHRSq/KC9h/UDu0LtqZhVOqhzfNioX/Q0EfnB+RZepYPjzVJsUjGrdLCsQgAf6xCGg4doUvNnilcZgTMRhVV+5URcfIgm9MOHaFL2A97D7W0wwbeOiIftsqaDzzzbZZV+raW1n7Dd7CWlV6odHIp0TrWRMuQH03E7dBhi4TGAW7+qZ3zn/VAylX5n9atUP+R2iKbO+u1UzpNc+Gg6JDZ/GgO1fkWNO+AhmrAOUWttmHcY4Kt7XsY8eF282HVLiIXXxYtdt4RYeF2c0gFep3x62L7/Uof3DWsbRq3pPgTCPJC7pvospQcZ7kkUDq8PS+fXA3Q1nXzmeoAudbgfPETTqY7BMnZ63kAddIrr/LgCnHCdp9Ki6gT8TDSuE/Ug3BgQ7hmXcGOJcBiDOkSzHvmpsM/nMORYDR+iWW+1xZdO8y4Sz3UW74Kr18PHdRcc1E9Hd8HhNdlSdsFx7kT2646MeuTXGTsNijlEk3qO0oFDNOsd6Kjf+OBKlVQph2iORP5eD9F02xgBq9T+mJao9DtrY0ShR/fYTIwjuAYJvxHg2qm7or5sT2G5vaCOD9EcQaTj9pLBEIKz3zaB4kM0D7xk8NF7yQDaQXyIJjzkEh+AWOiQywDCD9Tv+6/Krh7EZ3z8kML1RqUB0x6pKW2vthZvAqQOkaDscCmHSYbTzcnGRCITSWZCyUQmXWa1t7ludliFpza0DSDC6z0oLJJQ9R4eJom3wlUCv5HILwD84OFe+DBJPcO5SMKL/mH6QSL8vGxruGLKMkikgw9t9IqlDm2EdjqnQtLG4Laoxw54H/eo9GsRV13jnnqrvV4rCb26bbqlDtPBLwkVOx6BWMrud/ZLQpADY38epcbfyim/Q4g8Kj98oK+6xo7qs1WeSnlJCB8I5xc94XZOHU5LTVuLHfdAHRYz7oFlhQ9lqyfi6tWvd5uExwCabKTtZiuoNuw2XqH6lOHgutT+SZVlD6t92eIXbCqJdCpd0ulPpOO3toZfsIE2CdYP7DhtEtWe/KanSuTnN5tE2XXMPUCEHYb8VNhjc4Hk3CuTu6baSDerrd8w4NcVXMN04ZYBFV6667M0z5NyF1InrwynMcsdMGHZSAfH9bBNSlcJ/PjqWtKWvG+sb+WBbWMg2zZPlD2jxlgqvNvLQFBHQat9vca2lLJx9eCeegxD6ROuN0lXCfx06xNyxPocXiBPWJ+U/qGelI6o/uQghHUQgQV17KZPxXF/6BNy9KJPqh90GwdAfSodUXOGgxEWpc9h4N7piKuKX0WEh3gBFD4JbM6ggW35dQPxcV3oSmBDG+rWzmqJfNQhPxhX4k4Z0npfuupsW9wP/4N7AYD7Yf5geORXA/wqs23Tqc39rgTpQCzFI4DCzwF9yYd5AHFU/CCRfhVKvw1v4h6sgxirgrinwkudTstxlGVZi3CU/ifnfoeKdMmGxuZktCERStvyZxi/tA+5yPQpPUEbIZ3SNSyLKiJvART+FtDHLwDt/8OwRHoy3GqXcGUO/z/EIO5VZtveo8oI1l0VXqVdm23PUfl1BX7QfknXLfcb6gtiKR4BFH4lqruwvqn4QSL9Lij9NryJe7judiXCdyXCf3gAZI6jqrcw79xzvA/TRPjwHua2WmO7SjdHm2LNTcmGUCrUZDdFCrUrade75uy623qi17qM534QS62nqjkNPHCWc+uawq9G/JjwbaWngNVeTyrtLlrylsl4KQeYfi3iqqP+w/QUH6wf/NyiRo9+0nKrlqp70H5UEbrBPKoRx1pNHKkxruJEPVtRPGSYMw5py7FcE0e9bTSTf44I5/5zsvv+f7gFsr41XVg2cM4M6z3s22H4h0Hf/iDotxSuiq/sVFfgX034q9+qvMqJsPhZTzXSIaVXGF7VySqHvFahvKrwj+fyJ7n1HEhjQv1BXuUOmE8CzLmoTOA43a3Nq/BdifCwjSk+Paz2bbMrige511htHbxHlU8ZCov7YPjcrxqFrXZIB+uD4tCFwMH9JMbEaeL6IB2eI1UQ6cA2Bfv8GiJ9xv6hgeorlVN++OB66Afznsi2hsOOWkNUeZL5XV/fiovDYT5UW+McG6n7AXAfp1uBwlahsPh5JOQYYOAYJNKpQrjVLvzLEE4lEa/Ootsj9d8r3zKCL9XXlJoOxGrOtk0HljPs035Q34qL7XgFETebbfWH4X8K+rQfe+zTsC2BeUhmW+9hm43HsbhN4nUm3HfhMLAfh+HfArapJ5qPVBHpyXvvIH1SYwRq3IfHCIHhrZjvIn1SY4AeVnvd4Dpcg9KC42PVv2Ad/AGU62/rndNSeq1zyaO896d6OhzkAMNhDKrvVBhUu1bxehC8cNvDtqPKJQ2qP6PSCCC/UsuH6rfhWIMaw1D+sD+H6eB75UT4QuOPWgdsCreKwKHsfBfkV0b4YRsG8wttGB6bUHMyaBupdudUdm5jb4q7l3FVlQt3Sn/QDnGv5YTiITuUjDVkMnaqMdEcLbSWw51+uKEpnmhqDtnhTDgciTd2dvqN0UY7Hk/Ek43JTFM02dzZ6SebGjNNkUizHWlKpZvsTs9/OhppztgZsZ4XyYQicbuz0xer8+F01G5ubrDTiaamTDFriZR9hn0FbEPwPmx/as8A7q9H5PprvWtt9EHCXvo4Kn+UfTnfIX9HgfHI6OGF03OzmVRfWI78oF3EZZRfP/eYBxV+Uo43XDeg1r3gmpt0ldm2+Zucux8qzUWpZ7twvh7Its2321qFdHic3I0ID5+B4jENfHaK53IBAovql3A9q7Loca/Cw/WsCZQRfrYL63wt4g7zjscKFUS6bmsckucFqD1rei4Qo9YU/r+9awuRM7nO9XdPj6QZjTTa0V610mpXki+5mL5fwkKUWBpp19hZm7X3Eid2X9cCRUq0UnCe3M6Lw27sECfE2Y3tQMAhBEIeQhbsEGICeUwgLAQSSPIQCBjsBz/4xWCwavSf6a+/PlX9t+avvmj/gmH+/s/5T506VXXq1KlTVZK2jG7fIAz7Ccfssa8YYdgOZo1vFVlYvj6VIA5K0xOsCzS/n6YnMNZrj7/hJF+L6LdoY3O/1XySiC99Z9tM1hu3V8121PoA25x5T37afAn7gGtNDnUC+hReoTgwzaeA37K+FvzfhDHn0zTmoH7i9qLpGebFGF2PJfE1aXNXqRdtnS9N32VE+Uk58B3mv2GC6q8S63uUq2+tLZB9VBV+tDmvVs92be6YmawzbX6NflY+zlnzfWq6je0jTbdpfZ31gDZn9fkmfH0d15eS2I5aP+Z+jvi3oR+/6bEdXX4+Y/x16KtzlC/7YrT1Gp+fxqfPD3v4mrbGxHxpa0xGyXtaGXztTrOvFzim1rQxFcvOY6rPtrWJ62BLwdfs3W3CR5n7fE9av9wkWNJ+iXbom46xFMuBepb9Q1r/xDEax/WIeME80H8mR3pHlMe6go/0CoT/R4qtzzRF19j0heEkTeYZ36NceN4ueF8DHj574d5zkj2MgWJXEu8n3o/dVOQRYnzX5n9aXHHg+VLX1w80u4/nV1x32IddcQi8zoljA+p99tt/K25b20TTJjk/JFJg2poWxur9+TPjZQu1tsr7alxxMX9NOgr7uxYbIPqD++Lfgp3wN2QnaG1/0/h1lhaLw+3HFc/COkvw/86js7R5DvL1haFO8x3FL+VrF1r9cVtGfN96obZOp+0lwv60R3s4STOwjdDTbASUD9sIPlnYNKv9KO1jm/BRjlo/Yh+or63a5Iudwf0F0u9S9/GXSqVBvdpp1rvl4qDXnbePvzpotOuDRrFW7lX75V57Fh+/T8aRIuPjHhkntYeYVuShVZhCi498dPVB/m5O9kniI+jYPgkTE+q3T1A+7BvVbIVtBcZz4Fn9R5rPMw1aPDYjbVff0ObsKCNjdHsHZfux4b3/YeORix1tDmiozEcVniMFX/NhY/xyF+x+xuM8UXZHCYZ6fotgOI4cIxiOI8cJpvkYk/RBm3ztp+AoVxr5aGOfNl4fNB/NX8fyTiMfzReo+VG4f/vibrR8IiUfbS6KtvdPntHzdNmg7GsX/MfOjWjKJk/BERnlAGcrfj6i8J6iHmhp6yuGZIM6iH30uM7FbR71B7dT9P9w2zoGPGBcNidN7wiepfnFBHpHk3WgsXSpZJ1UniIL+913ZtDj2F6lTDif9PUjzJf70SnoIx88N8LHfIxJNpeb5jfmuZzmN17WcVqre24zxwDGbeY4wLh/4tHOKBNO0+yCpP2T61nT+65zBbhdoe/3JzP6aCMljyTzm8IUWknmJD5aSedK2fxmIq3U/GYtRVoRlQdlP23uP609cxv0zbHxuzm1wcRr/NwGozD8lJLK9X7bYJrtZtlphdzPrvUbl8/+kzRmyXcunz3PGwT/VbB3Xo6fk+774XJynhxTOC2un+0nXyw95qXFcPj2dLhihlF2WDaJFeG4iE4sr2nxqItcg5+nf11kpvnXfXGbbBvmFZrY5jOfWOYTy3xi+v+k+SyzT+wNx3zM5RNj/Sz434Kx7csOn9gfAM7bmU9sL83DJ/Z25hPbS6vgE/sr6CPvZD4x5zj9IPnE3nHoYMmDdXBSn9gbig0neLynCO04ibfi+cvnz49o/yPpeKH3z9B+/+ncOJ9Y7leG4zAtttm+uxPnqeku+3cx/l08UGq0fXZM2H0K1W4SuwLzn9eZYEn3KWg2Ksfsoj31e8MRHsPyyruch9bXUqT1ZynS+kqKtL6YIq0/TJHWGynSejtFWmnKK80ypsWXpgeXpa2+lSKtNPt2mm3iT1KklemvTH+FLGOasv/9FGml2e6/niKtNPv2svbHNHX0so61adbjl1Ok9V4Yh94LZUyTrzT16rKO27+bIq00+UpTXt9MkdZXU6SVpm2yrGNa1h8XV8ZlHbffC/O0NNvEmynSWtZ2/6cp0lpWX8c3UqQVUkcLLq5tyNkDNt2On3mN4hatCQTyy/d8sQBh78GoJj7bgNf5tbNqNxTYQfacdkqDSr/Y6VTLnV6tXq9HRF945Xfss0x6/4DIejOMrDtaHNkGyNWmNYAdIVgBYMKjlT3flR5mDbXaSSJ/zH9bweczFpLWpdxvfhjy8Z0Pf2s4DltXeMB1P1+cmrb+iWcVDM+PeMXvuJ3l6VuER5C/9h6fI3qP+WJ+rw7Hv+M1R+aFy5tX+NRkkVNkocUv5IkG9lOMRbV1/IDFj/eT6tlljR8PfIZMj9sj8rNsZ8j8cdzGtfg+VxyyUXiQvE3My1eo7yw6Hv2t8+PfyHdJz5AR/G9CPMfX4+csHn28bHwOjeD/ZSwv2/aWIB69b/l4kOPR3wJ5Z/Hok2XM4tH1cqWRTxaP7tYBacej/9t5PU9XPDrrZ8H/Hoxt/35+HEdk9C7g/A/5FJD3FPVAFo9uJmWdxaOPcJYtHv370Ed+TH0zi0d/MOPRf+zQwZIH62Cx9afFo4tuT/sMvEa5W2tXaq1it19rtOuNWc7Ay2zIEU5mQ+rlSiOfzIZ065K0bcgzF/Q8XTak65yv1oURzacvjOOIjM4Bzofi58yGHOFxSsuGZFlnNuQIZ9lsyGehjzxPfTOzIR9MG/J5hw6WPFgHJ7Uhz0C/33s3HOGlWIdlKU9hOOJZZLM2HPG9DnzbdBhggie8HgnDa1F43YjpS//EPLEsOcLn5wK9+wzUJZZRyoHvkL7gbwJM8PPwTniU9rsOsM3hbLQOE61DB6AlfG0r+Ifuky+N1jrROqLQwne4NvXxuG5CnC3ebvRb1Xql3K0MWu1msTnLvIrXksfKZ8bbTsr9IfG5dPJuXufS5Ykflo88azpQvuU1FJs4dkM771C7f2RetLT1TG4Lge5kSXw+nOS/YYK2zZJPrnlFrtocm+8+w3kq158WR6DFWK0KLfneJm0eKPGDmk3LMuX+jjBt7X2edyR/ieY3h4nXi/Hv4gHTou5I/guYE7x5YXp+y3hH8ldjvqfFAGR3JCc7+xZlzvEj93tH8jegjhZ5R/K3qT8Hitda+TuS300wv8zuSB4lzYcqfWfbTNYbt1fsA0cIhn0gjTuSvw1zFW0c1Wwc4VHqQosftYnHUcH/LvW7QHcNq+Mo6n0uX4p517V1EUnaOgz3eW3c1PQB93nN75a0z4ssZu3zmh3oux/Xd7+r1ge4f2Af4PENxwHXHaU2yT6WiGga4x/7tFjMafNt7BO4JvIf5I+T/NDmwW/Z5hH8H4Dd9p9kt2lrqNk946P/2T3jk/xo9ZzdMx7+nvEfQj8+/L7x8mt6NCL+jPHXoa/OUb7Ca3bPuD5HXaBdmt0zDjCcy0l/8Y1fqGd5bUvrnzhGt+J3kmcovzSvA6ZJ/+5yQZPXzFPmvxLWd1ytBrbbi9LeLg1H9LX5TZ7w+BsLZ38n4oSMkWgWq7WwcqqWA9tvlST9GPPX/M6R47/QYpjkNa876bWy+dZx0rTXNVqLrFPX/qM9nOEIliPYGsDWCYZjIc5tzwIe90G+5wbnyV8ajmj8LND7ufg5ZIyZ6O5QOsOmHYV/jhvAtXttTV1krsVe5AmG6+drw/F8JM5B1jCYlvDBcRE/E//W4hZ4vR/z5/X+Mb6VdyyXWeIDzsXPm2bkM6gAPVcf0daltXkV2qIB+3NZeNXWTVG/SP7Wjnw4fn799s1b/eduXP58v3vn9rWbNz7c7n6ubyjx4nQEhXcNzFhQjUYevteSrZCQRnyjOQoOkg5RMJMOOcy/QPjN+HfawSWDRrs0qLQH7Vq716t2p15cfyp+Xm2juDo3oziQ0VoNvIClGsWawpE2vDscyXJ3OM6T4FwBnCuAY5PPcNaCmC4TDPvSLsFQWUm+VgGfMKNnafdhB/TqQgd0GXhEIVvlfDZ+vnHz9rXB71y+8Vt3+nf6vRfudK5f6+7eudG9p6ivXzeU2OiO6HeOfrNOXlPocMLvIijDsuvqJ+Lfi9bVL8eA1dbV9dZqOzCCjwX7uvr5oRlrZ8boDgxxhOGz8KTpYaGr6eGPEExbkObJkxi+Min4KPAQEexjAOOJ4K8Mx3lH2AsAYyfuxwFWINgnAMaTSwye4wnriwA7TLBPAowPLfsUwPiws5cAtkmwlwF2lGCvAGyLYHjo1TGC/SrAjhPs0wDbJtivAewEwX4dYA8R7DMA2yHYZwF2kmBtgD1MsA7AHiFYF2CPEqwHsMcI1gfY4wQbAOwJgr0GsFME+xzAnozfiZ44bUawFG2PntA/E4D+3WGgu6PwfwbKZtOHhyHyHo1Bl2L6Jj3aRaF9OQzvFaG/G4Z+WehfCUO/KvSvBqFfagj958Lw3xG7+O9jej7HctixvNSMKD9jdMf1vhPMBLVdvAfhaY5rOxbJWGUdPu3X+p/ot8fOUUVyjypFw6IjzkGmHDZJ85xlymGffWexRWaSl7zyzrU/A/ECTw1rWmySJI7bYbMJTR6bUI1z0uLMpEy2m/0D0GU85gdlLrwdN5NyYnlqsV2aL1WrD47HCVQf3WWLR+T61uIRk9Y3rr3MUt9aHEBSFSRtUmsfBfpOi5GT/LX1Kd8+Gca1z1K3J4j2xfh38UCpVBZ5PWQmk8B2IG9tWMHyYEK+bf39COgyHueJ+mOHYFifJwmGbe1hgqF74RGCoYvlUYJhLPxjBMP4lscJhvEtTxAM932fIhju+36SYLjvW8zjI0QnbXN8i3jBtEW8SN7yzElrI8L3rG0kUmQhMOwvZwiG7q6nCIZt/SzBTgLsaYI9DLBnCPYIwM4RDO2W8wR7DGAXCPY4wN5HsCcA9n4zSlw3rrGPxyubLsb/y71av9hqdprlTrvS6FQrnVarXaqU6qVSc9ArF3vV8qBWqte7rX5rUKoMOrV+u15rt+q9Ur/Yrvc4r5zCl+Qr+vGUwiPrWPz+lBlPTEOjY5Q8csq3zNuTDt5c/GMf0micIhryfNrDPy6l8Vh2Mf5fKVYq/Xa5Wu/XivV+s9XstxqDWqPYbQ8GvUax2u3YCwDqxYqts0a52Cm3+qVKq1/rlvaUgOR1hmRzWim/lOspgLGrIK98/5QZT0yD6ZwmXOYNv80l5A1xcg7e8h76XG9nPfznpvCP37Jszzr4d9kdZ80k/2cU+vKs0WBdwTokB+/XFP40mqcd+eL7U458Tyn5+tqj1uflvTaO8Vktmrx4LmSfNwiGtgWffYZjPds5OBaxTYLjBo99WpyrZgPxGW1okzxEMBwz2XbC8Y3tHByL2JZBvcdjNNaP69yzyIy7pfG3fT5BMLQJ2DbE8ZvtOBxrcwTDPuE6B84+8zl6aDdGBIsA5toPY583CYZ26jbB0G5kmxntGrZv0QYRfbcKS6ffiX8veukU3YER5C9J8ymgexJ1y7rRxyahVyD878b/LQ+tSKeJckW3K9uCbNtcjP8XD5iEH99+UK2Mgv8vUMZnY+YW53YtdiPKz5jVcrsGDgfqcH0jP8t2/8i78X8+i9OmS8NxHma5f+RfqWwcfqj9F7r8jv2PWp8JHJZQ1NqMSY9+SbMJ1kCe/wXvWVfw/NAm0a8Fwv9foPnf8bPmsxcZbxq/TtfmtNxe1h34rO8E///i/5pO1/YOIl9XhzrN/weav0g0tf2BWvuT99P2B/J5jr69ddpYIPYdxvVjO7dpDWBp6nZbjl+mMWZMfwyTy8Imlp3vHAhsH9o5ELzXDfUA77P0tVWbxP+dtN9pNk5eySNS8tB87PkE/CKtXaKl8av52hFP6zOIjzQ0+oLrG2+R58vDcZ5ddg/qVRetK0TLFV7L/a1g9PJr8fdIQ6Mv7wPbD7Ukegnz1/TMYfpOu+vQJxPfXUsLkIn3vk6fTLT995reOZxAJtP0/pxl0vDpVJ9MsNwb9N2GUl6fTKbp8znLpCll35xRJljuTfpuUymvTybT9unPWSYtKfvRGWWC5T5K3x1VyuuTSdJz2OYkk7aUfWtGmWC5t+i7LaW8Mu5pMtHydt2FgT5hH882ie1/3JOnxjOfTabJQ8ubvzPEK7/3+RfzBNPsEM0HzHNp3x5ozR7XfMc+36PPZ+nz5fr85lL3Ic5FrtbajW67USq1qqV+tVSb5tNL3adYLff7tWa107n7VOqV5p1/t1bvdO8KodjfW+srT8tf2x+L8zGbDsW/cQ8u4gu9AuHvxgRsm7kaP0u/Kij5WbyXPHiR4/8eDeXd2nD83ZHhJD7uWRZ8yXtD4VFgeEZ4gfI5Gv9GeSEt4aNA+C/GBKROcJ+xfK+dUY5nvnNeWv68vqmdj76p4Nv6+Wj80f65rJB32r7OvTyJPr5j3qTt2Hb9C/H71d7m1KjMa5tTPgz9cmh/pbYl1eUzQDztGx7DEYfHcJsux7C982vN6Jm3dexCPhHBrgCMtzJx6DzCcF2JtzLhli/2P/jubjZmPufONYvVjtA/EoD+3WbX1HyLvD1rDWC8PQv1mvBocT5I8glxpsJd+dRDyv+ufHo7Cv94vp19roJMEC74KIdA9dhKMtZj/htB5TZag0vqD7a2rqzJv9a/fW8P9aX27fZL127f6L/+Op+JmaffvO7J60v8PcdHC58fiP9rcd+uJPywTkR6HPcU0e+cAw/Lqc2dfPOjWeZA2tq6Nq9KMs/ZNJM2sTG6LSn6Q/TJvM+/ke20y3z+jZyXtAoxKHLu36JjUCR+acWPWmlkdq0/JbVrD2KzSoygfeat3ZrNGviswnrgOivtOPi3SWweidNk+LqZHKPYvxc56C67bpO4wEXrNt4Wnuk2NVUC70EsBe6Hqm7z+cY13TZNf10G2jzn3lXyDVlmPIc10HhR3jHuMUJ0m/RzLfYB+wKubWn1YpR3kXHrRz4+y0C5S5XKXUd1r1Ea9AaVWqNV7pTqlXp9UB006s1qb1CrtnuNfqnarpRb/UZxUGr2+41apduoD1q9bn3AZc15yjbrGg3Kb9l1uOwbWLQOfzp+znS4N2X2qcnsU0qJ7FPcD4lyLhi3buPYWNnjY23aHQe9JPZu3vEdzlGZhklRXhofkcLHqtvnZ+Pfi9btD8bdB9UVv/ugmN19kCCFv/ugmN19cP8pu/vAU26u0z2c4QjG68RrAAt994GsVy/m7oNqdvcB4LvWfrK7D7K7D8Y6bl55nzPjgwGm7O6D5Ebxq/HzihvF3XkZxaE2EwXu6PtG8eXhiL7WwaUNi4MCn4UnwbkKOFcdOM8BDgZ92aQZ18Kf5lzZJZg2sGtG5FWCoZ4RnvAOAXQ2a0FpEcE+ArA5OeTbi3TIz/vc47TLJgP2s1CPPGBHZrweQxrUmJ8x+sRmGS741SYj1iAQJ1y3ff36C7eu/Xb7dl+u2cAiINmcUkQeztH/Zxx4rCJYLbAqwO6PdF3f8zuf6ooc/43yvTGT8zn8juO5cinkE3pdVLsTNU95B1JXM58DzPWI3ZvbplHkawBHyrS3Jx/oMh7zg/XAe6Nde8PzRp9vz7I33L5ftnN6uT7SOqd3lvpw+S+4b/L6/qquuf5S/HsZzqWSoVg7NyEimOscQNbtmj/u0vDe/9DnxPD5V8/F/21ZXySeNT9BXpFVkqEZy6v5FQ4lyFs7f5rzXje6HhJ6fK7LC/F/W/6X4mdt3MsTLKfQ1voknoOz6D2Ji94T+qH4ecWn9PUsDs2f0opDE/PdPuP5i0jPmFF/n7dtOYf4s9Ks6xR5ghUAhvYgn4seeq1wkbEdHwCZcNuJSA6h4oYiys8YfTot7zYC1ksRptN54oflg9NpiW+5frPd27118zfGHexYishROoRj0qQTOd7b5Is4XKXdRO+Pfy/zitLZ+HkVZg4/H//OInoOTv+u9l71y0BDR6pkET3JUiWL6LnvlEX0eMrNdbqHMxzBFhnRI4t7C4roaWURPSP8LKLnXsoiekgAWFCNRhbR406zGsUiJ/mP14mEMIpPhqFfRDe3obJgvmz8mxR5EHrSDrTlRV6m3ldMxF+UPn8l5kVb/pUkbr6T8E7keYJ4DWXIC/1Q0QtCP5SxpLVJfMdtAOuBDRDupynz2t43DoCHPOXJPCLOmplMOfq9Ru/zCXC1timwfSPA8x0fXcTv2OA0Cv6+QRH/Lzho4TUGiH+IcEPV4Y7CE/OOR0cF4GH/pvXNMPRVPY/HVW8STNqV1j4jx+8c/ffhRh66WpsSmlJXyK+U46c3Ix4jiW4MAA==",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert",
        "directive_to_radix",
        "directive_integer_quotient"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "redeem_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "ownership_key",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "772057049813214347": {
            "error_kind": "string",
            "string": "HTLCNotExists"
          },
          "2570651705007895968": {
            "error_kind": "string",
            "string": "HashlockNotMatch"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6012086182631426650": {
            "error_kind": "string",
            "string": "NotAnOwner"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17814817983036354427": {
            "error_kind": "string",
            "string": "Function redeem_public can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "redeem_public"
      ]
    },
    {
      "name": "refund_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::include_by_timestamp::IncludeByTimestamp",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                          "fields": [
                            {
                              "name": "recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "content",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "vL3djjS9cp15LzrWQTIYP6RvxRgYsqwxBGxIhiwPMDB871MMkrHi7Vaxs6vqm5Pdz/fu7rXyL1Zmkkzyf//df/un//q//vt/+ed/+b//9X/+3X/6z//77/7rv/3z3/72z//9v/ztX//xH/79n//1Xx7/+r//7hr/U+rjR/n7x8+yftL6WddPXj9l/dT109bPtn72+ZOXHi89Xnq89Hjp8dLjpcdLj5ceLz1ZerL0ZOnJ0pOlJ0tPlp4sPVl6svR06enS06WnS0+Xni49XXq69HTp6dKzpWdLz5aeLT1berb0bOnZ0rOlZ0uvLb229NrSa0uvLb229NrSa0uvLb229PrS60uvP/Rk/KzrJ6+fsn7q+mnrZ1s/u/+k61o/y/pJ62ddPx96On7K+qnrp62fbf3s82d56PXxc2xfHUAb6gbeIBt0w9hrG9A29AV0bRjKbQBtqBuGchkgG3TDQ5mGBbUNfcEomQllA22oG3iDbNANW7lu5bqVeSvzVuatzFuZtzJvZd7KvJV5K/NWlq0sW1m2smxl2cqjlmiczFFME2xD29AXjIKaUDbQhrqBN2xl3cq6lXUr61a2rWxb2baybWXbyraVbSvbVratbFu5beW2ldtWblu5beW2ldtWblu5beW2lftW7lu5b+W+lftW7lu5b+W+lftW7ku5XteGsoE21A28QTboBtvQNmzlspXLVi5buWzlspVHDVIboBtsQ9vQF4wanFA20Ia6gTdsZdrKtJVpK48arI9LtI4anFA20Ia6gTfIBt1gG9qGrcxbmbcyb+VRg1UH8AbZoBtsQ9vQF4wanFA20IatLFtZtrJs5VGDfA1oG/qCUYMTygbaUDfwBtmgG7aybmXdyraVbSvbVratbFvZtrJtZdvKtpVtK7et3LZy28ptK7et3LZy28ptK7et3LZy38p9K/et3Ldy38p9K/et3Ldy38p9KfN1bSgbaEPdwBtkg26wDW3DVi5buWzlspXLVi5buWzlspXLVi5buWxl2sq0lWkr01amrUxbmbYybWXayrSV61auW7lu5bqV61auW7lu5bqV61auW5m3Mm9l3sq8lXkr81bmrcxbmbcyb2XZyrKVZSvLVpatLFtZtvKuQd41yLsG2WuQBpQNtKFu4A2yQTfYhrahL7CtbFvZtrJtZdvKtpVtK9tWtq1sW7lt5baV21ZuW7lt5baV21ZuW7lt5baV+1buW7lv5b6V+1buW7lv5b6V+1buS1mua0PZQBvqBt4gG3SDbWgbtnLZymUrl61ctnLZymUrl61ctnLZymUr01amrUxbmbYybWXayrSVaSvTVqatXLdy3cp1K9etXLdy3cp1K9etXLdy3cq8lXkr81bmrcxbmbcyb2XeyryVeSvLVpatLFtZtrJsZdnKspVlK8tWlq28a1B2DcquQdk1KLsGZdeg7BqUXYOya1B2DcquQdk1KLsGZdeg7BqUXYOya1B2DcquQdk1KLsGZdeg7BqUXYOya1B2DcquQfEa1AFtQ1/gNehQNtCGuoE3yAbdsJX7Vu5LWa9rw3gLrANoQ93AG2SDbrANbUNfMGpwwlYuW7ls5bKVy1YuW7ls5bKVy1amrUxbmbbyqEGRAbxBNugG29A29AWjBieUDbRhK9etXLdy3cqjBmUczFGDE/qCUYMTygbaUDfwBtmgG7Yyb2XeyrKVRw1KH0Ab6obxKl8GyAbdYBvahr5g1OCEsoE21A1bWbeybmXdyqMGlQf0BaMGJ5QNtKFu4A2yQTfYhq1sW7lt5baVRw3qODujBifwBtmgG2xD29AXjBqcUDZs5b6V+1buW7lv5b6V+1buS9mua0PZQBvqBt4gG3SDbWgbtnLZymUrl61ctnLZymUrl61ctnLZymUr01amrUxbmbYybWXayrSVaSvTVqatXLdy3cp1K9etXLdy3cp1K9etXLdy3cq8lXkr81bmrcxbmbcyb2XeyryVeSvLVpatLFtZtrJsZdnKspVlK8tWlq2sW1m3sm5l3cq6lXUr61bWraxbWbeybWXbyraVbSvbVrat7DVoA2xD29AXeA06lA20oW7gDbJhK7et3LZy28p9K/et3Ldy38p9K/et3Ldy38p9K/el3K5rQ9lAG+oG3iAbdINtaBu2ctnKZSuXrVy2ctnKZSuXrVy2ctnKZSvTVqatTFuZtjJtZdrKtJVpK9NWpq1ct3LdynUr161ct3LdynUr161ct3LdyryVeSvzVuatzFuZtzJvZd7KvJV5K8tWlq0sW1m2smxl2cqylWUry1aWraxbWbeybmXdyrqVdSvrVtatrFtZt7JtZdvKtpVtK9tWtq28a7DtGmy7BtuuwbZrsO0abLsG267Btmuw7RpsuwbbrsG2a7DtGmy7BtuuwbZrsO0abLsG267Btmuw7RpsuwbbrsG+a7DvGuy7Bvuuwb5rsO8a7LsG+67Bvmuw7xrsuwb7rsG+a7DvGuy7Bvuuwb5rsO8a7LsG+67Bvmuw7xrsuwb7rsG+a7DvGuy7Bvuuwb5rsO8a7LsG+67Bvmuw7xrsuwb7rsG+a7DvGuy7Bvuuwb5rsO8a7KMG7RpQN/AG2aAbbEPb0BeMGpxQNmxl2cqylWUrjxq0MsA2tA19wajBCWUDbagbeINs2Mq6lXUr61a2rWxb2baybWXbyraVbSvbVratbFu5beW2ldtWblu5beW2ldtWblu5beW2lftW7lu5b+W+lftW7lu5b+W+lftW7ku5XNcVVIIoqAZxkARpkAW1oPAo4VHCo4RHCY8SHqMmTZw0yIKGR3Pqm0ZhLipBFFSDOEiCNMiCwoPCo4ZHDY8aHjU8anjU8KjhUcOjhkcNDw4PDg8ODw4PDg8ODw4PDg8ODw4PCQ8JDwkPCQ8JDwkPCQ8JDwkPCQ8NDw0PDQ8NDw0PDQ8NDw0PDQ8NDwsPCw8LDwsPCw8LDwsPCw8LDwuPFh4tPFp4tPBo4dHCo4VHC48WHi08enj08Ojh0cOjh0cPjx4ePTx6ePTtUa4rqARRUA3iIAnSIAtqQeFRwqOERwmPEh4lPEp4lPAo4RF1XqLOS9R5iTovUecl6rxEnZeo8xJ1XqLOS9R5iTovUecl6rxEnZeo8xJ1XqLOS9R5iTovUecl6rxEnZeo8xJ1XqLOS9R5iTovUecl6rxEnZeo8xJ1XqLOS9R5iTovUecl6rxEnZeo8xJ1XqLOS9R5iTovUecl6rxEnZeo8xJ1XqLOS9R5iTovUecl6rxEnZeo8xJ1XqLOS9R5iTovUecl6rxEnZeo8xJ1XqLOS9R5iTovUecl6rxEnZeo8xJ1XqLOS9R5iTovUecl6rxEnZeo8xJ1XqLOKeqcos4p6pyizinqnKLOKeqcos4p6pyizinqnKLOKeqcos4p6pyizinqnKLOKeqcos4p6pyizinqnKLOKeqcos4p6pyizinqnKLOKeqcos4p6pyizinqnKLOKeqcos4p6pyizinqnKLOKeqcos4p6pyizinqnKLOKeqcos4p6pyizinqnKLOKeqcos4p6pyizinqnKLOKeqcos4p6pyizinqnKLOKeqcos4p6pyizinqnKLOKeqcos4p6pyizinqnKLOKeqcos4p6pyizn0IUbucahAHSZAGWVAL6ptGnS8qQeHRw6OHRw+PHh49PHp49O3hg4oWlSAKqkEcJEEaZEEtKDxKeJTwKOFRwqOERwmPEh4lPEp4lPCg8KDwoPCg8KDwoPCg8KDwoPCg8KjhUcOjhkcNjxoeNTxqeNTwqOFRw4PDg8ODw4PDg8ODw4PDg8ODw4PDQ8JDwkPCQ8JDwkPCQ8JDwkPCQ8JDw0PDQ8NDw0PDQ8NDw0PDQ8NDw8PCw8LDwmPUeStOHCRBGmRBLahvGnW+qARRUHi08Gjh0cKjhUcLjxYePTx6ePTw6OHRw6OHRw+PHh49PPr28IFLi0oQBdUgDpIgDbKgFhQeJTxKeJTwKOFRwqOERwmPEh4lPEp4UHhQeFB4UHhQeFB4UHhQeFB4UHjU8KjhUcOjhkcNjxoeNTxqeNTwqOHB4cHhweHB4cHhweHB4cHh4XUuTn2T1/mk4dGcKKgGcZAEaZAFtaC+yet8UnhoeGh4aHhoeGh4aHhoeGh4WHhYeFh4WHhYeFh4WHhYeFh4WHi08Gjh0cKjhUcLjxYeLTxaeLTwaOHRw6OHRw+PHh49PHp49PDo4dHDo28PHxy1qARRUA3iIAnSIAtqQeFRwqOERwmPEh4lPEp4lPAo4VHCo4QHhQeFB4UHhQeFB4UHhQeFB4UHhUcNjxoeNTxqeNTwqOFRw6OGRw2PGh4cHhweHB4cHhweHB4cHhweHB4cHhIeUecSdS5R5xJ1LlHnEnUuUecSdS5R5xJ1LlHnEnUuUecSdS5R5xJ1LlHnEnUuUecSdS5R5xJ1LlHnEnUuUecSdS5R5xJ1LlHnEnUuUecSdS5R5xJ1LlHnEnUuUecSdS5R5xJ1LlHnEnUuUecSdS5R5xJ1LlHnEnUuUecada5R5xp1rlHnGnWuUecada5R5xp1rlHnGnWuUecada5R5xp1rlHnGnWuUecada5R5xp1rlHnGnWuUecada5R5xp1rlHnGnWuUecada5R5xp1rlHnGnWuUecada5R5xp1rlHnGnWuUecada5R5xp1rlHnGnWuUecada5R5xp1rlHnGnWuUecada5R5xp1rlHnGnWuUecada5R5xp1rlHnGnWuUecada5R5xp1rlHnGnWuUecada5R5xp1rlHnGnWuUecada5R5xp1rlHnGnWuUecada5R5xp1rlHnGnWuUecada5R5xp1rlHnGnWuUecada5R5xp1rlHnFnVuUecWdW5R5xZ1blHnFnVuUecWdW5R5xZ1blHnFnVuUecWdW5R5xZ1blHnFnVuUecWdW5R5xZ1blHnFnVuUecWdW5R5xZ1blHnFnVuUecWdW5R5xZ1blHnFnVuUecWdW5R5xZ1blHnFnVuUec+IKwXJwnSIAtqQX3TqPNFJYiCalB4SHhIeEh4jDrv5NQ3jTpfVIIoqAZxkARpkAWFh4aHhYeFh4WHhYeFh4WHhYeFh4WHhUcLjxYeLTxaeLTwaOHRwqOFRwuPFh49PHp49PDo4dHDo4dHD48eHj08+vbwgWSLShAF1SAOkiANsqAWFB4lPEp4lPAo4VHCo4RHCY8SHiU8Rp13HTTqfFEJGh7NqQZxkARpkAW1oL5p1PmiEhQeNTxqeNTwqOFRw6OGRw0PDg8ODw4PDg8ODw4PDg8ODw4PDg8JDwkPCQ8JDwkPCQ8JDwkPCQ8JDw0PDQ8NDw0PDQ8NDw0PDQ8NDw0PCw8LDwsPCw8LDwsPCw8LDwsPC48WHi08Wni08Gjh0cKjhUcLjxYeLTx6ePTw6OHRw6OHRw+PHh49PHp49O3hg9UWlSAKqkEcJEEaZEEtKDxKeJTwKOFRwqOERwmPEh4lPEp4lPCg8KDwiDrvUec96rxHnfeo8x513qPOe9R5jzrvUec96rxHnfeo8x513qPOe9R5jzrvUec96rxHnfeo8x513qPOe9R5jzrvUec96rxHnfeo8x513qPOe9R5jzrvUec96rxHnfeo8x513qPOe9R5jzrvUec96rxHnfeo8x513qPOe9R5jzrvUec96rxHnfeo8x513qPOe9R5jzrvUec96rxHnfeo8x513qPOe9R5jzrvUec96rxHnfeo8x513qPOe9R5jzrvUec96rxHnfeo877rnK5d53TtOqdr1zldu87p2nVO165zunad07XrnK5d53Rd4VHCo4RHCY8SHiU8SniU8CjhUcKjhAeFB4UHhQeFB4UHhQeFB4UHhQeFRw2PGh41PGp41PCo4VHDo4ZHDY8aHhweHB4cHhweHB4cHhweHB4cHhweEh4SHhIeEh4SHhIeEh4SHhIeEh4aHhoeGh4aHhoeGh4aHhoeGh4aHhYeFh4WHhYeFh4WHhYeFh4WHhYeLTxaeLTwaOHRwqOFRwuPFh4tPFp49PDwuW+u4kjACmSgABVowAbsG31g3MYCHLtkTjWIgyRIgyyoBfVNXvKTSlB4lPAo4VHCo4RHCY8SHiU8KDwoPCg8KDwoPCg8KDwoPCg8KDxqeNTwqOFRw6OGRw2PGh41PGp41PDg8ODw4PDg8ODw4PDg8ODw4PDg8JDwkPCQ8JDt4YOF5qxCPt3WRY5+/bEjAwWoQAM2YA/0abcWFiAB4cZwY7gx3BhuDDeGm8BN4CZwE7gJ3ARuAjeBm8BN4KZwU7gp3BRuCjeFm8JN4aZwU7gZ3AxuBjeDm8HN4GZwM7gZ3AxuDW4Nbg1uDW4Nbg1uPgHY5ZeZzwG2sAF7oE8GtrAAh9u8PD0TFzJQgMOt+PXrmbhwuBVx7Bt9cNHGAiRgBTJQgAo0YAPCrcCtwM1nEyvqWIEMFKACDehuzbEH+uxiC4cbFUcCViADBajA4eazPfnAo4090FNjobv5lvlUfQsr0De9O7rYOMc+nOgRwI7jzyo5ViADBahAAw7d6m4eChM9FBYWoLv5NngoLBxuY9oU8sFFGxVowAbsgR4KzI4FSMAKdDc/fB4KC93NN9JDYWED9kAPBXFjD4WFBKxABgpwuIlvjofCwgbsgR4K4hvpobCQgL5vfvV5KCwUYA/0mhffC69u8YvAS3r969gy9Y30kl7YgH2jjyPaOLZsfCtPPpJoYwUyUIAKdLfm2IA90Et6obt1RwJW4HAz3zIv6YUKHG5GjsPN5jx7w218D0Q8JwycWIAErEAGDrfmFl7SCw3YgD3QS3phARKwAhkItwq3CrcKN6/55nvsNb+wAhkoQA30gmxzskEDuoWfQsWmKzZdseleIs0PlJfIQgYKUIEGbMAe6CWysADh1uDW4Nbg1uDW4Nbg5nfIpo6uYI6u4JecF85CAzZg3+gDczYWIAErkIECVKABGxBuBW4FbgVuBW4FbgVuBW4FbgVuBW4EN4IbwY3gRnAjuBHcCG4EN4JbhVuFW4VbhVuFW4VbhVuFW4VbhRvDjeHGcGO4MdwYbgw3hhvDjeEmcBO4CdwEbgI3gZvATeAmcBO4KdwUbgo3hZvCTeGmcFO4KdwUbgY3g5vBzeBmcDO4GdwMbgY3g1uDW4Nbg1uDW4Nbg1uDW4Nbg1uDW4dbh1uHW4dbhxuyRJAlgiwRZIkgSxRZosgSRZYoskSRJYosUWSJIksUWaLIEkWWKLJEkSWKLFFkiSJLFFmiyBJFliiyRJEliixRZIkiSxRZosgSRZYoskSRJYosUWSJIksUWaLIEkWWKLJEkSWKLFFkiSJLFFmiyBJFliiyRJEliixRZIkiSxRZosgSRZYoskSRJYosUWSJIksUWaLIEkWWKLJEkSWKLFFkiSJLFFmiyBJFliiyRJEliixRZIkiSxRZosgSRZYoskSRJYosUWSJIksUWaLIEkWWKLJEkSWKLFFkiSJLFFmiyBJFliiyRJEliixRZIkiSxRZosgSRZYossSQJYYsMWSJIUsMWWLIEkOWGLLEkCWGLDFkiSFLDFliyBJDlhiyxJAlhiwxZIkhSwxZYsgSQ5YYssSQJYYsMWSJIUsMWWLIEkOWGLLEkCWGLDFkiSFLDFliyBJDlhiyxJAlhiwxZIkhSwxZYsgSQ5YYssSQJYYsMWSJIUsMWWLIEkOWGLLEkCWGLDFkiSFLDFliyBJDlhiyxJAlhiwxZIkhSwxZYsgSQ5YYssSQJYYsMWSJIUsMWWLIEkOWGLLEkCWGLDFkiSFLDFliyBJDlhiyxJAlhiwxZIkhSwxZYsgSQ5YYssSQJYYsMWSJIUsasqQhSxqypCFLGrKkIUsasqQhSxqypCFLGrKkIUsasqQhSxqypCFLGrKkIUsasqQhSxqypCFLGrKkIUsasqQhSxqypCFLGrKkIUsasqQhSxqypCFLGrKkIUsasqQhSxqypCFLGrKkIUsassRHEZUxmJB8GNFGAo7N6dWRgQJUoAEbsAd6QS4sQALCzeDmBendLT6qaKMBG7AHekEufLiRd9z52KKNFchAGUiOCjRgG+hb5osDTPTlARa6GzsSsAIZ6G7i6Lrq2Df6uKKNBei6zdF1u+PQLZejABVowOHmLf8+wGihLxiwsACHm6/K4UOLyBvgfWwReUu6Dy4ibzP30UVE888asAf6ygELC5CAFTjciBwFONy8SdzHGW1swB7oK3osLMDhVv04zHU9JjJQgMOt+ubM9T0mNuBw8+bzPlf5mFiA7saO7ubbMFf7mChABRqwAd1tXNV9rvwxsQAJWIEMFKACDdiAcFO4KdwUbgo3XxWk+jXp64IsVKCfN7+ifHWQhT3QVwhZWIAEHG7sx9dXClkoQAUasAF7oK8asrAACQi3BrcGtwY3DwX2jfRQWFiABKxABgpQgQZswO1WfWjSxgIkYAUyUIAKNGADwq3ArcCtwK3ArcCtwK3ArcCtwK3AjeBGcCO4EdwIbgQ3ghvBjeBGcKtwq3CrcKtwq3CrcKtwq3CrcKtwY7gx3BhuDDeGG8ON4cZwY7gx3ARuAjeBm8BN4CZwE7gJ3ARuAjeFm8JN4aZwU7gp3BRuCjeFm8LN4GZwM7gZ3AxuBjeDm8HN4GZwa3BrcGtwa3BrcGtwa3BrcGtwa3DrcOtw63DrcOtw63DrcOtw63BDlpSZJexYgASsQAYK0C0uxwbsgTNAJhYgASuQgQJUINwK3ArcCG4EN4IbwY3gRnAjuBHcCG4Etwq3CrcKtwq3CrcKtwq3CrcKtwo3hhvDjeHGcGO4MdwYbgw3hhvDTeAmcBO4CdwEbgI3gZvATeAmcFO4KdwUbgo3hZvCTeGmcFO4KdwMbgY3g5vBzeBmcDO4GdwMbga3BrcGtwa3BrcGtwa3BrcGtwa3BrcOtw63DrcOtw63DrcOtw63DrcebnRdwAIkYAUyUIAKNGADwm1miTkWIAHdrTkyUIAKNGADDjdxN8+ShQXobt2xAhkoQAUacLiNdSvqXJJwomfJwgIkYAUyUIAKNCDcKtwYbgw3zxIhxwpkoAAVaEB3E8ce6Fmy0N3UkYAVyEDX9RM7Fyn0MzSXKZxIwKGgfoY8HxYKcGzvWJiiziULFzZgD/R8UN8hz4eFBKxA1/XD5zU/hsbUuUDhwgL07XWLuUzhRAYKUIEGbMAe6DWvfny95hcSsAIZKEAFGrAB+8a5kOHCAiRgBTJQgO6mjj3Qq3thARKwAhkoQOh6dS9sQLgR3AhuBDeCG8GN4EZwI7gR3AhuFW4VbhVuFW4VbhVuFW4VbhVuFW4MN4Ybw43hxnBjuDHcGG4MN4abwE3gJnATuAncBG4CN4GbwE3gpnBTuCncFG4KN4Wbwk3hpnBTuBncDG4GN4Obwc3gZnAzuBncDG4Nbg1uDW4Nbg1uDW4Nbg1uDW4Nbh1uHW4dbh1uHW4dbh1uHW4dbj3c+LqABUjACmSgABVowAaEG7KEkSWMLGFkCSNLGFnCyBJGljCyhJEljCxhZAkjSxhZwsgSRpYwsoSRJYwsYWQJI0sYWcLIEkaWMLKEkSWMLGFkCSNLGFnCyBJGljCyhJEljCxhZAkjSxhZwsgSRpYwsoSRJYwsYWQJI0sYWcLIEkaWMLKEkSWMLGFkCSNLGFnCyBJGljCyhJEljCxhZAkjSxhZwsgSRpYwsoSRJYwsYWQJI0sYWcLIEkaWMLKEkSWMLGFkCSNLGFnCyBJGljCyhJEljCxhZAkjSxhZwsgSRpYwsoSRJYIsEWSJIEsEWSLIEkGWCLJEkCWCLBFkicwsaY4FSMAKZKAAFWjABuyBBDeCG8GN4EZwI7gR3AhuBDeC2wwQcyRgBTJQgAo0YAP2wBkgE+HGcGO4MdwYbgw3hhvDjeEmcBO4CdwEbgI3gZvATeAmcBO4KdwUbgo3hZvCTeGmcFO4KdwUbgY3g5vBzeBmcDO4GdwMbgY3g1uDW4Nbg1uDW4Nbg1uDW4Nbg1uDW4dbh1uHW4dbh1uHW4dbh1uHWw83vS5gARKwAhkoQAUasAHhVuBW4FbgVuBW4FbgVuBW4FbgVuBGcCO4EdwIbgQ3ghvBjeBGcCO4VbghSxRZosgSRZYoskRnlnTH4TY+8ag+AnNjD/QsWViABKxABgpQgXBjuDHcBG4CN4GbZ8n4DqX6CMyNAlSgARvQ3UYDhY/ApDaxAAlYgQwUoAIN2IA90OBmcDO4GdwMbgY3g5vBzeBmcGtwa3BrcGtwa3Dz1BgT5FYfVUnGjgXoCuJYgQwUoAIN6NvrV5/ng6OPqtxYgMOtX44VyMDhNkbUVB9VudGAw23MuVR9VOVCz4eFBehu1dF12VGBBmxA1x0PLj5+ksbQmOrjJ2l8TF99/OSjDcexDvQtG0lQLzceSbBRgQZsA33LRhIsHEmwsQDdTRzdwjenuoVvTnULP76j/GvxzRnl/2jkceyBo/w3FiABK5CBw634Nozy39j2xeUjJRd6zS8sQAJWIAMFqEADwk3gpr5Dfki0AAnoO+QHShkoQAUasAF7oF3AAiQg3Axuo+Yr+faOmt9owAbsgaPmNw438qM+an5jBTLQ3fz6bQo0oLv5lrVIGB8pubEACViBDBSgAg3YgOHWrgtYgASsQAYKUIEGbEC4FbgVuBW4FbgVuBW4FbgVuBW4FbgR3AhuBDeCG8GN4EZwI7gR3AhuFW4VbhVuFW4eIOMb6OojJTeOq6TOXzBgA/ZAD5BaHQuQgBXIQAEq0IDuxo49cD4/iKM/BfnvzreOia47f0GBBmzAHuipsbAAfS/MsQIZ6G7NUYEGdDd17IGeGgujK6PNt46JFchAASrQgA0YHScNHSdz4KZ3/8yBmwt9L/zMez4sNGAD9sB+AQtwHDMujhXIwOE2BnxVnyJuowGHm/dO+nDOiT6cc2N0V83hnAsrkIECVKABG7AHlgvoe1EdGShABfpesGMD9kC6gD6u2BwJWIEMFKACDdiAPXDOhjDR98J3yGt+oQAVaMAGHHvhXZI+WnNjARJwuHkHqI/W3CjA4SZ+HLzmFzagu40S8dGa1a9UH61Zx9f61UdrbqxABgpQgcPNuy99tObGHuhJsLAACViBDBSgAuGmcFO4GdwMbv784H2hPlpzIwPdzY+OPz8sNGAD9kB/flg43PwtyUdrbqxABg63sXxo9dGaGw043Pzty8dwPp6QBno+LCxAAlYgAwWoQAO6m18Png8D2cdw1rHqFPsYzo0ErMDhNh4X2cdwblSgARuwB4582FiAw21ME8A+hnOju1VHASrQgC3QP6+4XIHcgh0JWIEMFKBb+NHxV42FDdgD/VVjYQEOt+775gGykIECHG7dt9cDZGEDDrfu++YBsrAA3U0c3U0d3c03xwNkoQIN2IA9cA7sdqpBHCRBGmSbRgXzeLVjHzm5sQeOCt5YgASsQAYKUIFwM7gZ3BrcGtwa3BrcGtwa3BrcGtwa3BrcOtw63DrcOtw63DrcOtw63Drcerj5yMmNBUjACmSgABVowAaEW4FbgVuBW4FbgVuBW4FbgVuBW4EbwY3gRnAjuBHcCG4EN4IbwY3gVuFW4VbhVuFW4VbhVuFW4VbhVuHGcGO4MdwYbgw3hhvDjeHGcGO4CdwEbgI3gZvATeAmcBO4CdwEbgo3hZvCTeGmcFO4KdyQJQVZUpAlBVlSkCUFWVKQJQVZUpAlBVlSkCUFWVKQJQVZUpAlBVlSkCUFWVKQJQVZUpAlBVlSkCUFWVKQJQVZUpAlBVlSkCUFWVKQJQVZUpAlhCwhZAkhSwhZQsgSQpYQsoSQJYQsIWQJIUsIWULIEkKWELKEkCWELCFkCSFLCFlCyBJClhCyhJAlhCwhZAkhSwhZQsgSQpYQsoSQJYQsIWQJIUsIWULIEkKWELKEkCWELCFkCSFLCFlCyBJClhCyhJAlhCwhZAkhSwhZQsgSQpYQsoSQJYQsIWQJIUsIWULIEkKWELKEkCWELCFkCSFLCFlCyBJClhCyhJAlhCwhZAkhSwhZQsgSQpYQsoSQJYQsIWQJIUsIWULIEkKWELKEkCWELCFkCSFLCFlCyBJClhCyhJAlhCwhZAkhSwhZUpElFVlSkSUVWVKRJRVZUpElFVlSkSUVWVKRJRVZUpElFVlSkSUVWVKRJRVZUpElFVlSkSUVWVKRJRVZUpElFVlSkSUVWVKRJRVZUpElFVlSkSUVWVKRJRVZUpElFVlSkSUVWVKRJRVZUpElFVlSkSUVWVKRJRVZUpElFVlSkSUVWVKRJRVZUpElFVlSkSUVWVKRJRVZUpElFVlSkSUVWVKRJRVZUpElFVlSkSUVWVKRJRVZUpElFVlSkSUVWVKRJRVZUpElFVlSkSUVWVKRJRVZUpElFVlSkSUVWVKRJRVZUpElFVlSkSUVWVKRJRVZUpElFVlSkSUVWcLIEkaWMLKEkSWMLGFkCSNLGFnCyBJGljCyhJEljCxhZAkjSxhZwsgSRpYwsoSRJYws4Vno5FiABPTGWicOkiANsqAW1DfNTy6cShAFhQeHB4cHhweHB4cHh4eExyxrdiRgBfohVEcB+iHsjgZswB44y3piARKwAhkoQLgp3BRuCjcv6+InzMt6IQErkIECHG6je5l99OTGBvRuqUFzvIJTCaKgGsRBruiXixfpmEeBfSwkFz/eXqQLK5CBvqV+FrxIFxqwAfvGNRbSqQS5lzlWIAPdqzsq0IDDa3Teso+EXOglOmZnYB8JuZGA3vHkxEESpEEW1Db5LZ0mji0ldhxb6pe0j2vcaMAG9C31HfSaXliABKxAb6p2kiAN8hZ/pxbUN83OBacSREFu0hwZKMAW6AVLfvC9YBd6T4gTB0nQOCLVT41X68IGHEdkHl6v1oXDaip4tS4cGzu326t17r5Xa/Xj5NU6OrXYhypubMAe6NW6sAAJWIHDjX17vVrZLyWvVvbt9dst+0b67ZZ9I/12u5CAFchAAWqgFyr7bnqhLiRgBTJQgLrRBw/y+AqRffDgRgYK0P+sOfqR7I5+MTj1TbPinEoQBdUgDpIgDbKg8CjhQeFB4UHhQeFB4UHhQeFB4UHhQeFRw6OGhz8pj48qWeeTspMFtaC+aT4lO5UgCqpBHCRB4cHhweHB4SHhIeEh4SHhIeEh4SHhIeEh4SHh4bUmfhS81hYKcAiJXyxea6Mjkn0oH4tfN15V4teNV8r4cJF9IB6r/67f1xb2QK8f9QvW62chASuQgQJUoAHdjR17oBfYwuFmvm9eSuab46W0cOja/F0DNmDf6MPz5p/58LyNBKxABgpQgQ3omz7I625SCaKgGsRBLi6OCrRAL7OFvnn+Z15U3ino4+42KtCADdgDvbQW+sFojgSsQHfrjgJU4HDz/kEfgrexB3oFLixAAlYgAwWoQLgx3BhuAjeBm8BN4Ob16J2YPhpvowJd10+03wG939GH1W30zfEz5JXW/Az5XW2i39UWuoIfdb+rLRyb4z2MPiiOvavQB69xdwuvk4U90Otk4dD1bkUfvLaxAhkoQAW67thIH6a2sQBd1xwrkIECVKABG7AH+mU/xpiyDzLb2IA90IthYQH6lnXHCmSgABVowIeb+GudDzJbOEpkYwHSwOIoA8lRB1ZHAzZgD+QLWIAErAPZkYECdDdxNGADupsfHbmABUjACmSgABXobn7Mxg1K/A3IB46Jv8X4wLGNAlTg2DJ/zfEhYhsLkIAVyEABKnBsmb8S+RCxjT2wXcACdAs/Zo2BLuaXfffN8Su1u7Efh+7Gfhy6AYexC4xqcvIxXYtKEAXVIA6SIA0aJnQ5NmAPHHeejQVIwApkoABdd5xPH7Yl/mrmw7bGECX2UVuLOEiCNMiCXLE69kCvqoUFSMAKHKr+RudDs8Rf2Hxo1kZ/J3GioBrEQRKkQX5MzbEBe6BXzsICJKAfveboCt1xKDiNl6dFJWj8uf+JV80kDpIgDbKgYeKvaD6+aqGX0cIKHH9f/Rx6aSxswKHgu+GVMakEUVAN4qCxmf5W6KOlNhqwAXtgv4AFSMAKZCDcOty87vzF00dLbewLxUdLyXgHFR8ttdHdmqO7dcfhNl4mxUdLbVTgcBvXjfhoqY3Dbbxiio+WEnbjUYDqfzXqb1EN4iAJ0iBX1IFeeuwb7bXHvqVefAsF6ElxORqwAXugF+BCjx839lIbbxHiQ5tEfAf9BrawB3oBLixAAlYgAwXobn7gvAwXNqC7+eH0MlxYgAR0Nz9mfgNbKMBxeF123L8WtaCHlfpWjXpdVIIoqAZxkJv4OfKCXWjAFuj3uIW+mX4R+t1soSv4+fSSXdiAY0tdYJTsohJEQTWIgyRIgyyoBYVHD48eHj08enj08Ojh0cOjh0cPj749fDzUohLkt5zLsQIZ6HcdclSgAcch85Pro6EWeoVOC79FLiRgBTLQ3ZqjAt2tOw438y3z6h3jRcVHQ20sQI9V30iv6YUMfLhNrVHSiyyoBfVNo5wXuWJ1HFtqvttezeMFUnxs08Ye6NW80LfUd9ureWEFMlCAY1N9/7yYzQ+LF3Ob/9oDvZibb+Mo2/WPj7/vvvu+5K1r+pK3k0qQ3zvVsQIZKEAFGrABe6DfQRcWINwMbgY3g5uXbvON9NJd2IA90G+3Cwuw7mPgi99OkqBxhNzJF7+d1IJc3K9Lv8UuLEACViADx650v4r8FrvQd8XPpt9iF/aNtNe7FtrrXQvt9a6F9nrXQnu9a6G93rXQXu9aaK93LbTXuxba610LlfAo4VHCo4RHCY8SHiU8SniU8CjhQeHhtTpexcVHG22swHHQ/KT4aKONCjTgOGjjZV58tJGMd3VZa8G6mM/yvpCA7iaODBSgAg3YgD3Qq3thARIQbgw3httcIfZyNGAD9sC5QuzEAiRgBTJQgHATuPnjtV/sNB+vHefz9cQCJGAFMlCACjSgu5ljD/SUWFiBruDVMCpf5/aOyt/YA/2uvXDc7ubp9vv2wgpkoAAVaMAG7IF+/14Itw63DrcOtw63Dje/jV9+Vft9fKG7javaRxBtLEB3E8cKZKAAFWjABuyBxd3UsQAJWIHu1hwFqEADNuBwG20L4iOINhYgASuQgf58b44KNGADupsb1wtYgMNtvKmLjyBScouRDxsFqEADNmAPHPmwsQAJCDeGG8ON4cZwY7gx3ARuAjeBm8BN4CZwE7gJ3ARuAjeFm8JN4aZwU7gp3BRuCjeFm8LN4GZwM7gZ3AxuBjeDm8HN4GZwa3BrcGtwa3BrcGtwa3BrcGtwa3DrcOtw63DrcOtw63DrcOtw63DzLBltPeIjiDa6mzgSsAIZ6G7NUYEGbMAe6FmysAAJ6G7dkYG67wE+bGhjA/p75UhPHza00d8sqyMBK9BfLn3nPUAWKnDskDdx+ExvG3ugB8jCAiRgBTJQgAqE24gKf2D3oUiLKGg8zs/f4yAJckV1NGAD9kAPiYUF6NvvR9ZDYiEDh5mfsJERiyyoBfVNIx8WlSAKqkEcFB4aHhoeGh4aHhYeFh4WHhYeFh4WHhYeHgd1YgP2wNmG5xfmbMSb6C9x8xcqkIGyX8d83raN3kpyOTbgcPPWMB+rtLEAx1P5pBrEQRKkQbbIxyPp6OAXH3uk3r7mY4/U29d87NFGBRrQt1Qde6AX98ICJOBw89YwH3y0UYAKNGADDjdvtfJZ2DYWIAHdTRwZKEB3M8fh5i0ePlppYw/0Ol9YgASsQAYKUIFwq3CrcGO4MdwYbgw3hhvDjeHGcGO4MdwEbgI3gZvATeAmcBO4CdwEbgI3hZvCTeGmcFO4KdwUbgo3hZvCzeBmcDO4GdwMbgY3g5vBzeBmcGtwa3BrcGtwa3BrcGtw82TwlmqfkG2ju3nxejIsLEACuptf6/6gsFCACjRgA/aNPiHbRndTRwK6hTkKUIEGdIvm2AM9QBYWIO2M8tFUGxkoQAUasAF7oAfIwroa1XwE1SIJGk1uvuPeOjipBfn2j1uAzpCYWIAErEAGDidy0iAL8qbcy7EHekIsfFj5HcbHWS2qQRwkQRpkQS2obxrBsCg8JDwkPCQ8JDwkPCQ8JDwkPDQ8NDw8DOax9zBYyEBv/PZT52Gw0Ju//aR4GCzsgR4G5herh8FCAlYgAwWoQAO6m1/Ys9vAcfYbTCxAd/PzPrsOJjJQgAocbs3Pt4fBwh44wmBRCaKgGsRBEqRBFtSC+iIf1LWoBFFQDeIgCdIgC2pBviPj3Pq4Lh2jfcQHdm0kYAUyUIAKNGAD9kCCG8GN4EZw86cIf8T2gWAbFWjABuyBHhDeXukDwTYSsAIZKEAFGrABeyDDjeHGcGO4MdwYbgw3hhvDjeEmcBO4CdwEbgI3f17wdlsf8uXvez692iL/I3NkoAAVaMAG9N4bv7TsAhYgAUekeXObz662UYDeUeRbawZsQHfzy6VdwAIkoLv5hdFcVx0N2IA9sLtuc3RdP1Cj1q14MXW/m/n2dr+d+ZZ1v5+5cVegARtwuI3hOeID1DYWIAHdzRzdojv6nexy9FtZcRwW3gTho9JsfAshPnnaxgIkYAUyUIDu5ttQDOgWvjl0AQtwWFTfSH8CWMhAASrQgA3YA72bcGEBwq3CrbqbHxJ/DlioQAM2YA9kd/M99keBhQSsQHdrjgJU4HDzd9CGMm8o84YybyjzhjJvKPOGMvchbhsVaEC4CdwUbgo3hZvCTeGmcFO4KdwUbgo3g5vBzeBmcDO4GdwMbgY3g5vBrcGtwa3BrcGtwa3BrcGtwa3BrcGtw63DrcPNU8MbF3x2tY3jKuH5Cwo0YAOOa9KH5fhIvI0FSMAKZKAAFehu6tiAflsdV7UPvTOeWIEMFKDrNkcDNmAPnOMK2LEACViBDBSgAi3Q88EHE/mwvI0ErEAGCtBfP0aZ+rA883FFPi7PfFyRD8zbyMCh4KOCfGzeRn+r8S3zt4CFPdDfA7zNxAfnbSRgBTJQgAp0Nz+F/j6wsAf6G8HCAiSgj0HyM6Qax0ENiKPjd39v4/GxexsLkIAV6HvhFn73X6hAAw43f2X3cX4L/e6/cLj5G7kP9dtYgcPNBzn5aL+NCnQ3P/P+TOCDbHy0n/kbuY/2M38N99F+Gwnour5vXscLDdiArvvYN/URfH5xqY/g28hAAVqgD/9ZWIAE9FNIjgwUoAIN2IA90Mt0YQH6Qe2OAlSgAcfOj7dp9cF7C71MFxbgHiqoc0jfQgYKUIEGbMAe6IMHFu6hpTqH9C0ce2ETFWjABvS98OPgxbuwAAlYgQz0gaATFWjABuyBPkxgYQESsAIZ6HtRHRuwB3rxLvS9YEcCViADfdSwn2MfPLDQgA3YA72Ff2EBEtDPhTgq0IAN6HuhA71MFxYgASuQgQJUoLv5BePFu7Bv9AF/G92tORKwAhnox0wcFWjABuyB5QIWIAEr0HWLo+9Fd2zAHuiP7qOVQH1wn41uE/XBfRsrkIECVKABG9Bbo8YF45OaWfON9DoeI/PVB/PZGH2mPphvoT94LyxAV/CjPlvhJjJQgAo0YAP22IY5Qn5iARKwAhmIvfA6XmiBswHOz/xsgfOj7rfbhRXIwLEX3U+L34QXGnDsRfdz7HU80et4YQESsAIZ6G6+vX4TXmhAd/Oz6TfhiX4TXliABKxABrqbXw9e3QsN6G5+lXh1T/TqXliABKxABrqbXzte3QsN6G5+hmZb3Di+NBvjiqO3xpEjASuQgd4ix47eJCeO3ianjg3YA8sFdLfm6G7d0UeY+paNO/pGASrQ980cG7AHes0v9O+H3M0fvBdWIAMFqEADNmAPrN6v7keyViADBeh74Udy3NE3NmAPnH34EwuQgBXIQNetjg3YA8V1/RRKARKwAhnoun66vTO++Nn03viFBKxABsr6+lLn1GELDdiAPXB+kzmxAAlYgX58/cybARuwBzbfCz+Fzc+QX4hNgQYcCuRX36jYhd5ovnDssd+SfIBeIz/U3kZOfvi8kXweB28lX9iAfaMP0NtYgK4rjgJUoAHb+v5Y52ReE/2b54UFSMAKZKAAFTh0x6gbndN2LSzAcT2MpjT1QXcbfS+6owAVOPZiNG6pD7rb2APHc3Xz5z4fdLeRgBXIwOFW/eh4FS40YAP2QK/ChQVIQNf1QzIn+/C98MqqvsdeWQsr0LfMD5SPhlnoWzYVDNiAY8vYj4NX4cICJGAFMlCAw2001KgPmdvYgD3QB8csLECKPfaxMOyH2qtwoQEb0HVHifjguI0FSMBxTXoNzem1FgpQgQZswB7o32Ev9KMzkYECVKDvhZ9ur9iFfaMPg9s4KsCTdk6ktbACGShABRqwBc7Z8/0h0UeFBXNiSayJLXFL3MHjQg8uiZMvJ19Ovpx8Zf57d5bEmtgSt8QdrFfikpgS18TJV5OvJl9Nvpp8Nfla8rXka8nXkq8lX0u+lnwt+VryteTbkm9Lvi35tuTbkm9Lvi35tuTbkm9Lvj359uTbk29Pvj359uTbk29Pvj35dvj6MLLgkpgS18ScWBJrYkvcEiffknxL8i3JtyTfknxL8h311f2V1wdkbWzAHsgXsAAJWIEMFCDcGG4MN4abwE3gJnATuAncBG7+lZe/+vuArI0N2APn118TC5CAFchAAcJN4aZwU7gZ3AxuBjeDm8HN4GZwM7gZ3AxuDW4Nbg1uDW4Nbg1uDW4Nbg1uDW4dbh1uHW4dbh1uHW4dbh1uHW493HxA1sYCJGAFMlCACjRgA8KtwK3ArcCtwK3ArcCtwK3ArcCtwI3gRnAjuBHcCG4EN4IbwY3gRnCrcKtwq3CrcKtwq3CrcKtwq3CrcGO4MdwYbgw3hhvDjeHGcGO4MdwEbgI3gZvATeAmcEOWKLJEkSWKLFFkiSJLFFmiyBJFliiyRJEliixRZIkiSxRZosgSRZYoskSRJYosUWSJIksUWaLIEkWWKLJEkSWKLFFkiSJLFFmiyBJFliiyRJEliixRZIkiSxRZosgSRZYoskSRJYosMWSJIUsMWWLIEkOWGLLEkCWGLDFkiSFLDFliyBJDlhiyxJAlhiwxZIkhSwxZYsgSQ5YYssSQJYYsMWSJIUsMWWLIEkOWGLLEkCWGLDFkiSFLDFliyBJDlhiyxJAlhiwxZIkhSwxZYjNLuuNwG/NsqQ/x2qhAAzZgD/QsWViABKxAuAncBG4CN4GbwE3hpnDzLPFmex8btpGBAlSgAd1NHHugZ8lCd/Nj5lmysAIZKEAFGnC4eSO2jw3r3lztY8M2FiABK5CBAlSgARsQbh1uHW4dbh1uHW4dbh1uHW4dbj3cfMTYxgIkYAUyUIAKNGADwq3ArcCtwK3ArcCtwK3ArcCtwK3AjeBGcCO4EdwIbgQ3ghvBjeBGcKtwq3CrcKtwq3CrcKtwq3CrcKtwY7gx3BhuDDeGG8ON4cZwY7gx3ARuAjeBm8BN4CZwE7gJ3ARuAjeFm8JN4aZwU7gp3BRuCjeFm8LN4GZwM7gZ3AxuBjeDm8HN4IYsaciShixpyJKGLGnIkoYsaciShixpyJKGLGnIkoYsaciShixpyJKGLGnIkoYsaciShizpyJKOLOnIko4s6ciSjizpyJKOLOnIko4s6ciSjizpyJKOLOnIko4s6ciSjizpyJKOLOnIko4s6ciSjizpyJKOLOnIko4s6ciSjizpyJKOLOnIko4s6ciSjizpyJKOLOnIko4s6ciSjizpyJKOLOnIko4s6ciSjizpyJKOLOnIko4s6ciSjizpyJKOLOnIko4s6ciSjizpyJKOLOnIko4s6ciSjizpyJKOLOnIko4s6ciSjizpyJKOLOnIko4s6ciSjizpyJKOLOkzS9ixAAlYgQwUoLuZowGbTy9SnDvY2y43l8SUuCbmxJJYE5vz5dwS983m89UFl8SUuCaevtVZEmtiS9wSd3C5Ek9fdabENbH7jn5h89FxwZrYfUf3tPkAueAOnot/js5f8zFywZTYT+389WnbnCWxJrbELXEHr+l3JpfEbkvu5V0hmzmxJNbElrgl7mDvCrnId8u7QjZT4unr28OcWBK775gKwK45H8/ilriD55Q8i0tiSlwTu2/1Uz3n5VmsiS1xS9zBeiUuiaev74vWxJxYEmtiS9wSd7BdiUvi5GvJ17taLvaS8q6WzZrYErfEHexdLZtLYg+qiRXIQAEq0IAN2APnQ8/EAoRbh1uHW4dbh1uHW4dbD7dyXcACJGAFMlCACjRgA8KtwK3ArcCtwK3ArcCtwK3ArcCtwI3gRnAjuBHcCG4EN4IbwY3gRnCrcKtwq3CrcKtwq3CrcKtwq3CrcGO4MdwYbgw3hhvDjeHGcGO4MdwEbgI3gZvATeAmcBO4CdwEbgI3hZvCTeGmcFO4KdwUbgo3hZvCzeBmcDO4GdwMbgY3g5vBzeBmcGtwa3BDlhRkSUGWFGRJQZYUZElBlhRkSUGWFGRJQZYUZElBlhRkSUGWFGRJQZYUZAkhSwhZQsgSmk85Y6SG0XzKWSyJZzyrsyVuiWc8j5in+ZSzuCT228IY4240n3IWc2L3Fd+2+ZSz2BK77xjmbzSfcibPp5zF7ju+NjCaTzmLa2L3Hd+4GM3HnMWaGI85lB5zKD3mrFkG/dFjTTO4mBLXePSg9ZgzWRJrPHrQesyZ3BLP/e2D52PO4pLYfdV952POYk7svurndz7mLLbE7qu+bfMxZ/J8zFnsbaETvdXTj9ps0Z3YA2eL7sQCJGAFMlCACoSbwk3hZnAzuBncDG4GN4Obwc3gZnAzuDW4Nbg1uDW4Nbg1uDW4Nbg1uDW4dbh1uHW4dbh1uHW4dbh1uHW49XCr1wUsQAJWIAMFqEADNiDcCtwK3ArcCtwK3ArcCtwK3ArcCtwIbgQ3ghvBjeBGcCO4EdwIbgS3CrcKtwq3CrcKtwq3CrcKtwq3CjeGG8ON4cZwY7gx3BhuDDeGG8NN4CZwE7jNN5/xPZrV+eYzvr6yOt98FmtiS9wSd/B881lcElPimjj5avLV5KvJd775jC+/rM43n8nzzWdxSUyJa+Lpa86SWMFtd0FZnREykYAVyEAButr4gMt8KGVwSzz3YgR8nc0vi0viuRd+1mbzy2JOLIk1sSVuiXswz+aXxSXx7m4zviqQgdNUnDWxJW6JO3g+lSwuiSnx3NnmzIklsSa2xC1xB8+nksUFPJ8azPdrPjUspsS7cc84GmWNo1HWOBpljaNR1jgaZY2jUdY4GmWNo1HWOBpljRluDDeGG8ON4cZwY7gJ3ARuAjeBm8BN4CZwE7gJ3ATPnHO06eaSGM+cc7TpZk7sZ3d8Y2ZztOlmS9wSd/AMgsUlMSWez5yTObEknr7F2RK3xB08m0AWl8SUuCZ2Xw/iOdp0sya2xC1xB8/IWFwSU+Lp68d2RsZiSayJLXFL3IPnaNPNJfF8tifnmpgTz+NcnDWxJZ6+zbmDZ2osLokpcU3MiSUx3ilkvctMbomn76h8mamxuCSmxDUxJ5bEmth9vXZkvsss7uCZSotLYkpcE3NiSey+3fdrvpuMr91M5rvJ4pqYE0tiTWyJW+IOFjQ5i5TElHj6qjMnlsSa2BK3xB0882fx3F8/5jN/FtfEnFgSa2JL3BJ3sOePT2ZvPqA2mBLXxOzs58jzZ7MmtsQtcQe3K3FJTInRtC+NE0vi6VudLXFL3MH9SlwSU+KaeO6vn5cuiTWxJW6Je7CPtg0uiSnx1B/XmI+XfXB3LokpcU3MiSWxJrbELfHs+hjXv9KVuCR23/H9pfng2WBOLIk1sSVuiTvYc6OML13MB9EGU+KamBNLYk1siVvi6ev7xVfikpgST18/R8yJJbEmtsQtcQfLlbgknm0+fg1ITcyJp685a2JL3BJ3sF6JS2JK7PtLfl48ZzZLYk1siVviDp45s7gknvrkLIk1sSVuiTt45gn5+Z15stj3a3zxZT7ANnj6+vltknj6+rmYebJ4+vrxmXkyeebJPC8zTxZPX6+vmSeL3bf6vs88Wey+Y6YO05kni923+j7OPHG2mSdjBi+zmSeL3de7B33QbfD0FWdJPH3V2RJPX3Pu4JlL3h1nM5cWT9/uXBO77/hY0GzmEvv2z1zy9mGbucS+nTOXFnew59LmkpgS18ScWBJr4uRLyZeSb02+NfnW5FuTb02+NfnW5FuTb02+Nfly8uXky8mXky8nX06+nHzn84+38dp8/lmMNmGbucR+bcxcWkyJa2JOLIk1sSWe++vXzMylyTOXFpfElLgm5sSSWBNPX9+vmUuLO3jm0uKSmBLXxJxYEs+GGL/O5/vX4pbYff19zWZeLS6JKXFNzIklsSb2/RWvqZlXizt45tXikpgS18ScWBJPX8+EmVeLp68f/5lXfl21+f7l/QJtvn8tpsQ1MSeWxJrYErfEHVySb0m+M6/8vLSZV4s5sSTWxJa4Je7gmVeLS+LpS841MSeWxJrYwDNnvDG0zZxZrIktcUvcwTNnvAGxzZxZPH+/OXfwzIfF/vveLNhmPiyuiTmxJNbElrgl7uCZD4uT78wHb31rMx8Wc2JJrIktcUvcwTMfFk9f3/eZD+bHcObDYk4siTWxJW6JO3jmw+J53fo2zPaZxTXx9PVam/mwWBNb4pa4g2c+LC6JfX+bH/OZD4s5sSTWxJa4Je7BfT7PLJ6tn8O3lytxSRwNgRhVaxhVaxhVaxhVaxhVaxhVaxhVaxhVaxhVaxhVaxhVaxhVaxhVaxhVaxhVaxhVaxhVaxhVaxhVaxhVaxhVaxhVaxhVaxhVaxhVa73GeEnrtYP5Soxxi50pcU08z251lsSa2BK3xB08U2NxSTx9J9fEnHj6srMmtsQtcQfP1FhcElPieTWbMyeWxJrYErfEHTxTY3FJPH2bc03MiSWxJrbELXEHz9RYjPGhvVHimnj6ekXN1FisiS1xS9zBMzUWl8S+v/OanKmxmBNLYk1siVvivrnNcbibo1W3rXG4i2tiTiyJNbElbok7eKZScd+ZSospsfuO8bNtj8OdLInn/lZnS9wSz/2VwfOpYnFJPI+zOtfEnHge5+6siS1xS9zB8y1ocUlMiWvi4UsjQ9ociLtZE1vilriD55wki0tiSjyPsx+H2Qq8WBJPXz/mbIlb4g6WK3FJTIlr4rm/7CyJNbElbok7eM55srgkpsSzFXhytGK3NbB28uxVWlwSU+KamBNLYk0cI5naGli7uINbtGK3NbB2MSWuiTmxJNbEljhasdvVOnj2Ki0uiSlxTcyJJbEmnq2lfn5Xq+7kHlyuK3G0YrdyUeKamBNLYk1siVviDi4xYqyVUhJT4mjFbmW1Dk+WxJrYErfEHUxX4mjFboUocU3MiSWxJrbELXEHz5wZLeOt1GjFbqW2xB3MV+KSmBLXxJxYEs8RdeJsiVviaMVuZbXqTi6JKXFNzIklsSaOVuxWpCXuYL0Sl8SUuCbmxJJ4+vp+zeecxS1xB1u0YrdiJTElrok5sSTWxJa4JZ69FH4NzJxZXBJHK3Yrs/VkMSeWxJrYErfEHdyjFbuVXhJT4pqYE0tiTWyJo/W80ZwTya9/mnMiLa6JObEk1sTzvmPOLfG874zjNkfcbp6+3ZkSu69fk3PE7Wb39eeZOeJ2s/v6s9AccbvZff16myNuN7vvmGuyzRG3m6evOHPi6ev7SJp4+vo+Uks8fX0f65V4+vo+zjnWFrvvPBfzeWax+3rGzhG3m92XfB/n88xi9yXfx/k8s9h9PUPmiFsi3/45xxr5Ns851vzaniNuN2tiS9wSd/B8nllcElPimjj5SvKV5CvJV5KvJF9Nvpp8Nflq8tXkq8lXk68mX02+mnwt+VryteRryXc+/1S/3ubzz2JNPH392phzuC3u4DmH2+KSmBLXxJzY97f6NTPncFtsiVviDp5zuC0uiSlxTey+1a/DOYfbYk1siVviHlznHG6LS2JKPD/gUmdOLImnLztb4pa4g2deLS6JKXFNPPfXnCWxJrbELXEHz7xaXBJTYvcdPV6tzrxa7L6j96vVmVfsx4fiQ7lWqSXu4HolLokpcU3MiSWxJk6+NfnOvBq9Na3OvFpcElPimpgTS2JNbIlb4unr18PMq8UlMSWuiRk8c2b0iLQ5jHdzTcyJJbEm9u0UP3czZybPOR7Fz+Oc43GxJZ6/79sz82HyzIfFJTElrok5sSTWxJY4+c58GL0vbQ7U3VwSU+KamBNLYk1sid1Xfd9nPoylS9ocqLu5JKbENTEnlsSa2BLPL4gmd/D6gmjy9K3OlLgm5sSSWBNb4pZ47u845nOs7uaSmBLXxJxYEmtiA8/nk9H70tYcsIs5sSTWxJa4Je7gWe+LS+Lky8mXky8nX06+nHw5+XLyleQryVeS76z3May+rTlmF0tiTWyJW+IOns8ni0viOerXz6/WxJzYfc2vsZkbiy1xS9zB8/lkcUlMiX1/zb3mHLOLJbEmtsQtcQfP/FlcEk9fdq6JObEk1sSWuCXu4Jk/i+foar+eZ/vM4pp4+oqzJNbElrgl7sFrjtnFJfHc3+ZcE3NiSayJLXFL3MHz+WTx9O3Orj9GVLc9l+xk1x+9X22O7t3cErv+6Ddpc3Tv5pKYEtfEnFgSa2JL3BIn35p8a/Ktybcm35p8a/Ktybcm35p8a/Ll5MvJl5PvmpuanTmxJNbElriB53dI4zKcA0Grv6LNgaCbJbE6m7Mlbol78BwIurkkpsQ1MSeWxJrYEsN3DhCt/oozB4JWf9WYgz/3v/u2jUFobQ7+rGPgWZuDPzdT4pqYE0tiTezb5q8dc/Dn5g6u07c6T192nr7iPH3VmbEvVRKnffRLpnpTxBzYuZkS18ScWBJrYkvcEnewTF/fL5m+vl9CiWtiTjx9fd9FE1vilriD9UpcElPiqe/HU6eOH0+bf+vXjM2/9WvDKHFNzIkN3KaOH/9WEs9r26+xNs+XH6s+a8GPVS+JKfG8hv34rBqcLIk18awF399Vg5N7/I6tGpxcElPiGsdnDp7cLIk1cY/jMAdJzn2fgyQ3E3hG45jeqM2BgtT9b2c0LrbELXEHz2j0Los5ILB6t9gcELhZEmtiS9wSd/C8nr2LYw4I3EyJa2JOLIk18fQl55a4g+f1vLgkpsQ1MSeeXn4e1RK3xB08r//FJTElrok5sSROvpZ8bfqycwfPellcElPimjid05bOaUvntKVzOmtnLNHU5oC96k3Cc8De5pa4B88Be9WbiueAvc2UuCbmxJJYE1vilriDS/Itybck35J8S/Kd9zjf3zlIr3qT9hyMt7lgH+d9bXFNzInnvnRnTWyJZ5Zezh0872uLk29NvjX51uQ772uLNbElbonTuZv3vsXJl5PXfPzpvm3z8WdxB8/XssX+2DXm92pzsN/mmpgTz0wjZ01siVviDp6vZYtLYkpcE3Pi5KvJV5OvJl9NvpZ8LfnO1y8fjjEH75F3v88Be+Td43PA3uaSmBLXxJxYEs9t9nM0X60Wt8QdPF+t5vbMpp3FlLgm5sSSWBOnfZyvVs5z2kue2AN9wgVvw5vTXi4kYAWOQWz+jjcH6C1UoAEbsAf6AL2FBUjACoSbj78bn+u2Of5ujBBvc/zdGMDd5vi7hQSsQAYKUIEGbMAeyHBjuDHcGG4MN4Ybw43hxnBjuAncBG7+AbU3cM5ZLRcy0AJ9ZhVv9JxzUi5koAAVaMAG7IE+s8rCAnQLcmSgABVowAbsgT4XwsICJKBbVEcX80vZZ0tZ2AN9thTx69dnS1lIwApkoAAVaMAG7Au7j2PbKKvIuo9Q2zgUxsjgfs358Sf2VWT9ioLsV9kl0q9CwApkoAAVaMAG7IFRkP0iuBE2nbDpPiB2YQP2wFmQEwuQgBXIQLhVuFW4VbhVuDHcGG4Mt7loxkTs/FwTw4+vlDjUQsAKZKAAFWjAZIHjqzi+iuOrOJuKs6k4m4qz6aU3sq/7wDDPvu7jwjwUug8L21iBDBSgAg3YgD2wXUC4Nbg1uDW4Nbg1uDW4Nbg1uHW4dbh1uPUdeH3OsrhQgG3jnCNxBFOfcyQuFKACDdiAPbBcwAIk4A68PidGXKhAAzZgD6QLWIAErEBZ2dfnvIcj5fqc93CiV+HCSKM57+HCCmSgABVowAaMwJvzHi6ExXxPHV2qfQ6T2iyJ8+9Y4pa4g+c75eKSmBLXxMlXk68mX02+mnw1+VryteRrydeSryVfS76WfC35WvK15NuSb0u+Lfm25NuSb0u+Lfm25NuSb0u+Pfn25NuTb0++Pfn25NuTb0++Pfl2+NJ1JS6JKXFNzIklsSa2xC1x8i3JtyTfknxL8i3JtyTfknxL8i3JtyRfSr6UfCn5UvKl5EvJl5IvJV9KvpR8a/Ktybcm35p8a/Ktybcm35p8a/KtyZeTLydfTr6cfDn5cvJN2TKHT21Ovpx8JflK8pXkK8k35RWlvKKUV5TyilJeUcorSnlFKa8o5RWlvKKUV5TyilJeUcorSnlFKa8o5RWlvKKUV5TyilJeUcorSnlFKa8o5RWlvKKUV5TyilJeUcorSnlFKa8o5RWlvKKUV5TyilJeUcorSnlFKa8o5RWlvKKUV5TyilJeUcqrmvKqpryqKa9qyqua8qqmvKopr2rKq5ryqqa8qiuvunNJTIlrYk4siTWxJW6JO5iSLyVfSr6UfCn5UvKl5EvJl5IvJd+ZM2M4SJ+TD/rT/Zx8cKJcwAIkYAUyUIAKNCDcBG4KN4Wbwk3hpnBTuCnc5oJ2jhYvBXWuVyeO8d5RTYEGbMB4i5zTCS4sQFi0CmSgABVowAaMtxwffTTfUXzw0XxH8bFH8+Hdhx5tNGADxpuADzvaWIAErEAGClCBBmxAuBW4FbgVuBW4FbgVuBW4ld380rk0YA8kAsZ7B1MDxnsH1wtYgASsQAYKUIHx3jEnBZzIF7AACViBDBSgAg3Y9zvKnPPP30bmnH8LGRjvHXPOv4UGbMB47/DBPxsLkIAVyEBYWFy0bHHRMl6WGS/LjJdlxssy42WZ8bLMeFlmvCwzXpYZL8uMl2XGyzLjZZnxssx4WWa8LDNelhkvy9zh1uGGgmQUJHdctHiF5h4XrY+32RgXreBlWfCyLHhZFrwsC16Wfbq8jQwUoALjohW8LAtelgUvy4KXZcHLsg+d2ShABRowLlqpcdFKrUAGxkUreFkWvCwLXpYFL8uCl+W5kvRCAlYgA2HhN4kxRLTPtZIXMlCACjRgA/bA2eQ6sQDh5tfvmCWkz7WSFwpQgQZswB4422QnFiAB4dbh1sNtrnQ8Jirpc6XjMZK1z5WOFwpQgQYcWzYGova5pvGY4aPPNY0XViADBahAA7ouOfZAv2gXFiABK5CB7lYdFWjABuyBfutYWIAEdAt2FKACDdiAPdAv5YUFSMAKhBvDza/qMf9FnwsZL2zAHuhPeAsLECdLcLIEJ0twsiQCZK5TPIbk9rlO8UICVqCL+SXnD3ALFWjABuyB3mi7sAAJWIFwM7gZ3AxuBjeDm9exel14HS90Bb/s5yrDftnPVYYnFiABaxTZrMKJAlSgARuwb5yrDC8sQAJWIAMFqEAD9r1va2nh4liBvHdoLSI8UYEG9C4ZcuyBcxHhiX6gqiMBKxBuBDeCG8FtLiI8MU7LWkR4YgESsALhNlcOvv7P3//d44/+99+NQmvj6WaU2QTb0DZ0h8ef0PiT4v+pj/+s4z+97scQCa/6AV7zDmUDbagbeINs0A22YSvzVpatLFvZa3sMyvPKduANskE32Ia2oS/wYncoG7aybmXdyrqVdSvrVtatrFvZtrJtZdvKtpVtK9tW9mL2mSxtQ9vQF3gRz296N9CGuoE3yIat3LZy28ptK/et7AU/xjl6uTvUDbxBNugG13mk91yQaoxFnH0tkzhIgjTIglpQ3+SlO6kEhUcJjxIeJTxKeJTwKOFRwoPCg8LDi3iMAZxdLJM4SIJ0k5fnJP8LG+R/0QZJkAZZUAvqm7yoJpUgCqpB4cHhweHB4cHhweEh4SHhIeEh4SHhIeEh4SHhIeEh4aHhoeGh4aHhoeGh4aHhoeGh4aHhYeFh4WHhYeFh4WHhYeFh4WHhYeHRwqOFRwuPFh4tPFp4tPBo4dHCo4VHD48eHj08enh4KY6Rt3MFqEkaZEEtqC+aiz9NKkEUVIM4SII0yIJaUHiU8CjhUcJjVt6jUoiuoBJEQTXIt6UMsqAW1Dd5DU5y3zqIgmqQ6/EgCdIgC2pBfZPX5aQSREE1yD1kkKw8oFmXThbUgvqmWZdOJYiCahAHhYeEh4SHhIeEh4aHhoeGh4aHhoeGh4aHhoeGh4aHhYeFh4WHhYeFh4WHhYeFh4WHhUcLjxYeLZS98sjJgvys9kF9k1fepKEyvpyYKydNGnrjq4a5btKksaXj64a5atKk4TG+cphrJk0aHuNrh7li0qQS5B42qAZxkAS5RxtkQS2ob/LKm1SCKKgGcZA3/lyDNMgbmsqgFtQ3zbFBNKgEUVAN4iAJ0iALakF9Uw2PGh41PGp41PCo4VHDo4ZHDY8aHhweHB4cHhweHB4cHhweHB4cHhweswuiDiqLGB1EjL4cRlcOo+eZ0fHM6HdmdDszep0Znc6MPmdGlzOjx5nR4czob2Z0NzN6mxmdzYy+ZkZXM6OnmdHRzOhnZnQzM3qZGZ3MjD5mRhczo4eZ0cHM6F9mdC8zepcZncuMvmVG1zKjZ5nRsczoV2Z0KzN6lRmdyow+ZUaXMqNHmdGhzOhPZnQnM3qTGZ3JjL5kRlcyoyeZ0ZHM6EdmdCMzepEZnciMPmRGFzKjB5nRgczoP2Z0HzN6jxmdx4y+Y0bXMaPnmNFxzOg3ZnQbM3qNGZ3GjD5jRpcxo8eY0WHM6C9mdBczeosZncWMvmJGVzGjp5jRUczoJ2Z0EzN6iRmdxIw+YkYXMaOHmNFBLCh/QfewoHdY0Dks6BsWdA0LeoYFHcOCLBFkiSBLBFkiyBJBlgiyRJAlgiwRZIkgSwRZIsgSQZYIskSQJYIsEWSJIEsEWSLIEkGWCLJEkCWCLBFkiSBLBFkiyBJBlgiyRJAlgiwRZIkgSwRZIsgSQZYIskSQJYIsEWSJIEsEWSLIEkGWCLJEkCWCLBFkiSBLBFkiyBJBlgiyRJAlgiwRZIkgSwRZIsgSQZYIskSQJYIsEWSJIEvEYrCAmAIN2IAxUEDaBSxAAlYgA+HW4Nbg1uDW4Nbh1uHW4dbh1sNtfTTMo5mORyPbONFtNGSO0zyBN8gG3WAbRguermYuh3FiJ5QBNJu5JtQNvEE26Abb0Db0BXZt2MrmynU2c03gDbJBN9iGtqEvaNcGV+bZzDXBlWU2c01wZZ3NXG00djfb0Db0Bf3aUDbQhrqBN8iGrdy3ct/KfSv7pJGLShAFuXpbjWGLJEiDLKgF9U3lCipBFBQeJTxKeJTwKOFRwqOEx0jwNlqOvTGsjaZybwxbNDxGi7c3hi0aHqOR2xvD2hi04tM/NvOGtBbUN1X38KYy9xhHqFKQe7TVfLbIPfpqPmtjBT1vPmtjpgVvPlvUN420bmOOBW8+a2M2AW8+a2M+AG8+WzQ8xkKZ3ny2SIPcQ1fz2aK+SdzDVmNO67Yacyb5xTapBI0t6LsxZxEHSZAGjS0YHwJ7Y86ivsgbcxaVIAqqQRwkQRpkQS0oPEp4lPAo4VHCw18VxyeqszHnKrsJZ3y+O5twJkmQBllQC+qb/GXwqrtZ54pmnSuada5o1nFffxmcpEEW1IL6ptmHUXazziQKchXeDTeTWlDfNPsrdDfcTKKgGr/HQRIUHt5wM/+iBfVN3nDjv+cNN5MoqMbvcZAEhYfGfmjsh4aHxX5Y7IeFh8V+WOyHhYc33EyK/bDwsDhWLfajhUeLY9ViP1p4tDhWLfajhUeLY9ViP3p49DhWPfbDm3XGR8azWWeSBIVHj2PlzTrjk+PZrHO13axztcedW8ad2wOv+a8s8LhzKBtog+fQ+Fv1njYPnv74T4v/HB9pemQ7eH2OZPLyHLvo1Tk65xr+5Nq/QI9/775V3u03ylQ32Ia2oS/wDXYYGzxG+PgGO9QNvEE26AbbMJRH37rH8gBPZYeygTbUDbxBNrhyXV2VDm2DK/PsKZxQNtCGuoE3yAZd4A86Dm3DVratbFvZtrI/6IwBOP6g4yAbXFnXg45D29AX+IOOgyuPkzjC9nG2xn+PcWd+53WoG3iDbPAzOq6h8use3scf/e1f//Ef/v2f//Vf/su//9s//dP4+/0P//Pv/tN//t9/9z/+4d/+6V/+/e/+07/8r7/97e//7v/5h7/9L/+l//k//uFf/Oe//8O/Pf7fx8n+p3/5b4+fD8H/+5//9k+D/s/f46+v53/6aALl9dePNlANgcczzm2JansDHk15JUnwHxL0XMIXgHGFx10zBB4b9IdAfS7Qrr0XrfanAvxcwGcncoHeXxPQvQWPh1F6qnA6jtLiVGhpT4+jPZcgnytxHshHMy0kqv0h0U5nU/ZGdIGA3b+iFFeUVnu6G+Wg8XiJ3VvxeInFfuifB3P03D+9pHg8Fs0T8nhxfypBp4tqXxOPOMZ+SLuvIHs3Hg/czxUOlxX52r3zjD7eVEKD6U8JOWzEePqel3ah5xuhh42ofUs8ntTSxa302vmw5+fjdFUY7xPyaI3gpxL9sCdSYk8erR/PJOh695zS4VCQr/u4zqmUZ+eUDheWz3G3UvupwA/HsuBYtqcH4v3EO0lUH8C80qYfbh16urAstuNxdkPj8Yb1p8YhN/Xa9x8lTQpye08e3Uq7Th99Ps/Dm/rpLihRIo1S+Jb+533wcF4f7QtxcT3+rqBKHi0Kf6qU949ppXeP6XFfHnb7oI4Z8OX5vpwS1Fe1W9XWetqSPyu2HiL08UYWGkYpvH6xL7Vr7Aunqv+2L6f7u8oWebxM4ng8EuVPjdMN3lfTnTX3uDMmjS/b0Y+PfPsiezSg1ucap+3wOaqnxuPd8qkGH67TR3fP3o5Hx05/vh3HM6NXlN3j7OrTM8P1dFTjCnn0rR80Tleq9hJXWb2ea5yuVF9RYWo8Wlpe02DmuN335wnCp0TlfThU8Qw4rpU/FNrpibzF7aX05xKHy1RLQwbJ9VRDTpeH+eqdc0OspIv9m8rhQn10oe3T8uhCS5fHnxkkpzw1ikNq3J5JHI8HicXxaM9Pixwu0jKmDY27lFZ+fmZOl7rFU9QDn5fLsXBrjYP6aKzW5wUjdrphekvGumE2u56Eu7S/9PbAVzylP5rM5fmtTq+/9JbLGpfIg/vz25Senk4r3ufzW+TjZeZPjfruMT1uBZeIQubr6VacHsnIl71eDw9Wnj6SqZ5eiOPtqVpqnXg83tzW4Brvolz/uNK/aLT3H+q0v/2gfDyi8eoy7lVPj+hRgyo0DmfF3m5ysrfbnOztRqfzkWhRJY92l+dH4vQCVXvcaTnfWL7cWcxOD4QU13ht9lzj+CIX94RHqR00TsfDZ2Ve7/esTzWOx1Q5ckP/2JdfXKEax/TRS6NPNdrbV2h7+wptf+0VanFDefT9PK/3dmp/ugwNJjW/GP+ZXO1whZrGrlhu8PiNxpjBfR9Qza9wXzX6+yncr780hXuNF8lu+to13lu8BF7Unmr0+u413vnda7zLX3mNP363x8tfpedHwo6vofEWWv+4xu2+hn+hvw5n4+cap+tTq0YMa235iHxtwD+1kkafUEs36PrlIfLcQnmhhTK1fOvtDhWucTge9zU99ETUYwdZNLWWP7oz9Bcivj7kf3SBfBWR93s0Ln27S+Moca9P42rvd2pc/e1ejdMVdrtb4/ZZOfVrHBuPosGl0uG+4ivKvheEpbx9tz9L3OsUOB8OiSisejwcp/u9xQXyQH7aFXoWadGXaX8UzDeR/oGeyOv9rsi3+63KsdfpZt1SfbtuT30t97sj+/t1e748NK6x1l+8xsbKxVG4aUO+idDp3V5q1J2me/bXfvtz3fUYPVAfDevP6+7cgnTvaj91P9282o8S9672Wt+/2k+dTzev9mPf092r/fZZefUu1aPl5tHbqYfLo33g8ujvXx79/YEZ5f3Lg+nty+PU8XT/8mh/9eUR6fG4PNprD8p8lWjnvPhwjZ36nu6OHuIPXKf8/nXK71+n8oHrVN6/TuUT1yl/4Do9Xh3vv1ca7bc5NuvP3ytP/U5K0QKjXA+3/VPHU7/QR5ou9G93/fPxIBwPsheP6b2RWXq6ThlNUo8O6Oca9H7Van27ao8S96pW5f2qPXUa3R34Zx+o2ttn5VC156sjRq08rg59TUPQPCb6/L5g5dT0eu2GLb0Kv6Qh3fodjfO+3BrIWIzfvtKPEveudNP3r/RT99PNK93aaYQGRYRR6i3+dqUfu59uDcs8Ho17Y0O9E/XNrTgcDPYJVecdrqdK+X4wbou010TkilEvch1Py1FE49xeeTjS70SidUweLYIvipRoMZDSDyLt9BQ0VhfagTrW/oFMaa9GyNMhwOXUE2VoALHDK9D50eHOQOTS6QNvDUeRGsn+eB47vL/047gmxbgme36L6R9o5+/vt/P399v5+wfa+fvb7fx0faKdv3+gnf98deB4tMON/6Tx6EpCX+Phcf0HjettDS5xl+HUr/8rDYw8ecg91fDOszcfyI4adx/IzsfDNPalt7c15KIXj2m8nD66P5+eWzp9tvRoQo6BlcaHB6rjhhgeQ6zX5xvC75/ck8ZHTi5uUrWdtuPUOX91jDPNo7t/dVDRIfXomn/+2c6p54OjL5rpkKh0HHrbY4wAX88f7c7bUeN+mz+Y+XY4jvfs6Cnkmjtgvtyz6dQjdbPhgU5dUjfv2UTy7j37LHHv27TTp1A379l06o26ec8+Di66ec++f1bscFbq2w0PZ417DQ906o26GWM/bMe9rx/r+1dp/cBVentPnufgqdPj3rvLMX44PmFiTWP5vsUPX++O26BTV9TNcRvnXSkYK3V4+zlvx83BH8cN8XlR92s2HTZE3j+m+u4xPUt84HBIQbNU4dPh6H/llS4cN1qR/vwNm+T8tR52JSTo+pLop46oe1+F0PlTrGhvSIPdv2/F6WPfEu8tTPkZ+77E6K+p6LuR6zURDPh8sJYXRfC0X3LH/m8OagzylnY6tf0vlSiX4bn0auX5rvRPnJn+iTPT3z8z58rVGBkkPY8M+k3bmJbYG/3z6/ZfiUT9P7bp8LB+6pCKhs80Pol/kafKMeJc5Xr1cFSrIWLPByiSvX/ft7fv+2eJD9yjVGI7VMvpcJxiSHxi9/Ww3uVp7drhvq8an+s9uvYPd8tTF8wj0uNRiPrznnmy81D86Me56vNXj2MHyr0X9VOHVGkXph1oj1P8tKvgp5NzVZyc9Kj7i6qxGs/s9mjue35yGr3dwE6nz6Luvqy3t/tOzxL3XoPa+32n1N7uO6VTh9Ttl/XbZ+Xwsn6+Om41sB81bjaw/6Rxva1xr4H9rHGzgf3U8ZEaHqR3e0njbjvuze04apyPKT7UynOwfNuO/oHj0f/qfbnV4XBb49Dh8MM1dqvDoV78fofDeUPudTjU08dNN0/uUePmxX53O16/QO51WtTTJ1J3Oy3OG3Kv06IWevdZqJ4+kLrbaXHejludFj8+6XJ60n06X8hpSr67j8tHkZvtGMfnXIsZqYrp4SJ7/wOp+v4HUvX9D6TqBz6Qqu9/IFU/8YFU/cAHUj+8BcXbB+VvAr6d2fc7589vUjer9tQv5l+BrlNL9aXDQSValh49o/3p4Th92HQzCE8z890OwuN23DukP7RvpbvLlcbU/aaR7PGHHSL0NAirvt/SdhT5SKvw3SPCHzgifH3giJxE7h2RHwZMlviWp9Cr4z/LhT4lKs9Fjh974ob7aGW2p81C9Ty13q2xBpX1/dvladTlzdvlUeLe7fLUL3X3dnman+/m7fL4hdTd2+Xts2KHsyJvjzU4a9wba1Dl/df1o8bN2/YP+3JrvEI9fSJ180o/Sty80m/vyfMHodN47Xu9uOcIi1lZLL/dfoswre8/8ev7w6Wqvj0Q5Sxx78Tq+8Olqr49XKrqB4ZL3T8rhwg7Xh03n/hPU/PdjY7zdtzqf6nGbz9qnzqk7j0ln7finsRxLs177y4/aNx7d7G3R576rK5vv7vY+yNPz7N2xJR0rbTnK22cZ7i69+Vtf/95sr3/vUltb39vcpa4F8bt/e9Nanv7e5PaP/C9yf2zcvre5O3HyfN6GfeeJvv7g/iPGncbgd5uIaT3Z1Ko/f17/XGGvvuf/91eCeXpjZqvd59Ij+t/WAw/eQR2nhyUv2zFcXI9dHLWfG38QgLfEfwxfe1XCXm79ed0MLRHp3G75HAwji/2txbCuo4T799aCusocXNpGH33lBwXdYlJ9fIkct9mST0pKBYxaM8Vjt000Xw1puhKGnpfg6Mf76EhTzX4tAhU6RSriz24Pzug9e3mvPPqNKoxY8mj0zcl4Ne1JUp7u+KPEvcqnt4/HKcbimFeY8sZ/KV35N1r/Khw6xo/LhZ08xo/Lzh08xo/Fsrda/zUdUbRVPzH9PTfVgs6aQgmEBc5aBxXpaF4SXmwPl+IgU8yNyvlKHGvUk7X2AeC48vh6E8Px3n5JDwQa83LFtUXNex9jTTc5VfLOF0aTwuXPl/6iI/zvvm64vOotlYPIqc3phj/09Kozt9JxNRxTexFCY6tSLNIvCqh9bUDSoKVKfK79C9FcFvQIi+e2l7i/bGfzks5PZHG20rNs4r+aomuGjeYx/bW1zSwzBf39vzs3l6y7KRxd/k1e163LO++NB23wjBpfrvqYSsObzwmUfkm+cvpL6tJyXGqgYY7Q+5OsC8ap46RniYryp/7fdXQY4d3rDb24LQuXmn3j2qjHkc137R/k+st3nseqM81jnc64RgC8EiC53c6Pi0F1dFEcOWGBpMvx/XU4osjUuSwlNxp7rcW3QG9PD+oR4k0JCL3KHzXOLUf3Vt/jU+9RXcXYDtOhXfF8nwlT2f1fWeOo6rwEtX7IQBOnU53A0D7+wFw+gzqbgCcPmK6HQDnc1OxBFvt9NrF+qdIP4Tz6R0Etxlqhyf/owbaKh8vAa9pVEXnwnVYB/LYdx7PVO21RRwZremPl8T2koaUGPcvpR2WLDx1PanGK8gDy2siVqOBzmoamvVLkSYh0tuLIoy1DbjWF0Va9A9Yfmj+1cnhGK4m+SOVX2lYHBFpV3lRI96opNHpIjk9dtcrPth/8OmQHFeJIgzef7Ce9uj0MCGCUXyi1/Xy1uCT6MfWnAr5OA9sE6w016y9eoixgvGD5dUrJs87aK9pYJCB9LSE8a/WqL3iytVSXtsOLfHmquVwyZ3G0d18ujkulasSMfvg9P3trxbcVTyZPLi9qqJoC1S77EUVI+xRXsjvlyrRpfLgQ2CfVVr0oz64lFe3JR3dVk5HVz+RT3LqrRr5lMYe9P66zL2Y+2mnbsacHL+ZetwxC2LudIh/kLmZlj+cb0nXnr587cW0xA+WV6up46LRrvyqChbk1m79NRWjWCl0sLyqgsWj7fGO+VzlNEDiI8tyG3phmkl5UaXh04HWyvWiSk/b0k+PysfJUrFQsJ16Ck8aDQPfWroH/E5D0DCkz9+Czo06HfVT83cd35Yqp+OXpXfW/TxL3OowPEvc6jH8Yc319HFJv57NjiOnY9qLoWnpab/UWYJiNqlO1F7pl6qCBp2ax9H8biV7LBdcqpXnKlL53c6+s8Stzj55/zOoXxwOev2gouasvli5Y8l2qMjzlhTht/thzxL3Tg3/tf2wfx6OUz/sD6cGL8lm11OVUxP3vSg7Ktwb+3B8SKs1LZ5+aCSTUyvZvYEgR4lHGlYsn678ooil55l8tf9OJDqoHtz0letsLNgbx1Xq89v/eeEZjSerB/fyksqjKTUeRGp6iKCrv6aR3gh+pSEx2+ijgbi8pFExdLTmFaO+abw/reVJgq8SHbolNzbQdV+jREv7I9f4qYacvqm6mctHiXu5fPq24l4uHw8GVXxa8cfD8teDcRrC2uO99dGOpweR08wlmBovvT58bUU6b4ZiM9IUX7/cF0w2+sfi9L8Uwbox8vJRjS9WHq0P1/Nr/Tx/QSxwUk8a/e3bZX/3dqnHZWrvDRU8atwcKij2gaGCx4nTJF7HmtDz2Z/F3h7Kepa4F0Dt7aGs54OhaQjX87WD5Txt2p2DcZo2vlJ8RVRr/sas9C+bcZzb784Yejl9vXNvDP1Z4t5ttn9A4viqjlcx+mNpJfuyK4ez0qNRqafZF+xPhfMnL/fK9aihPivTajek9LXJo0v2FyqYxfLB6c7yWxWCCtNTlXJa2AhTpecJoOqXZ9sfNgTfU+ofH1T+aneY0U3CuTfgVyqSDq2kDyK/qsjpC6sPydCF76Ou3IT59b3uKILZ2x/NzfKiCEW0EtlzkX5cxzP6jugR9k/LWK/3Z+j8QQNFKKU+fwI4itx9jDhvyb3nCD32PN0NptO5YVwk0tvh3BwHUcQobPljXusv3yPrscvp3tQOWsrNi+T518R6mmTv3qeaZ4lbXxPraeGom5976umzq3ufe+ppkr67XxPfPyuH0j1eHfemdtDy/sSnP2zHrakdlN6eRU1Pc/3dn1r7vCW35iI4HpCb0zv8oHFregclff+gnvL05vQO5+24dUh/eKBJIzY4DRj++gyh7399pe9/faWV/lKJe++HPxxRjEh/HF15ekRPb2Y3X2hOL6qPRu0YO6nl+Uo2x5ddjLdqlfjFl92bp6W//dp++uRJYwqSlpuFvu5Jf7sfpr/dD3McoXjzifCocfeBkD/wnfVxVn+JdljKA42/nhTl9yfm1WNPzs1nudPYxJvPckeJe89y8v7UHXpae+rms9zpq6vbz3K3z8rhWY7fn5hX5f05yn/YjnvPcvL2MikqH1km5bwl957l+P1phn/QuPcsd+ySundQj9PJ3X2WO27HvWe548DmGF/d5LXbU4yY1fZ82JW9/9xymju6Ukw/+2jkzr0N7b6Gxa269j9mmLmvwVdo8JWHw3wtFHu7of+8GfGAzuW4Ge9PePiDxs0GrfOSADcbtM5bcvP5xdr7zy/HRadYMBKl2PPL7DQ9FUazkKq+piExmIUeR+75NdLo3c4gPa1sdK8z6CxxM0CORzSNp730cDQ+sOyEtuMH7HFu6/VHJ93XLTnda2+u0qbHR/6bjx+nu8PNO2UvH3n8+OHk3FqljY5Lm7Z4pczPDl8nIdN+HLp9a5E27e/PSukDCd989+hvz0qp/f1ZKbW/PSulXR+YlfL+WTncMc9Xx61F2o4aNxdp+0njelvj3iJtZ417i7TZdW+RlNO6VUeNm/N03t2O4zvh+ZjeWqTNTv0dd4/HTY039uXWIm23NQ6LtP1wjd1apM2OS07dXKTtvCH3Fmmz09x9t09ue/9iv7kdr18g9xZps2NP1M1F2s4bcm+RNqO3J0w3kvcbDc7bca8d5qcH3TuLtBm195+WjyI3BwcfH3PvtQVbfb9f3+rb/fpniVvPY1bf79f3l5Q3n8fqB/r175+Vw/PY+SXoVluw1Q/06x9fpG5WbX+/9fSscav11Pjt1lPjD7Senrfj3iHt77aenhXutJ6eP3yJd9IHpjmVfvPxjOIDHO31NY0WkxVQbj793Qc4eBC76Pm+iBzn/rz3Fc9R5HE+o9+22dNPcI8SPcpNO9lrEug9zquq6f2zYnGjJstTqv3mzP6hwS9qEDTq85Ni0t9uGD9K3BpXYO9/0nSUuPnUcjye+h9+E/m7c5LaPPuLyZG341UNPLaM6QRe1GC6pfF2X5i+3Rf2w1f30dnRiV78cD+m2X3g069Uj7MY3DoUP0jcORbnuSUwXfAfj8S/mp+iYDrYw7fyZ414nqU8T9/vNFAnrT//pPuH+UcYM4c0OUxldV/lNA/VDyoMFXs+Q4yHzNMn43szj9qpD+ru3FznOVkIU333w8yDPxwTvG88TvLL88Pkbakvq+ANvXV+cTYhI3zA/7iD11dVNM0D9PKcRPjM88FEr6pwUpFXZzaqNavoqyqpzbC2l4+LJZV+vajCacYnplfPNF9Z5eWrDtPEPt7gDtly/DiP08dofLpgfpLB1BGPjSkHmWO3/90Jy37amngxefBhOsPf7NQbMoaJKPK0wF9l2vljo08dm9QqkKcbeWOn3pDhguk1TnPItuM3VJ86NlgL8cEsH9kpfjU+rwtjYPLy6b+c6q5fSeX5xffDTL8xX/gD+4siWjBunuxFEYnBRY932Fd3x6Lh1NrL8zDn3XldBGs5qL06D7PFaG+zwq9uSUx38RCRV7dEsDSF8AfOTjlEAn1opuDj7NRFb10px0nQKyZSl8MkYsdFpWJJB8pjN78uCNWOC+Ldahpq76+p16j9pRI3ZyE7Hc+KmZCqPV9gq526Tm5NVHPcCkbjUu7b/74V9e3Xw3bakJuvh+clywirgZI83ZezRl4r9vnxYDqO2by3dtpR5F7T9lniVtP2DxJ3mraPa/PdaqM6K9xpojqugXlrG84Kd7bh1DEYvR2aP7aTflcAi3JJ7jTWcldAY30yzS1bvxCIIU1/rOwqdlcAqxO1XOG/EIgnr5aHdX4RaHJcDiyG7abR1GNRr1ckUr/VV4ljy2+MpU6L7/3iOBBuHWqvbAFhqsb+0i5ohFOelr7Y1zNx/PohPn7IF7TdPgr4ZtNS3/L3bTh1+VM0yjza6tMjZ/2zLtupO4HS4j/l2UiMo0JRvPVpfsv/zWYU9A4/mmboRZEeT5ulk3xApL6+JfHy2VOX6C9F8Hjzxwvsr87vVTC2hA+7c7zSKsUMetVOx6Qf6z49rb0ugqeT4zE5P+IQHnFe3RLB2kyaG3B+KYIwzEsr/UrEP1ZdInllgN+JpAlwr5e3JFq1Hp3x5UURw+6YvLolZuirvV7eEkPnYJEXRdCJRX/0p/1OJN6VqF+vi8Qx6eXV2umonf5q7TwayuMphPjFA/t4Ea54EX6xACvHPbTK9TyoT8+2eNXJQ81U7wrcXjzv9HAZbT5/PFzefhzpcQ/PL0pf/r718hfvRawG0PLst1+3ot55rNL8ie5vFBpeltqLClc82tUXzkXBa2vpaa7ZR0/eSxLp/fsXEmPOPTw49NckMCDh+uOF5RcSsTgXXf3FHYnWLir5zvYrCYbEi8eCog/gwflo3K8Pxmoq3Gp7KuFNJ88ftSnNfJl25svL9FkESwYWzo/avxGx6IL9Y0mu+y/1j0BC7KUW2cK/eCuPD1D7lVdQ/SLRT3N3scaE2ZKXgn+8ytwXEYyKl5IO6XeR41i5iFDK71H6i+0o0VYuJWXHr3bm0WgVMWoqr4p0NH3lD6Z/JdLijUH/WD3oi8hxoZsYcdBLnrHq/mX2h0SeqvrbZXacJCWNt0mNUPyrw0E4HPXVE4PVg/TP540vIqcuprsn5ihyc160887EXUr7Hzfs3xQvnmgfrfeHonm/g6m/38HU3+9g6u93MP1wQONL+scBPVynx49zhDCrxx8fPP1KxNI3/faiyB+NZNcnRPRVESzKZPkZ+ZvI2wNvz9vRMAKm//Ex66/KTlF2drpK+ptNoEeFe91dZ4lb3V0/SNzp7jodTYzPkz+G591/zBWJW9TjvfhFiRhO/VB77ZG/YO6avDzxI6R/IYFH/nR3+pUEvnii9NbwGwkMsydKRfIbCbyO/vnd1S8kDG3IVl87nBRLexPZaxI17giPo1Je2wp8P1avlw6nRDegvHYkpGOlaHlFoFx4f8vNLL+RKPFZYsmrP/1KQtHa017bipqWB+yvbUVa/FHYXpNQfMDb+ms7gpfhvCDFryTQYFPltR3RKLGSx8L9RsLwqGP9pfooWGrk0Qf3koRFO2Je7/sXAj16mLu8dBx6fD2cv9P4jUAURzd5cxdeExCJHuoH2ms3YrzT5LD7jQTHBSWcF5L/RVOmSVrLME+Z+OVh0+zdZpHzZW14WtWnW3HckRaJmSdN+bYj7dhCfmcyvH76HureZHhniXuT4R2fjWIriNK0Td8PxukDJDWcFbXnL5o/iNS8Pnt9KnKeMBorQ+Yxqt925zTwvcVhpT8P65clfE6z8rWCgU5F7CCixz7LND9gfb47x0lbS8WTTho0UK7yCxGNxsjHG29/UQQdn3+8W30XqW+/8p63Q9M7Xjtsh3ygD6DrB/oAjrvT47DadZ3OzXEmhXgUHZMq4PW7fF236rS8WYnJT3pJvXZfRcp1HZ/BhLDqdc+9Td+O7XFjYiRvJzluDH2gjo8Hl+Izz0qp1ek/2JTj3Lgthro8WsC6nHTkE7t0fjiM7yxaTtovF91jU45z8xd81pMnppX6VeU0/RiaKPk6afT3r//H/l2fKIDjGkW3C+CHfbp92ZX6mcvutIrU3cvufK6Rui2viPvtXB8XkhI0P9glhy0p9pfvDz5/vVJjyn+wQ8eZmhhPcaUdNoWuj+yQHW9p8eJp7bRHdJwdKF6bah5v8B+o1E+caPrIhXvcoxJDgyqxnfZIP3Km7a++A/R4B7KupzvA6dsQxvSTfKVnwu/ZcpoGZYx9iGEQaSB4168ipyH5JVpoHycrPVu2byrnea1iSqrcpvfoSfyqUj9xzR33iDDHVk23o/9gj+Qv3xYumMw2NUH8B9tymlYXw6jlylWkv7nmUESPpxg9XXP9L37De1wicc3R9fz9u1xcPpFzTH/1DlFFzOXZ6L/vEH8i5vgjD7qnZ3cM6ax5bpVSvtbzcXmfX7zTnDYGs0tyyd/MfN+Y/omCPj5d3j4w8v/Hs+7tIyMfiV06fhAUzWGPpls9bYt84J4m+ol72ukrq/v3NGmfOLjHPbp9T9PrL9+W2/e003x2H7mnicZKjPLHm9G3a04/8Kh7/Eb1ijFHVvsrLfSshK/62A73ELV3m+gfGu3dNvofNO410v/UOI4ljdTk2UR/j+Qr7zexn1VuDipr58XC0YsjL7ewRz62kidz+Z1IfNXdqNAhB0yPr0IxvUbP3xZ9VzmlbHxbzeV5b+e5KRhNYSrpw6/fNQVjfs3atbz8kHHv9Pykcvf8nKYNvH9+TktPfeD8mLY0sQwd3pnb4ckAE7HU9NFWoa8SpyUrMZRIzHKj6fWrR8C7V8r5oevulXJWuXul/NCocfNKOX2Dde9K+aFRO24b0tuhtejUV8YYyMyV+uEsH5tL0aJHyuXl5tK7Z/mscvss20fOcvtrzzLm/+x5cPXXs1yu44ciMd+2lD9GEl+/aEOWgguO/miJvn7Vhnz3LJ9Vbp7lcuovu32Wy6m37O5ZPrX9EgZjUR4K9R+c5/OCo1HNV+fTGaqfqOZzm/jt88yfOM+n7rL75/n0xdYnznMtMWS6Fj208ZdTRxm3eNbn1uR0nvUj9fyR1Cb7yHluHznP/f3zfGyaqRUjZlMf19emmUKn96gY2M75JGv7hYbEckaiL2tg9po0XfMvNeK7XM1fbr2s0V7U0Dge+vLx0Dge+vLx0I5ZheoHNF49Hljuyl4+HhbHw14+Hhb70l4+Hlnj1eOB74OavrodLb4fz9Nx/lIjms77y8cja7y6HT1yuZ8y6IfGYUxlduUJ3782DntX1/N3WsEsInli89+p/DGNSHtVBcssVc0LBPxOxaIBcqxt+H9ebTS//XL8iWYu73d7/wbM9oEb8PHzWqxYW9NUiL/tBLh7bPUjLyvykYdYob/42HI83Dw6NcrzY1tOi1LUEn1gjy4jedqpUY7PWanV+8/ZC76KnL6RvTMVzQ8Sd+ai+UnixmQ0534i7tGaI5f054f0dLUyHrNY82jJ10Xq8x6r+51nh67Josf1BPDpAdd22J/TvMHeBr2ePfvpoJwu1oJu3wfnMbHvyBz6A8+9x1e71Xt87FTkeMYQ4UOnejnN7TVbr9YO/TF921cVO11z0WXE+WZK11eN4wgvJBudNE7bUSJi80o73zXqJ8Le+AMtFqczLBaZormF+NsZPvV/1fg0jNNE99/ehs+dX/+RxGhE+U3v9e37+UcapdonOhJKe7sj4YfPIGL0dqfrNMDy/BnE3UN7Vrl9aOUjh1Y/0Hp//CIjdWQ/7onldHTlI0dXPnF0P9IDVj7RA3b+mOLulXtWufkZUOmfGAP+g8rN8/yDyu3zbB85zx/oAzt/YHK/ispH4r984ujS9YkRB3TV94/ucWj8zbZqOkXLzbbqo8bNtuqzxr226rPGvbbq2xrtRY2bbdVnjXtt1WeNe23VtzVePR4326rPGvfaqs8a99qqb2u8ejxutlWfNe61VZ817rVV39Z4dTvutlWfP8652VZNp27r223VZ5W7bdVnlbtt1WeV223V9SMDueonBnJR/cRjLNUPPMYeNW63VdePvCJU+cixlY8cW/2Lj+3dtmpf2/jdtmo6fQ52t62aTn1G99qqzxK32qp/kLjVVn36Tu9uWzWdvgK721b9C5FDW/X9jxcPbdV0/AjsZls1cXu/rZq4f6Kt+lcyh7bq89e7H2ir5itaCx5yhwkc6DSK+HZbNZ06v262VdOpAf9mW/V5O+61VZN8op2A5APtBOfPduNie7QRHz7bJT137t9oqyYt77dV1498HlE/8XkE6ScGypK+PVD2/nxX/Hy+q8eGHOfvujU9+w+fVN8eJssfaTbnTzSbk31ihAHZB0YYnG7J94em8keeiPkjT8Qf+QCMPvABWDsPjIl5U2qe/778QoQvDEC+9PANP516wD6jcm9K7x80bs3p/ZPGm5N6E6bhoyJP5zd/bMVpDe47U6SfNgJrm1BJK3l834jTaO74hq2XPF/818ac03eXYx5PzMKZn9d+sQyPFCxNkCYMvr+ebhLg6xUBjQfX3PbyG4H0wldeEogZbvWPlabvC9xa1vgo8O6qxrc+KD6+PxgWQUozula6vYLRoyLj7V0qvyRhMWdJyV+t/0aiYQ7slmZr+I1Ej09QSs/TUv5CQjHTr9prO6IdE1hfr+3IlWZGa69tBcXn+4Xy9/u/kMDihuXx/vHaVsRnW+WPlZZ/sxXxWXepRd89Fi9LSMeOpMAtv9kKwxmh9yX0JYkas1A/sL0moehVTdNt/EYiRw6/dixqR/CleZ9elnjtpOaJatJCIb+SwJz5rPqiBHYkr2zxG4l4AC/cXjupHK2NJa9j+rvrAgsh0EsnlWNJnz8aK+8L4NIUen4cSj19gDibZXdcpAfF+893jGVw7KXdsHi64pfOhQhGR/JLAjHXvPT6mkCMeOj8nkAe7vCrg4j25peyUqMVMk9x/doWvHYa64U5oy5uTxscThIlLsY/5tL91mZRTz1NmKg7DWe7P1m/RV/v4121v7Ibj+bieAvV/PZ29S+7cWwcq1gGu6YJge2byKkliQir7KW32e8i57FjJa0KR4eRefU84WBMOUW5C/Dr49FDRd5/4PxB5eYz5w97RPFmSHlJtl888D0eXAsulnq6WM6zbUYHXGnYHfvFMwomQ3kcnLzQ5bctOc81GLNtDMmkol9V6PRikpouristVWRfz8+pp4mKYjWvR4OovHJgGJft4yksD4u5bq+brliv6PEqj72Rb3tzvNljhbQHp7YM5V/JVHQoUk2L3XyXOfU2GYb5tNTz9S1apH8mWvT6RLSc+pzuR8tR5Xa0HPfoZrT8eK5j7tsxPsOen+tjt5NhiqPU3q2/3BQsgUa5r/T7phyntUtrJPW8SNK3ZDhNGHg7GX7aGqwOTNdV63OZ0/dOXQQ9/PnR6X7AWFx0ammC128Bc+p3euwr48rNqxR/rWk7Pi7Egc1TMX5t/q72id7Sau9PK1RPvU53l1F8qBynJr63al7xSnt6mdxaqu2H/bm5vmWp7dgOe2/xvDEa/rA/t9auO2vcXSHyh/25uZLfD/XDDa0KeeG0b/XTzuPNY6A35ZWPv04+WNs5biNTKM+C2MormdIufp4pp06ox/NzjMzM446+bsdD5bT4Ro8j+2imTbegL0vKn1UqVtCsksdq/05Fo+XnkWHXQaUfJyS+tZ5OPU09eHs+7vqRT51q/8R41drfH69aTx9d3U/s00dXd9d8/UHlbu7zafLBmzl51Lifk8dje3OB5ce21I8cFf7AUbmnYS8fk7t3VD6v0nXzjsrHqS7vHpP2gSvlvD+376jHlLw3QSufJh28PUHrcUturonFp88eby8hwuUTo6m4fGI0FZf35xni05SD9+un9E/UD30gaekTSXven4/Uz82pb5mOIwlvTn17rp+ba7DxR1bm4o/MlMn0iZkymd6fKZPr9YkCOn1+cb+ATh//3S2gSp8ooOP+3C6g48M+BhzVP1ba+/qwz6fPsHqLjxl7s6fN84VPn/t8ojFbMWxbmz5vJuLjV1h3m4mYr7ebiZg/Mdya+f3h1nzqI7v90sGn/qT7D8anvq2bzUTn/bmdKfyRh1r+wEMtf+Shlj/xUHuun7vNRHzqIrvdTMTHb7E6zlDPX7r166VMSSN6vmXK6UsswzGxPND463Y8VE45K4XjUjnszUPlFLQYd/ZHPwV9XSztrIKFgYn/GMn3TeU0s1SLHeqnLTnOJMghwnnBmlr7b1SkxmuU5A6p36rE92XSX96WvEcpV36polHN/MfnR79VieOiedail/dIpb28LfFky5YHoP5WJbbFKn1gjyx1jP1SxeQKlfbyObL4npett0/sUe4e/p1KKxg4KPq6Spzp3CDx+h61tDT8L1V6jNXg3k7H5dxF1tJw37wmw7dFKvnUSTY+LcDdNdXj197qs0rF80Kt8qKKRo+35YEA3zROR1eumFtNrmNKNfrM0W31E0f3qHL76J5U7h7d4wCUC/tziR7usO0T329ze//7bT52lN1+DznNT3i78+Oscvttpn+gRaF/pEXh5pacOgvO5+f2e9Wpm+z+e9Wp4+L2kbX3j8lJ4xdnRz/xbnZ8ahd8ki7y8rM/93j2l3zlf1WRUzdZj9kpSv62t5evGp/o3JXrE527cr3fuSvXJzp35fpE5+55W+7WspRPDKWR8v5QmqPG7To878/dOjxe+4VaGo1sh4v/JJI6HXoay/9N5NxRhklpc/180zhetTHK9dEsYC+rVAwJ5ddVSlJpL6tIGp5aPrEt9vrRNfQK5S96X9+Wfjy6pxaoCJbe9EWNhu/0rvxw/E2EPtG/K/R+/66cOsruRzb1DzxMSn2/f/eocT8mj0fl7kgaqfUjR4U/cFTeH0lzPse3b8v0ifEEcvqK7P5t+dTUf/vI9k9cb7X95bfllE15EvFvd9RT35LF53GWptOoX2cYk2NP2b0PX88bgo6L/AHLf7AhJ434Cqal765+p9HRNHOlj/T+A5HTWtZXXLCP57PTk/7pQ7L7tw253r9tnD4ku3/bOH5IdjtSjttyO1JOMwXej5RTT9ndSDkuXHQ7Uo7786FIiSvuHCknERLGV5RpSoBvInqcUKXGlmieD7J9UzkuBxpz9Vj+nPxbMp2WIasV491rehj9Oj+snJbt+uOL7FpfFCmC5ZbzfO+/E4khmJXKaUtOg78UHap63J1jDz4+oezcXhOh68JHX3TaktOqUBEGmlqvv18lx+3AcLhLD+fGyl+7HQUd5qXxiwe1aPmASFytb4jkOw8drpHTd1YFn++Xmjq6fyeCyWUL00dE5FURwswvzC+LYA5i6R/YnddF0mxmrb0vkhcX+J1Inokm3XS+iTR5u4bP26GYKelUOad+sLtZckx5weQZp0xr/QMpf+yquZvy/f10PW/HzZQ/fSr2ie24m/I/iJQPiNxM+ds9paeUP3/fdTPljyJ3U/6+iLwqcjPlfxC5l/K3d+d1kZspf1fkmPJHkZspr9f76Xrejnsp7yPj/sqUt/g6mXIj0LftOPZX3Sy+s8jN4vuFiLwqcq/4fhK5VXz3d+d1kXvFd1vkVHxnkbvFR9e7F/0P23Gz+IjeL77T2zgZpllrh9N7+irs7tu4krz/nHYUufucpvR2tv6wHfee05T6X7sdN5/TfhIpHxC595x2Frn5nKaVP3CrOIrcvVXcF5FXRW7eKn4QuXeruL07r4vcvFXcFTneKo4id28V/Pa71g/bcfNWwfJ+lvD7b+PKH2hzPYrcTnl+P135A22uKuWv3Y67Kc8faHP9QeRmyvMH2lxVPtDmeha5m/LygTbXH0Ruprx8oM31/u68LnIz5eUDba5nkbspr++nq3ygzVXV/tqUv/s2rv0DxXcUuVt890XkVZGbxfeDyL3iu707r4vcLL67IsfiO4rcLb7Th1U3L/rzdtwsvvZ2q8B56IJizSq7no9/0OPnXXeHLujpg6q7Qxe08ftDF/TUoXV36MJZ5ObQhR9E7g1d0NY+0FjyiU4t/USnlr7fqaWf6NTS9zu19BOdWvqJTi39RKeWfqJTSz/RqaWf6NTST3Rq6Sc6tfQTnVr6iU4t/USnln6iU0s/0all73dq6Sc6tez9Tq0fUv5eY4kdOwlupvxR5G7KW3k7XX/Yjnspb0X+2u24mfI/iZQPiNxL+bPIzZS34zSFN1P+LHIz5X8hIq+K3Ev5n0Rupfz93Xld5F7K3xY5pfxZ5G7Kv9+t9cN23Ez5Wv7alL/ZWGLn77ZuFt9R5G7x3ReRV0VuFt8PIveK7/buvC5ys/juihyL7yhyt/j47SEDP2zHzeI7Lkl/s/jk/aELPmvnu2/j9olOLftEp5a936lln+jUsvc7tewTnVr2iU4t+0Snln2iU8s+0alln+jUsk90atknOrXsE51a9olOLftEp5Z9olPLPtGpZe93atknOrXs/U6tH1L+5tu4fqDN9ShyO+Xf/0zrh+24mfJW/9rtuJvy+oE21x9Ebqa8fqDN1ewDba5nkbspbx9oc/1B5GbK2wfaXO/vzusiN1PePtDmeha5m/Lvf6b1w3bcTPnW/9qUv/s23j/wIcFZ5G7x3ReRV0VuFl//wIcE93fndZGbxXdX5Fh8/QMfErTr7SEDP2zHveJr1/sfEhyHLhih+Owwv9pRpGHGxZZmtPilyIVV2+XVLekaIxcuej7h4g8TSMZauSRpvd1fTiCpmIwsN1H8UgWTuYx9e67SThP61ZhwZKyEHSLyVeJwwT5OcUyiVylNk1O/qZyuWCr70AoxdufrkiE/iMSmSE27813kNNlV1F9Ps2b/6ojUGPXTqh6PiH7iiOgnjkh784gcV4BoEstMNUkzPn5bu6EdP9Nq8Y4jrfPhuJ5UrMeMgo8sv15W4QaV8qLKI9lCpeShXb9UiRmMWvljlYJvKsd5g5pguuw/FhD6qnK84OqFq5Ze1OgUF+314hWn8ezY/mgh+H7FHR5iWWKBW5aW1xawX6iIShShdnlR5XFqa5zlP1ZL+J0K0prq69sSs5U+rqnroHL8EOb2FVfl/SvurHHnijutk9NjyQbNyyR8XSennabxU91lrHk1skt+ocG+qPC8YjUF/neV4/pdJea4Lo/mpFBR/ipSTv058ZZRa4rIryshtVP/1piBI97fpP8xv+63jTk9/xXC+mppebVKX8/QeWbCFkNxKa8S8juVGmtvP16irpPKcVUyTfPrPt+je1etXWnS4W9X7XH1LW6xGLlUPlwrh0CphmVc06Wvv9oQwWHVtGL2tw05dXSNr/+goum56+t6fmcZa/H09uDn6/n9sEsmmFUwLWr+fZcOl5vFYnyWbmFWfyHRolO1pTXNvkucGnN6zNddr3TL+JYGclzdM15KH4+9/ZAFcvrAAOuciHCaB7Ndv9qWm7PvNz0+R96ck7Od5iW8OSdnO01LeHtOznaaf+D2nJznbbk7J2c7dXjdnpOznaYzuTkn51Hj9pyc5/25OyfnuZbL9XMtn67YCx+SFH6+zGiz40jYFt1E+fXp62PK3e1IM8N/347jUgSETsDHcSzPI/YsU2NdzgenK/a7zGkEjMWEwzXPWvwtI8+TvbV4wX1wO6Xkcc0ujf6zR5+eHZ5Sjn0Jt5+Yzj1od5+Yzkfm/rNkK594ljx+1nX7yNxVqXlVwN+p3D6+x+Ny84n0x1qKl+4Ht8OD3Kkf7O4T5Q+b0lHWubvl+6YcBxoYSqmbHR4GT0tu3V4j+qetaVid4Mof4H3fmtOCWRJP/SV3jEu//fZBV/RSUEmNgtdD4v96/Oc//OM//9t/+du//uM//Ps//+u//M/xl3SNa3UMy6ISREE1iAeNWcxJgtTpcWckC2pOjz2hvqugXkEliILcY9zrq3uMXoUqQe4x7kvVPcYjb21B7jEuWr6C3GOcdqYg9xhv4Dw8ePT0sATpLNIHWVBzenhw3yRX0PDg8QQiFFSdHnsu7jGeiEWC3GO0M4gFucc4ktI3qXuMI6klyD3GBa81iIMkSIMsqAX1TXYFlaDwsPCw8LDwsPCw8LDwsPBo4dHCo4VHC48WHi08Wng09+iPY9BaUN/Ur6ASREE1iIMkSIPCo4dHD49yXcACJGAFMlCACjRgA8KtwK3ArcCtwK0MNxmdp6UIUIHDTcb1+nhxAPZAL34ZLRbFq38hObaBFchAdxudu8UjYKEB3W284RZPgYkeAwvdbVRN8SCQsWhn8SRYyEB3G70dxcNAqv+Zu7GLNeB0e6RA8UCQ8aZRPBEWErACGShABRqwAXugwE3gJnATuAncBG4CN4GbwE3gpnBTuCncFG4KN4Wbwk3hpnBTuBncDG4GN4Obwc3gZnAzuBncDG4Nbg1ubbqNE9sq0N3EUYAKNGAD9kCPkIUFSMAKhFuHW4dbh1uHWw83ui5gARKwAhkoQAUasAHhVuBW4FbgVuBW4FbgVuBW4FbgVuBGcCO4EdwIbgQ3ghvBjeBGcCO4VbhVuFW4VbhVuFW4VbhVuFW4Vbgx3BhuDDeGG8ON4cZwY7gx3BhuAjeBm8BN4CZwE7gJ3ARuAjeBm8JN4aZwU7gp3BRuCjeFm8JN4WZwM7gZ3AxuBjeDm8HN4GZwM7g1uDW4Nbg1uCFLCFlCyBJClhCyhJAlhCwhZAkhSwhZQsgSQpYQsoSQJYQsIWRJRZZUZElFllRkSUWWVGRJRZZUZElFllRkSUWWVGRJRZZUZElFllRkSUWWVGRJRZZUZElFllRkSUWWVGRJRZZUZElFllRkSUWWVGRJRZZUZElFllRkSUWWVGRJRZZUZElFllRkSUWWVGRJRZZUZElFllRkSUWWVGRJRZZUZElFllRkSUWWVGRJRZZUZElFllRkSUWWVGRJRZZUZElFllRkSUWWVGRJRZZUZElFllRkSUWWVGRJRZZUZElFllRkSUWWVGRJRZZUZElFllRkSV1ZMl5UZ5YoD2SgABXobqNpss4smehu2sZ7rbvZNbAACehuRgMZ6G6jQbTOLJloQHcbjZR1ZslAnlkymr14ZslEArrbGFnDM0smupu/X88sGa0bPLNkoruNlxWeWeI4s2Q0A/HMkokEdLcxqoJnlkwcbjoGLrJnyUIDDjf1l3fPkomeJT4+kD1LFg43/7CRPUsWMtDdxgsIe5YsdLfRVsmeJTr649mzZKJnyUJ3q976QEB3Gx2i7FmyUIDuNoZWsGfJQncbXeDsWTLRs2Shu43RXOxZstDdRn8oe5boaGJgz5KF7jb6utizZKG7jUYc9iyZ6Fmy0N1GBbBnyUJ3Gy057FmyUIDuNi5w9ixZ6G7jqmbPkomeJTqGIbNnyUICuttoPWXPkoXu5hetZ8lCAzagu3mbkWfJQnfzq9qzRP1S9ixZyEB386vas2Shu/ml7FmysAd6lqhf1a0Ah5v5pexZspCBw81m65QCzXFsjmeJjaGY7Fky0bPEu//Ys2Shu43XdfYsWchAd/Ni8CxZ6G5+KXuWLOwbxbPExju6eJYsdDdvCPMsWehu7E1rAlSgu403QPEsWehu46oWzxLzJjTPkoUEdLdxVYtnyUJ3G5eyeJYsNKC7jataPEsmepbYuJTFs2QhAd1tXNXiWbLQ3cZVLZ4lZt5waEB3G99qi2fJRM8SGwEtniULCehuoxjEs2Shu42AFs+ShQZ0t3GBi2fJRM8SG1e1eJYsHG7tKgMrkIHiOE6WZ8lCc/S20OY4jo5nSRvdeuJZsrA4ji0TAlYgA6fb2E1RoAGjKVI8S9po0RLPkoUFSMAKjAZJ8SxpoxjEs2ShARuwB9p0GwfVCpCAFchAASrQgA3YAxvcGtwa3BrcGtwa3BrcGtwa3BrcOtw63DrcOtw63DrcOtw63DxLfEyMeJY4qmfJwgJEc7hnSRvtiOpZstDdxg1bPUsWok38QqP4Nd28vf0CFiABp5sNZKAAFWjABuyBNN3GNlABErACGSjAaaEDG7AH1guIHarYoVqB6E+o6FDwAGkj19UDZGED9kAPkDb6/tUDZCEBK5CBvkPjJqEzQCZOt3HeZoBM7IEzQCZOt7GbM0AmViADp9s4ATNAJhqwAXvgDJCJ00IGViADBaixkYodmqnhOz9TYzyq6UwN7wKaqTFuVDpTY6K7jdFrOlNjoruNe5bO1FDv/nE3czF3a449cKbGRHcbIw51psZEd2veg+Ruo/NMZ2pMdDdfiv3/+Yd/++d/+K9/+6f/+ehQHH2O/+tf/nH3Lz7+89//3/+x/5//+m///Le//fN//y//49/+9R//6b/9r3/7p9EX6d2Q1/qf/zw+Zvj79kif/+vRdPr47z7WX+6Pf3z8d/X//7Hbj1+q4/8ff/C42MrfP/5Hxz+Mv3j0+P5/fZlBEsUgCEMvxKJS0O/9L/ZfmGJ33XQRJpKigxMJ4zM18BxaVzxOVXhzclhW2BUuiM7iBd2tBM9oGKonL97WcJy9gmadON/OKVNBTxA/Dp9ehJlvBo3O2J1m8B5ivH6Ika2REUaOo9Etl8LzaOR28cqxXtlhvgX9XmjZ7YL2gdA+89SH+hZlXJ3YN3/aieOyyIp/Fk8D5T8=",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "get_note_internal",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "call_private_function_internal",
        "load",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert",
        "directive_to_radix",
        "directive_integer_quotient"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "refund_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3564161243949231814": {
            "error_kind": "string",
            "string": "Function refund_public can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "9323748002447105156": {
            "error_kind": "string",
            "string": "NotPassedTimelock"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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AC0IAQInAhoEDAAIARoBJwMCBAEAIgICGi0KGhstDgQbACIbAhstDggbACIbAhstDh4bACIbAhstDgkbACIbAhstDhQbACIbAhstDhUbACIbAhstDhYbACIbAhstDhgbACIbAhstDhkbACIbAhstDgsbACIbAhstDgobHAoXBAAcCg8IABwKEAkAHAoRCgAcChILABwKEw8AHAoNEAAcCgwNAC0IAQwnAhEEDAAIAREBJwMMBAEAIgwCES0KERItDgUSACISAhItDgQSACISAhItDg4SACISAhItDggSACISAhItDgkSACISAhItDgoSACISAhItDgsSACISAhItDg8SACISAhItDhASACISAhItDg0SACISAhItDgMSLgiARQAqIwAAC7QNIgAqgEwAAyQCAAMAAA7qIwAAC8ktCwcDLQsDBAAiBAIELQ4EAy0IAQQnAgUEBAAIAQUBJwMEBAEAIgQCBS0KBQcuDIBGAAcAIgcCBy4MgEYABwAiBwIHLgyARgAHKwIABQAAAAAAAAAAFwAAAAAAAAAALQgBBycCCAQFAAgBCAEnAwcEAQAiBwIILQoICS4MgEYACQAiCQIJLgyARgAJACIJAgkuDIBGAAkAIgkCCS0OBQktCAEFAAABAgEtDgQFLQgBBAAAAQIBLQ4HBC0IAQcAAAECAS4MgEUABy0IAQgAAAECAS4MgEQACC0LAwkAIgkCCS0OCQMuCIBFAAIjAAAMuA0iAAKATQAJJAIACQAADqAjAAAMzScCCgQLLQgACy0KBQwtCgQNLQoHDi0KCA8ACAAKACUAABcZLQIAAC0KDAktCAEEJwIFBBkACAEFAScDBAQBACIEAgUnAgcEGAAqBwUHLQoFCAwqCAcKFgoKCiQCAAoAAA0/LgyARgAIACIIAggjAAANHi0IAQUAAAECAS0OBAUuCIBFAAIjAAANVw0iAAKATQAEJAIABAAADlMjAAANbC0LBQMnAgQEGC4CAAOAAygAgAQEABklAAAXjS4IgAUABwAqBwQILQ4JCC0OBwUuCIBFAAIjAAANpQwqAgQDJAIAAwAADiQjAAANtykCAAIALRfGuCcCBAQCJwIGBAMAKgQGBS0IAQMACAEFAScDAwQBACIDAgUtDgQFACIFAgUtDgQFJwIFBAMAKgMFBC0KBAUtDgIFACIFAgUtDgEFACIDAgQt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",
      "debug_symbols": "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",
      "brillig_names": [
        "refund_public"
      ]
    },
    {
      "name": "sync_private_state",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "sync_private_state"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "HTLC_Private"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Train"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "contracts_private",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "contracts_public",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::add_lock_private_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::add_lock_private_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::add_lock_public_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::add_lock_public_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 90
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::commit_private_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::commit_private_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 90
                    }
                  },
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::commit_public_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::commit_public_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Train::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "key",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::get_htlc_public_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "hashlock_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "hashlock_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_hash_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_hash_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "claimed",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::HTLC_Public"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::get_htlc_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::is_contract_initialized_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::is_contract_initialized_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_hash",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 90
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::lock_private_solver_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::lock_private_solver_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "ownership_hash",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 90
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::lock_public_solver_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::lock_public_solver_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "ownership_key",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::redeem_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::redeem_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "ownership_key",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::redeem_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::redeem_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::refund_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::refund_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::refund_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::refund_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Train::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::sync_private_state_abi"
        }
      ]
    }
  },
  "file_map": {
    "101": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        authwits::AUTHWIT_TYPES,\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_private_state = generate_sync_private_state();\n    let process_message = generate_process_message();\n    generate_authwit_exports();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_authwit_exports() {\n    let authwits = AUTHWIT_TYPES.values();\n    authwits.for_each(|(s): TypeDefinition| { s.add_attribute(\"abi(authwits)\"); });\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // TODO(#15012): Here we use PRIVATE_LOG_CIPHERTEXT_LEN for message ciphertext length. Fix message vs log naming.\n    quote {\n        #[$utility]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::do_process_message(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n"
    },
    "102": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::{compute_fn_selector, size_in_fields};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "105": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_array, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_public, is_fn_view,\n    size_in_fields,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else if is_fn_public(f) {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    } else {\n        if is_void {\n            create_utility_void_stub(f)\n        } else {\n            create_utility_stub(f)\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n    let params_num_fields =\n        fn_parameters.fold(0, |acc, (_, typ)| acc + crate::macros::utils::size_in_fields(typ));\n\n    let serialized_args_index_name = quote { serialized_args_index };\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args = [0;2];\n    // let mut serialized_args_index = 0;\n    // let target_address_serialized = aztec::protocol_types::traits::Serialize::serialize(target_address)\n    // for i in 0..target_address_serialized.len() {\n    //    serialized_args[serialized_args_index] = target_address_serialized[i];\n    //    serialized_args_index += 1;\n    // }\n    // serialized_args[serialized_args_index] = fee_juice_limit_per_tx as Field\n    // serialized_args_index += 1;\n    // ```\n    let serialized_args_array_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_NAME = [0; $params_num_fields];\n            let mut $serialized_args_index_name: u32 = 0;\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append =\n                add_to_field_array(SERIALIZED_ARGS_NAME, serialized_args_index_name, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_array_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    // This is here because utility function call interfaces can only be used within TXe tests.\n    let modified_fn_name = f\"_experimental_{fn_name}\".quoted_contents();\n\n    quote {\n        pub fn $modified_fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    // This is here because utility function call interfaces can only be used within TXe tests.\n    let modified_fn_name = f\"_experimental_{fn_name}\".quoted_contents();\n\n    quote {\n        pub fn $modified_fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n"
    },
    "106": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "109": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n\n    fn_abi\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "111": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ, _) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "112": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ, _) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "114": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{private_notes::MAX_NOTE_PACKED_LEN, process_message::do_process_message},\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        do_process_message(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "115": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "116": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "117": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    prelude::AztecAddress,\n    utils::array,\n};\nuse protocol_types::{\n    constants::GENERATOR_INDEX__EVENT_COMMITMENT, hash::poseidon2_hash_with_separator_bounded_vec,\n    traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private_log` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "118": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "119": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::decode_message,\n    encryption::{aes128::AES128, log_encryption::LogEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    constants::PRIVATE_LOG_CIPHERTEXT_LEN,\n    debug_log::{debug_log, debug_log_format},\n};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn do_process_message<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    let message = AES128::decrypt_log(message_ciphertext, message_context.recipient);\n\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\npub global MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "121": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{\n        GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2,\n        PRIVATE_LOG_CIPHERTEXT_LEN,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "128": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/logs/note.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    messages::{\n        encoding::encode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        logs::utils::prefix_with_tag,\n        msg_type::{PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID},\n        offchain_messages::emit_offchain_message,\n    },\n    note::{note_emission::NoteEmission, note_interface::NoteType},\n    utils::{array::subarray::subarray, remove_constraints::remove_constraints},\n};\nuse protocol_types::{\n    abis::note_hash::NoteHash,\n    address::AztecAddress,\n    constants::{PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_SIZE_IN_FIELDS},\n    traits::Packable,\n};\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists(context: PrivateContext, note_hash_counter: u32) {\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\npub fn compute_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PRIVATE_NOTE_MSG_TYPE_ID,\n    )\n}\n\npub fn compute_partial_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID,\n    )\n}\n\nfn compute_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    msg_type: u64,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let packed_note = note.pack();\n\n    // A note message's content is the storage slot followed by the packed note representation\n    let mut msg_content: [Field; N + 1] = std::mem::zeroed();\n    msg_content[0] = storage_slot;\n    for i in 0..packed_note.len() {\n        msg_content[1 + i] = packed_note[i];\n    }\n\n    // Notes use the note type id for metadata\n    let plaintext = encode_message(msg_type, Note::get_id() as u64, msg_content);\n\n    let ciphertext = AES128::encrypt_log(plaintext, recipient);\n\n    let log = prefix_with_tag(ciphertext, sender, recipient);\n\n    log\n}\n\n/// Sends an encrypted message to `recipient` with the content of the note, which they will discover when processing\n/// private logs.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n        assert_note_exists(*context, note_hash_counter);\n\n        let encrypted_log = compute_note_log(note, storage_slot, recipient, sender);\n        // Regardless of the original note size `N, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_raw_note_log(encrypted_log, length, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note`, except encryption is unconstrained. This means that the sender is free to make\n/// the log contents be whatever they wish, potentially resulting in scenarios in which the recipient is unable to\n/// decrypt and process the payload, **leading to the note being lost**.\n///\n/// Only use this function in scenarios where the recipient not receiving the note is an acceptable outcome.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log = unsafe {\n            remove_constraints(|| compute_note_log(note, storage_slot, recipient, sender))\n        };\n        // Regardless of the original note size `N`, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_raw_note_log(encrypted_log, length, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note_unconstrained`, except the note is emitted as an offchain message instead of a\n/// private log.\n///\n/// Like `encode_and_encrypt_note_unconstrained`, this function uses unconstrained encryption. The sender can set any\n/// message contents, potentially preventing recipient decryption and resulting in note loss. Since offchain messages\n/// inherently lack delivery guarantees, constrained encryption provides no benefit and is not offered.\n///\n/// While delivery is not guaranteed, message integrity is still protected via cryptographic commitments in the note\n/// hash tree. For guaranteed delivery, use `encode_and_encrypt_note` with private logs instead. See\n/// `messages::offchain_message::emit_offchain_message` for more details on delivery guarantees.\npub fn encode_and_encrypt_note_and_emit_as_offchain_message<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log = unsafe {\n            remove_constraints(|| compute_note_log(note, storage_slot, recipient, sender))\n        };\n\n        // Remove the tag from the log\n        // TODO: This is a tech debt. We should refactor this file such that the log is by default computed without\n        // the tag.\n        let message_ciphertext: [_; PRIVATE_LOG_CIPHERTEXT_LEN] = subarray(encrypted_log, 1);\n\n        emit_offchain_message(message_ciphertext, recipient);\n    }\n}\n"
    },
    "129": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/logs/utils.nr",
      "source": "use crate::{\n    oracle::notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n    prelude::AztecAddress,\n};\n\npub(crate) fn prefix_with_tag<let L: u32>(\n    log_without_tag: [Field; L],\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> [Field; L + 1] {\n    // Safety: we assume that the sender wants for the recipient to find the tagged note, and therefore that they will\n    // cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the\n    // note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut log_with_tag = [0; L + 1];\n\n    log_with_tag[0] = tag;\n    for i in 0..log_without_tag.len() {\n        log_with_tag[i + 1] = log_without_tag[i];\n    }\n\n    log_with_tag\n}\n\nmod test {\n    use super::prefix_with_tag;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn prefixing_with_tag() {\n        let sender = AztecAddress::from_field(1);\n        let recipient = AztecAddress::from_field(2);\n\n        let app_tagging_secret = 42;\n        let index = 5;\n\n        // I am using the deserialize trait instead of directly instantiating the IndexedTaggingSecret struct because\n        // direct instantiation functionality is not exposed.\n        let indexed_tagging_secret = IndexedTaggingSecret::deserialize([app_tagging_secret, index]);\n\n        // Mock the tagging oracles\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(indexed_tagging_secret);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let log_without_tag = [1, 2, 3];\n        let log_with_tag = prefix_with_tag(log_without_tag, sender, recipient);\n\n        let expected_result = [indexed_tagging_secret.compute_tag(recipient), 1, 2, 3];\n\n        // Check tag was prefixed correctly\n        assert_eq(log_with_tag, expected_result, \"Tag was not prefixed correctly\");\n    }\n}\n"
    },
    "137": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "142": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "144": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n    pub storage_slot: Field,\n    pub note_hash_counter: u32, // a note_hash_counter of 0 means settled\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note, storage_slot: Field, note_hash_counter: u32) -> Self {\n        Self { note, storage_slot, note_hash_counter }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "147": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{\n        note_getter_options::{\n            NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder,\n        },\n        note_interface::{NoteHash, NoteType},\n        note_viewer_options::NoteViewerOptions,\n        retrieved_note::RetrievedNote,\n        utils::compute_note_hash_for_read_request,\n    },\n    oracle,\n    utils::{array, comparison::compare},\n};\n\nuse protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, traits::{Packable, ToField}};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. note nonce, note hash,\n/// etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "150": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n"
    },
    "152": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/note/retrieved_note.nr",
      "source": "use crate::{note::note_metadata::NoteMetadata, utils::array::subarray::subarray};\nuse protocol_types::{\n    address::AztecAddress,\n    traits::{FromField, Packable, Serialize, ToField},\n    utils::arrays::array_concat,\n};\n\n// Number of fields a RetrievedNote adds to the packed or serialized representation of a note\n// +1 for the contract address\n// +2 for the note metadata\npub global RETRIEVED_NOTE_OVERHEAD: u32 = 1 + 2;\n\n/// A container of a note and the metadata required to prove its existence, regardless of whether the note is\n/// pending (created in the current transaction) or settled (created in a previous transaction).\n#[derive(Eq)]\npub struct RetrievedNote<NOTE> {\n    pub note: NOTE,\n    pub contract_address: AztecAddress,\n    pub metadata: NoteMetadata,\n}\n\nimpl<NOTE, let N: u32> Serialize<N + RETRIEVED_NOTE_OVERHEAD> for RetrievedNote<NOTE>\nwhere\n    NOTE: Serialize<N>,\n{\n    fn serialize(self) -> [Field; N + RETRIEVED_NOTE_OVERHEAD] {\n        array_concat(\n            array_concat(self.note.serialize(), [self.contract_address.to_field()]),\n            self.metadata.serialize(),\n        )\n    }\n}\n\n// This function is not part of the Packable trait implementation because in the case of the retrieved note, the pack\n// functionality resides in TS (oracle.ts and txe_service.ts).\npub fn unpack_retrieved_note<NOTE, let N: u32>(\n    packed_retrieved_note: [Field; N + RETRIEVED_NOTE_OVERHEAD],\n) -> RetrievedNote<NOTE>\nwhere\n    NOTE: Packable<N>,\n{\n    let contract_address = AztecAddress::from_field(packed_retrieved_note[0]);\n    let note_nonce = packed_retrieved_note[1];\n    let nonzero_note_hash_counter = (packed_retrieved_note[2] as u1) != 0;\n\n    let packed_note = subarray(packed_retrieved_note, RETRIEVED_NOTE_OVERHEAD);\n    let note = NOTE::unpack(packed_note);\n\n    RetrievedNote {\n        note,\n        contract_address,\n        metadata: NoteMetadata::from_raw_data(nonzero_note_hash_counter, note_nonce),\n    }\n}\n"
    },
    "153": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "157": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "158": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "159": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "160": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getTimestamp)]\nunconstrained fn get_timestamp_oracle() -> u64 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_timestamp() -> u64 {\n    get_timestamp_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "161": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "162": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "166": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "167": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "168": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "170": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(fetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(validateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(bulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "172": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{\n    note_interface::NoteType,\n    retrieved_note::{RETRIEVED_NOTE_OVERHEAD, RetrievedNote, unpack_retrieved_note},\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress, indexed_tagging_secret::IndexedTaggingSecret, traits::Packable,\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> {}\n\npub unconstrained fn get_notes<Note, let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<NOTE_PCKD_LEN>,\n{\n    // N + 3 because of the contract address, note nonce, and note_hash_counter that are stored out of the packed note.\n    let packed_retrieved_notes: BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> = get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        MAX_NOTES,\n        NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD,\n    );\n\n    let mut notes = BoundedVec::<_, MAX_NOTES>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = unpack_retrieved_note(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MAX_NOTES];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "174": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "175": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "177": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: u32,\n    length: u32,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number, N)\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "179": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\n// Map reserves a single storage slot regardless of what it stores because nothing is stored at said slot: it is only\n// used to derive the storage slots of nested state variables, which is expected to never result in collisions or slots\n// being close to one another due to these being hashes. This mirrors the strategy adopted by Solidity mappings.\nimpl<K, T, Context> Storage<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "181": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr",
      "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\nuse crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    lifecycle::create_note,\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_notes},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\n// Private storage slots are not really 'slots' but rather a value in the note hash preimage, so there is no notion of a\n// value spilling over multiple slots. For this reason PrivateImmutable (and all other private state variables) needs\n// just one slot to be reserved, regardless of what it stores.\nimpl<T, Context> Storage<1> for PrivateImmutable<T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor.\n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: NoteType + NoteHash + Packable<N>,\n    {\n        // We emit an initialization nullifier to indicate that the struct is initialized. This also prevents\n        // the value from being initialized again as a nullifier can be included only once.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> Note\n    where\n        Note: NoteType + NoteHash + Packable<N>,\n    {\n        let storage_slot = self.storage_slot;\n        let retrieved_note = get_note(self.context, storage_slot).0;\n\n        // Because the notes obtained from PrivateImmutable are not meant to be nullified and get_note(...) function\n        // has already constrained the note (by pushing a read request to the context), we can return just the note\n        // and skip the additional data in RetrievedNote.\n        retrieved_note.note\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:is_initialized\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note\n    where\n        Note: Packable<N>,\n    {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"
    },
    "190": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable.nr",
      "source": "use dep::protocol_types::{\n    shared_mutable::{\n        ScheduledDelayChange,\n        ScheduledValueChange,\n        shared_mutable_values::{unpack_delay_change, unpack_value_change},\n        SharedMutableValues,\n    },\n    traits::Packable,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\n\nmod test;\n\npub struct SharedMutable<T, let INITIAL_DELAY: u64, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Packable and Eq traits, and allocate `M` storage\n// slots to this state variable.\nimpl<T, let INITIAL_DELAY: u64, Context, let M: u32> Storage<M> for SharedMutable<T, INITIAL_DELAY, Context>\nwhere\n    WithHash<SharedMutableValues<T, INITIAL_DELAY>, _>: Packable<M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in seconds. Reads in private are only valid as long as they are included in a block with a timestamp not\n// too far into the future, so that they can guarantee the value will not have possibly changed by then (because of the\n// delay). The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let INITIAL_DELAY: u64, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u64> SharedMutable<T, INITIAL_DELAY, &mut PublicContext>\nwhere\n    T: Eq,\n{\n\n    pub fn schedule_value_change<let N: u32>(self, new_value: T)\n    where\n        T: Packable<N>,\n    {\n        let _value_change = self.schedule_and_return_value_change(new_value);\n    }\n\n    pub fn schedule_and_return_value_change<let N: u32>(\n        self,\n        new_value: T,\n    ) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let current_timestamp = self.context.timestamp();\n        let current_delay = delay_change.get_current(current_timestamp);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let timestamp_of_change = current_timestamp + current_delay;\n        value_change.schedule_change(\n            new_value,\n            current_timestamp,\n            current_delay,\n            timestamp_of_change,\n        );\n\n        self.write(value_change, delay_change);\n\n        value_change\n    }\n\n    pub fn schedule_delay_change<let N: u32>(self, new_delay: u64)\n    where\n        T: Packable<N>,\n    {\n        let mut delay_change = self.read_delay_change();\n\n        let current_timestamp = self.context.timestamp();\n\n        delay_change.schedule_change(new_delay, current_timestamp);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let current_timestamp = self.context.timestamp();\n        let value_change = self.read_value_change();\n\n        value_change.get_current_at(current_timestamp)\n    }\n\n    pub fn get_current_delay<let N: u32>(self) -> u64\n    where\n        T: Packable<N>,\n    {\n        let current_timestamp = self.context.timestamp();\n        self.read_delay_change().get_current(current_timestamp)\n    }\n\n    pub fn get_scheduled_value<let N: u32>(self) -> (T, u64)\n    where\n        T: Packable<N>,\n    {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay<let N: u32>(self) -> (u64, u64)\n    where\n        T: Packable<N>,\n    {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change<let N: u32>(self) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        // We don't read ScheduledValueChange directly by having it implement Packable because ScheduledValueChange\n        // and ScheduledDelayChange are packed together (sdc and svc.timestamp_of_change are stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_value_change::<T, N>(packed)\n    }\n\n    fn read_delay_change<let N: u32>(self) -> ScheduledDelayChange<INITIAL_DELAY>\n    where\n        T: Packable<N>,\n    {\n        // Since all ScheduledDelayChange member are packed into a single field, we can read a single storage slot\n        // here and skip the ones that correspond to ScheduledValueChange members. We are abusing the fact that\n        // the field containing the ScheduledDelayChange data is the first one in the storage layout - otherwise we'd\n        // need to offset the storage slot to get the position where it'd land.\n        // We don't read ScheduledDelayChange directly by having it implement Packable because ScheduledValueChange\n        // and ScheduledDelayChange are packed together (sdc and svc.timestamp_of_change are stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_delay_change::<INITIAL_DELAY>(packed)\n    }\n\n    fn write<let N: u32>(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>,\n    )\n    where\n        T: Packable<N>,\n    {\n        // Whenever we write to public storage, we write both the value change and delay change to storage at once.\n        // We do so by wrapping them in a single struct (`SharedMutableValues`). Then we wrap the resulting struct in\n        // `WithHash`.\n        // Wrapping in `WithHash` makes for more costly writes but it also makes private proofs much simpler because\n        // they only need to produce a historical proof for the hash, which results in a single inclusion proof (as\n        // opposed to 4 in the best case scenario in which T is a single field). Private shared mutable reads are\n        // assumed to be much more frequent than public writes, so this tradeoff makes sense.\n        let values = WithHash::new(SharedMutableValues::new(value_change, delay_change));\n\n        self.context.storage_write(self.storage_slot, values);\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u64> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext>\nwhere\n    T: Eq,\n{\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction timestamp as this proof\n        // will only be valid for the time we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n        let (value_change, delay_change, historical_timestamp) =\n            self.historical_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the historical timestamp (timestamp of\n        // the historical block against which we are executing the private part of the tx) as this one also takes into\n        // consideration any scheduled delay changes.\n        // For example, consider a scenario in which at timestamp `x` the current delay was 86400 seconds (1 day). We\n        // may naively think that the earliest we could change the value would be at timestamp `x + 86400` by scheduling\n        // immediately after the historical timestamp, i.e. at timestamp `x + 1`. But if there was a delay change scheduled\n        // for timestamp `y` to reduce the delay to 43200 seconds (12 hours), then if a value change was scheduled at\n        // timestamp `y` it would go into effect at timestamp `y + 43200`, which is earlier than what we'd expect if we\n        // only considered the current delay.\n        let effective_minimum_delay =\n            delay_change.get_effective_minimum_delay_at(historical_timestamp);\n        let timestamp_horizon =\n            value_change.get_timestamp_horizon(historical_timestamp, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any timestamp after the timestamp horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_include_by_timestamp(timestamp_horizon);\n\n        value_change.get_current_at(historical_timestamp)\n    }\n\n    fn historical_read_from_public_storage<let N: u32>(\n        self,\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u64)\n    where\n        T: Packable<N>,\n    {\n        let header = self.context.get_block_header();\n        let address = self.context.this_address();\n\n        let historical_timestamp = header.global_variables.timestamp;\n\n        let values: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::historical_public_storage_read(header, address, self.storage_slot);\n\n        (values.svc, values.sdc, historical_timestamp)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u64> SharedMutable<T, INITIAL_DELAY, UtilityContext>\nwhere\n    T: Eq,\n{\n    pub unconstrained fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let smv: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::utility_public_storage_read(self.context, self.storage_slot);\n\n        let current_timestamp = self.context.timestamp();\n        smv.svc.get_current_at(current_timestamp)\n    }\n}\n"
    },
    "202": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "205": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "206": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "208": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "209": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "211": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "213": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "214": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/random.nr",
      "source": "use crate::oracle::random::random;\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n"
    },
    "218": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "225": {
      "path": "/home/nerses/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "243": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "286": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "301": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "303": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "304": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{arrays::array_concat, field::{field_from_bytes, field_from_bytes_32_trunc}},\n};\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "305": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "314": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "318": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] != 0 };\n        consumed_counter = 1;\n    } else if typ.is_field() | typ.as_integer().is_some() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type, _) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type, _)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    let serialize_trait: TraitConstraint =\n        quote { Serialize<$serialized_len> }.as_trait_constraint();\n    quote {\n        impl $serialize_trait for $typ {\n            #[inline_always]\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "320": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "321": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "331": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] != 0,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] != 0,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] != 0,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] != 0,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "335": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_delay_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initially equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub struct ScheduledDelayChange<let INITIAL_DELAY: u64> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pub(crate) pre: Option<u64>,\n    pub(crate) post: Option<u64>,\n    // Timestamp at which `post` value is used instead of `pre`\n    pub(crate) timestamp_of_change: u64,\n}\n\nimpl<let INITIAL_DELAY: u64> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u64>, post: Option<u64>, timestamp_of_change: u64) -> Self {\n        Self { pre, post, timestamp_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current timestamp - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_timestamp: u64) -> u64 {\n        // The post value becomes the current one at the timestamp of change, so any transaction that is included at or after\n        // the timestamp of change will use the post value.\n        if current_timestamp < self.timestamp_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the timestamp at which it will become the current\n    /// delay. Note that this timestamp may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u64, u64) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.timestamp_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current timestamp. This function is only meaningful\n    /// when called in public with the current timestamp.\n    /// The timestamp at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u64, current_timestamp: u64) {\n        let current = self.get_current(current_timestamp);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let time_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior constraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value timestamp of change\n            //      timestamp             timestamp of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   time until change               new delay              |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.timestamp_of_change = current_timestamp + time_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical timestamp (timestamp of a historical block). It only returns a meaningful value when called in\n    /// private with historical timestamps. This function can be used alongside\n    /// `ScheduledValueChange.get_timestamp_horizon` to properly constrain the `include_by_timestamp` transaction\n    /// property when reading mutable shared state.\n    /// This value typically equals the current delay at the timestamp following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_timestamp: u64) -> u64 {\n        if self.timestamp_of_change <= historical_timestamp {\n            // If no delay changes were scheduled, then the delay value at the historical timestamp (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // timestamp of change the current delay will be the scheduled one, with an overall delay from the historical\n            // timestamp equal to the time until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //        timestamp                delay                  actual earliest value\n            //           v              timestamp of change           timestamp of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest timestamp in        |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |          time                  new delay                       |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest timestamp in\n            //                             which to scheduled value change\n            let time_until_change = self.timestamp_of_change - (historical_timestamp + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                time_until_change + self.post.unwrap_or(INITIAL_DELAY),\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u64> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.timestamp_of_change == other.timestamp_of_change)\n    }\n}\n\nimpl<let INITIAL_DELAY: u64> Empty for ScheduledDelayChange<INITIAL_DELAY> {\n    fn empty() -> Self {\n        Self { pre: Option::none(), post: Option::none(), timestamp_of_change: 0 }\n    }\n}\n"
    },
    "337": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_value_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some timestamp\n// called the `timestamp_of_change`. The value can only be made to change by scheduling a change event at some future\n// timestamp after some minimum delay measured in seconds has elapsed. This means that at any given timestamp we know\n// both the current value and the smallest timestamp at which the value might change - this is called the\n// 'timestamp horizon'.\npub struct ScheduledValueChange<T> {\n    pub(crate) pre: T,\n    pub(crate) post: T,\n    // Timestamp at which `post` value is used instead of `pre`\n    pub(crate) timestamp_of_change: u64,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, timestamp_of_change: u64) -> Self {\n        Self { pre, post, timestamp_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given timestamp. This function can be called both in public\n    /// (where `timestamp` is simply the current timestamp, i.e. the timestamp at which the current transaction will be\n    /// included) and in private (where `timestamp` is the historical timestamp that is used to construct the proof).\n    /// Reading in private is only safe if the transaction's `include_by_timestamp` property is set to a value lower or\n    /// equal to the timestamp horizon (see `get_timestamp_horizon()`).\n    pub fn get_current_at(self, timestamp: u64) -> T {\n        // The post value becomes the current one at the timestamp of change. This means different things in each realm:\n        // - in public, any transaction that is included at the timestamp of change will use the post value\n        // - in private, any transaction that includes the timestamp of change as part of the historical state will use\n        //   the post value (barring any follow-up changes)\n        if timestamp < self.timestamp_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the timestamp at which it will become the current\n    /// value. Note that this timestamp may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u64) {\n        (self.post, self.timestamp_of_change)\n    }\n\n    // Returns the previous value. This is the value that is current up until the timestamp of change. Note that this\n    // value might not be the current anymore since timestamp of change might have already passed.\n    pub fn get_previous(self) -> (T, u64) {\n        (self.pre, self.timestamp_of_change)\n    }\n\n    /// Returns the largest timestamp at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_timestamp`\n    /// (timestamp of a historical block at which we are constructing a proof), since due to its asynchronous nature\n    /// private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum time in seconds that needs to\n    /// elapse from the next block's timestamp until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical timestamp is only safe to use\n    /// if the transaction's `include_by_timestamp` property is set to a value lower or equal to the timestamp horizon\n    /// computed using the same historical timestamp.\n    pub fn get_timestamp_horizon(self, historical_timestamp: u64, minimum_delay: u64) -> u64 {\n        // The timestamp horizon is the very last timestamp in which the current value is known. Any timestamp past the\n        // horizon (i.e. with a timestamp larger than the timestamp horizon) may have a different current value.\n        // Reading the current value in private typically requires constraining the maximum valid timestamp to be equal\n        // to the timestamp horizon.\n        if historical_timestamp >= self.timestamp_of_change {\n            // Once the timestamp of change has passed (block with timestamp >= timestamp_of_change was mined),\n            // the current value (post) will not change unless a new value change is scheduled. This did not happen at\n            // the historical timestamp (or else it would not be greater or equal to the timestamp of change), and\n            // therefore could only happen after the historical timestamp. The earliest would be the immediate next\n            // timestamp, and so the smallest possible next timestamp of change equals `historical_timestamp + 1 +\n            // minimum_delay`. Our timestamp horizon is simply the previous timestamp to that one.\n            //\n            //   timestamp of    historical\n            //      change       timestamp          timestamp horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n            historical_timestamp + minimum_delay\n        } else {\n            // If the timestamp of change has not yet been reached however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the timestamp horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the timestamp of change is in the past: the time horizon is\n            //      the timestamp prior to the earliest one in which a new timestamp of change might land.\n            //\n            //         historical\n            //         timestamp                      timestamp horizon    timestamp of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` seconds away from the historical timestamp, in which case\n            //      the timestamp of change would become the limiting factor for the time horizon, which would equal\n            //      the timestamp right before the timestamp of change (since by definition the value changes at the\n            //      timestamp of change).\n            //\n            //           historical                         timestamp horizon\n            //           timestamp   timestamp of change    if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the timestamp of change to an\n            // arbitrary value, and therefore scenario a) is not currently possible. However implementing #5501 would\n            // allow for this to happen.\n            // Because historical_timestamp < self.timestamp_of_change, then timestamp_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.timestamp_of_change - 1,\n                historical_timestamp + minimum_delay,\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current timestamp. This function is only meaningful when\n    /// called in public with the current timestamp.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_timestamp: u64,\n        minimum_delay: u64,\n        timestamp_of_change: u64,\n    ) {\n        assert(timestamp_of_change >= current_timestamp + minimum_delay);\n\n        self.pre = self.get_current_at(current_timestamp);\n        self.post = new_value;\n        self.timestamp_of_change = timestamp_of_change;\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.timestamp_of_change == other.timestamp_of_change)\n    }\n}\n\nimpl<T> Empty for ScheduledValueChange<T>\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        Self { pre: T::empty(), post: T::empty(), timestamp_of_change: 0 }\n    }\n}\n"
    },
    "339": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/shared_mutable_values.nr",
      "source": "use crate::{\n    hash::poseidon2_hash,\n    shared_mutable::{\n        scheduled_delay_change::ScheduledDelayChange, scheduled_value_change::ScheduledValueChange,\n    },\n    traits::{Hash, Packable},\n    utils::arrays,\n};\nuse std::meta::derive;\n\nmod test;\n\n/// SharedMutableValues is just a wrapper around ScheduledValueChange and ScheduledDelayChange that then allows us\n/// to wrap both of these values in WithHash. WithHash allows for efficient read of values in private.\n///\n/// Note that the WithHash optimization does not work in public (due to there being no unconstrained). But we also want\n/// to be able to read the values efficiently in public and we want to be able to read each value separately. Reading\n/// the values separately is tricky because ScheduledValueChange and ScheduledDelayChange are packed together (sdc and\n/// svc.timestamp_of_change are stored in the same slot). For that reason we expose `unpack_value_change` and\n/// `unpack_delay_change` functions that can be used to extract the values from the packed representation. This\n/// is \"hacky\" but there is no way around it.\n#[derive(Eq)]\npub struct SharedMutableValues<T, let INITIAL_DELAY: u64> {\n    pub svc: ScheduledValueChange<T>,\n    pub sdc: ScheduledDelayChange<INITIAL_DELAY>,\n}\n\nimpl<T, let INITIAL_DELAY: u64> SharedMutableValues<T, INITIAL_DELAY> {\n    pub fn new(svc: ScheduledValueChange<T>, sdc: ScheduledDelayChange<INITIAL_DELAY>) -> Self {\n        SharedMutableValues { svc, sdc }\n    }\n}\n\npub fn unpack_value_change<T, let N: u32>(packed: [Field; 2 * N + 1]) -> ScheduledValueChange<T>\nwhere\n    T: Packable<N>,\n{\n    let svc_pre_packed = arrays::subarray(packed, 1);\n    let svc_post_packed = arrays::subarray(packed, N + 1);\n\n    // We first cast to u32 as the timestamp_of_change is packed into the same field as the delay change and it\n    // occupies the first 32 bits of the field.\n    let timestamp_of_change = (packed[0] as u32) as u64;\n    ScheduledValueChange::new(\n        T::unpack(svc_pre_packed),\n        T::unpack(svc_post_packed),\n        timestamp_of_change,\n    )\n}\n\npub fn unpack_delay_change<let INITIAL_DELAY: u64>(\n    packed: Field,\n) -> ScheduledDelayChange<INITIAL_DELAY> {\n    // This function expects to be called with just the first field of the packed representation, which contains sdc\n    // and svc timestamp_of_change. We'll discard the svc component.\n    let svc_timestamp_of_change = packed as u32;\n\n    let mut tmp = (packed - svc_timestamp_of_change as Field) / TWO_POW_32;\n    let sdc_timestamp_of_change = tmp as u32;\n\n    tmp = (tmp - sdc_timestamp_of_change as Field) / TWO_POW_32;\n    let sdc_post_is_some = (tmp as u1) != 0;\n\n    tmp = (tmp - sdc_post_is_some as Field) / TWO_POW_8;\n    let sdc_post_inner = tmp as u32;\n\n    tmp = (tmp - sdc_post_inner as Field) / TWO_POW_32;\n    let sdc_pre_is_some = (tmp as u1) != 0;\n\n    tmp = (tmp - sdc_pre_is_some as Field) / TWO_POW_8;\n    let sdc_pre_inner = tmp as u32;\n\n    // Note that below we cast the values to u64 as that is the default type of timestamp in the system. Us packing\n    // the values as u32 is a tech debt that is not worth tackling.\n    ScheduledDelayChange {\n        pre: if sdc_pre_is_some {\n            Option::some(sdc_pre_inner as u64)\n        } else {\n            Option::none()\n        },\n        post: if sdc_post_is_some {\n            Option::some(sdc_post_inner as u64)\n        } else {\n            Option::none()\n        },\n        timestamp_of_change: sdc_timestamp_of_change as u64,\n    }\n}\n\nglobal TWO_POW_32: Field = 2.pow_32(32);\nglobal TWO_POW_8: Field = 2.pow_32(8);\n\n// We pack to `2 * N + 1` fields because ScheduledValueChange contains T twice (hence `2 * N`) and we need one extra\n// field to store ScheduledDelayChange and the timestamp_of_change of ScheduledValueChange.\nimpl<T, let INITIAL_DELAY: u64, let N: u32> Packable<2 * N + 1> for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; 2 * N + 1] {\n        let mut result = [0; 2 * N + 1];\n\n        // We pack sdc.pre, sdc.post, sdc.timestamp_of_change and svc.timestamp_of_change into a single field as follows:\n        // [ sdc.pre_inner: u32 | sdc.pre_is_some: u8 | sdc.post_inner: u32 | sdc.post_is_some: u8 | sdc.timestamp_of_change: u32 | svc.timestamp_of_change: u32 ]\n        // Note that the code below no longer works after 2106 as by that time the timestamp will overflow u32. This is a tech debt that is not worth tackling.\n        result[0] = self.svc.timestamp_of_change as Field\n            + ((self.sdc.timestamp_of_change as Field) * 2.pow_32(32))\n            + ((self.sdc.post.is_some() as Field) * 2.pow_32(64))\n            + ((self.sdc.post.unwrap_unchecked() as Field) * 2.pow_32(72))\n            + ((self.sdc.pre.is_some() as Field) * 2.pow_32(104))\n            + ((self.sdc.pre.unwrap_unchecked() as Field) * 2.pow_32(112));\n\n        // Pack the pre and post values from ScheduledValueChange\n        let svc_pre_packed = self.svc.pre.pack();\n        let svc_post_packed = self.svc.post.pack();\n        for i in 0..N {\n            result[i + 1] = svc_pre_packed[i];\n            result[i + 1 + N] = svc_post_packed[i];\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; 2 * N + 1]) -> Self {\n        let svc = unpack_value_change::<T, N>(fields);\n        let sdc = unpack_delay_change::<INITIAL_DELAY>(fields[0]);\n        Self::new(svc, sdc)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u64, let N: u32> Hash for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn hash(self) -> Field {\n        poseidon2_hash(self.pack())\n    }\n}\n"
    },
    "342": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "356": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    #[inline_always]\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// T = type of item in BoundedVec\n// M = max length of BoundedVec\n// O = field length of T\n// O * M + 1 = total serialized length of BoundedVec<T, M> (the +1 is for length of the BoundedVec)\nimpl<T, let M: u32, let O: u32> Deserialize<O * M + 1> for BoundedVec<T, M>\nwhere\n    T: Deserialize<O>,\n{\n    #[inline_always]\n    fn deserialize(fields: [Field; O * M + 1]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[O * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; O];\n            for j in 0..O {\n                nested_fields[j] = fields[i * O + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl<let N: u32> Deserialize<0> for () {\n    fn deserialize(_fields: [Field; 0]) -> Self {\n        ()\n    }\n}\n\nimpl<T, let M: u32, let O: u32> Serialize<O * M + 1> for BoundedVec<T, M>\nwhere\n    T: Serialize<O>,\n{\n    #[inline_always]\n    fn serialize(self) -> [Field; O * M + 1] {\n        let mut fields = [0; O * M + 1];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..O {\n                fields[i * O + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[O * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    #[inline_always]\n    fn deserialize(fields: [Field; N]) -> Self {\n        str::<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "361": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as u8 as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as u16 as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as u32 as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as u64 as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "362": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T, let N: u32> Serialize<N + 1> for Option<T>\nwhere\n    T: Serialize<N>,\n{\n    fn serialize(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T, let N: u32> Deserialize<N + 1> for Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    fn deserialize(fields: [Field; N + 1]) -> Self {\n        if fields[0] == 1 {\n            let mut value_serialized: [Field; N] = std::mem::zeroed();\n            for i in 0..N {\n                value_serialized[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_serialized))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "380": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_padded_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_padded_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_padded_array::{\n    assert_sorted_transformed_i_padded_array_capped_size,\n    assert_sorted_transformed_padded_array_capped_size, validate_padded_items,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    get_split_order_hints::{get_split_order_hints_asc, SplitOrderHints},\n};\npub use assert_split_transformed_padded_arrays::assert_split_transformed_padded_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::sort_by_counter_asc;\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\n// Returns the number of consecutive elements at the start of the array for which the predicate returns false.\n// This function ensures that any element after the first matching element (predicate returns true) also matches the predicate.\npub fn array_length_until<T, let N: u32, Env>(array: [T; N], predicate: fn[Env](T) -> bool) -> u32 {\n    let mut length = 0;\n    let mut stop = false;\n    for i in 0..N {\n        if predicate(array[i]) {\n            stop = true;\n        } else {\n            assert(\n                stop == false,\n                \"matching element found after already encountering a non-matching element\",\n            );\n            length += 1;\n        }\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n// Helper function to check if an array is padded with a given value from a given index.\n// Different to padded_array_length in that it allows the elements before the given index to be the same as the padded value.\npub fn array_padded_with<T, let N: u32>(array: [T; N], from_index: u32, padded_with: T) -> bool\nwhere\n    T: Eq,\n{\n    let mut is_valid = true;\n    let mut should_check = false;\n    for i in 0..N {\n        should_check |= i == from_index;\n        is_valid &= !should_check | (array[i] == padded_with);\n    }\n    is_valid\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn test_array_length_until() {\n    let array = [11, 22, 33, 44, 55];\n    assert_eq(array_length_until(array, |x| x == 55), 4);\n    assert_eq(array_length_until(array, |x| x == 56), 5);\n    assert_eq(array_length_until(array, |x| x > 40), 3);\n    assert_eq(array_length_until(array, |x| x > 10), 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_non_consecutive_fails() {\n    let array = [1, 1, 0, 1, 0];\n    let _ = array_length_until(array, |x| x == 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_first_non_matching_fails() {\n    let array = [1, 0, 0, 0, 0];\n    let _ = array_length_until(array, |x| x == 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test]\nfn test_array_padded_with() {\n    let array = [11, 22, 33, 44, 44];\n    assert_eq(array_padded_with(array, 0, 44), false);\n    assert_eq(array_padded_with(array, 1, 44), false);\n    assert_eq(array_padded_with(array, 2, 44), false);\n    assert_eq(array_padded_with(array, 3, 44), true);\n    assert_eq(array_padded_with(array, 4, 44), true);\n    assert_eq(array_padded_with(array, 4, 33), false);\n    assert_eq(array_padded_with(array, 5, 44), true); // Index out of bounds.\n    assert_eq(array_padded_with(array, 0, 11), false);\n}\n"
    },
    "381": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO: This currently only exists to aid point compression in compress_to_blob_commitment().\n// Once compression is part of BigCurve it can either be removed or optimised to be used elsewhere.\npub fn byte_to_bits_be(byte: u8) -> [u1; 8] {\n    let mut mut_byte = byte;\n    let mut bits: [u1; 8] = [0; 8];\n    for i in 0..8 {\n        bits[7 - i] = (mut_byte & 1) as u1;\n        mut_byte >>= 1;\n    }\n    bits\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "383": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "393": {
      "path": "/home/nerses/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "414": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    history::nullifier_inclusion::ProveNullifierInclusion,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT, PRIVATE_LOG_SIZE_IN_FIELDS,\n        },\n        hash::{compute_siloed_nullifier, poseidon2_hash_with_separator},\n        traits::{Deserialize, FromField, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nglobal NOTE_COMPLETION_LOG_LENGTH: u32 = 2;\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: &mut PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Completes the partial note, creating a new note that can be used like any other UintNote. Same as `complete`\n    /// function but works from private context.\n    pub fn complete_from_private(\n        self,\n        context: &mut PrivateContext,\n        completer: AztecAddress,\n        value: u128,\n    ) {\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        // `prove_nullifier_inclusion` function expects the nullifier to be siloed (hashed with the address of\n        // the contract that emitted the nullifier) as it checks the value directly against the nullifier tree and all\n        // the nullifiers in the tree are siloed by the protocol.\n        let siloed_validity_commitment =\n            compute_siloed_nullifier(context.this_address(), validity_commitment);\n        context.get_block_header().prove_nullifier_inclusion(siloed_validity_commitment);\n\n        // We need to do two things:\n        //  - emit an unencrypted log containing the public fields (the value) via the private log channel. The\n        //  contract will later find it by searching for the expected tag (which is simply the partial note\n        //  commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_private_log(\n            self.compute_note_completion_log_padded_for_private_log(value),\n            NOTE_COMPLETION_LOG_LENGTH,\n        );\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; NOTE_COMPLETION_LOG_LENGTH] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_note_completion_log_padded_for_private_log(\n        self,\n        value: u128,\n    ) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n        let note_completion_log = self.compute_note_completion_log(value);\n        let padding = [0; PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_COMPLETION_LOG_LENGTH];\n        array_concat(note_completion_log, padding)\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nimpl ToField for PartialUintNote {\n    fn to_field(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl FromField for PartialUintNote {\n    fn from_field(field: Field) -> Self {\n        Self { commitment: field }\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n}\n"
    },
    "50": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/lib.nr",
      "source": "pub fn bytes_to_u128_limbs(bytes: [u8; 32]) -> (u128, u128) {\n    let mut high: u128 = 0;\n    let mut low: u128 = 0;\n    for i in 0..16 {\n        high = (high << 8) + (bytes[i] as u128);\n    }\n    for i in 16..32 {\n        low = (low << 8) + (bytes[i] as u128);\n    }\n    (high, low)\n}\n\npub fn u128_limbs_to_bytes(high: u128, low: u128) -> [u8; 32] {\n    let mut bytes: [u8; 32] = [0; 32];\n\n    let mut temp = high;\n    for i in 0..16 {\n        bytes[15 - i] = (temp & 0xff) as u8;\n        temp >>= 8;\n    }\n\n    temp = low;\n    for i in 0..16 {\n        bytes[31 - i] = (temp & 0xff) as u8;\n        temp >>= 8;\n    }\n\n    bytes\n}\n"
    },
    "51": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/main.nr",
      "source": "//     @@                                    @@@\n//    @@@\n//    @@@        @@   @@@@      @@@@@         @     @    @@@@@\n//  @@@@@@@@@   @@@@@@      @@@@    @@@@@    @@@   @@@@@@    @@@@\n//    @@@       @@@       @@@           @@@  @@@   @@@          @@@\n//    @@@       @@@       @@@           @@@  @@@   @@@          @@@\n//    @@@       @@@       @@@           @@@  @@@   @@@          @@@\n//     @@@      @@@        @@@@       @@@@@  @@@   @@@          @@@\n//       @@@@@  @@@           @@@@@@@@@ @@@  @@@   @@@          @@@\n\nmod lib;\nmod types;\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract Train {\n    use crate::lib::{bytes_to_u128_limbs, u128_limbs_to_bytes};\n    use crate::types::events::{\n        TokenCommitted, TokenLockAdded, TokenLockedFirst, TokenLockedSecond, TokenRedeemed,\n        TokenRefunded,\n    };\n    use dep::aztec::messages::logs::note::encode_and_encrypt_note;\n    use dep::aztec::protocol_types::traits::{Deserialize, Packable, Serialize};\n    use dep::aztec::state_vars::{private_immutable::PrivateImmutable, SharedMutable};\n    use dep::sha256;\n    use dep::token::Token;\n    use aztec::macros::{\n        functions::{initializer, internal, private, public, utility, view},\n        notes::note,\n        storage::storage,\n    };\n    use aztec::prelude::{AztecAddress, Map};\n    use std::meta::derive;\n\n    #[note]\n    #[derive(Eq)]\n    struct HTLC_Private {\n        owner: AztecAddress,\n        randomness: Field,\n    }\n    #[derive(Eq, Packable, Serialize, Deserialize)]\n    pub struct HTLC_Public {\n        src_receiver: AztecAddress,\n        amount: u128,\n        token: AztecAddress,\n        hashlock_high: u128,\n        hashlock_low: u128,\n        secret_high: u128,\n        secret_low: u128,\n        ownership_hash_high: u128,\n        ownership_hash_low: u128,\n        timelock: u64,\n        claimed: u8,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor() {}\n\n    #[storage]\n    struct Storage<Context> {\n        contracts_private: Map<Field, PrivateImmutable<HTLC_Private, Context>, Context>,\n        contracts_public: Map<Field, SharedMutable<HTLC_Public, 1, Context>, Context>,\n    }\n\n    #[private]\n    fn commit_private_user(\n        Id: Field,\n        src_receiver: AztecAddress,\n        timelock: u64,\n        token: AztecAddress,\n        amount: u128,\n        dst_chain: str<30>,\n        dst_asset: str<30>,\n        dst_address: str<90>,\n        randomness: Field,\n    ) {\n        assert(amount > 0, \"FundsNotSent\");\n\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address())\n            .commit_public_user(\n                dst_chain,\n                dst_asset,\n                dst_address,\n                Id,\n                src_receiver,\n                timelock,\n                token,\n                amount,\n            )\n            .enqueue(&mut context);\n\n        let htlc_note = HTLC_Private { owner: context.msg_sender(), randomness: randomness };\n        storage.contracts_private.at(Id).initialize(htlc_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        Token::at(token)\n            .transfer_to_public(context.msg_sender(), context.this_address(), amount, randomness)\n            .call(&mut context);\n    }\n\n    #[internal]\n    #[public]\n    fn commit_public_user(\n        dst_chain: str<30>,\n        dst_asset: str<30>,\n        dst_address: str<90>,\n        Id: Field,\n        src_receiver: AztecAddress,\n        timelock: u64,\n        token: AztecAddress,\n        amount: u128,\n    ) {\n        let htlc_public_current = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public_current.amount == 0, \"HTLCAlreadyExists\");\n        assert(context.timestamp() + 900 < timelock, \"InvalidTimelock\");\n        let htlc_public = HTLC_Public {\n            src_receiver: src_receiver,\n            amount: amount,\n            token: token,\n            hashlock_high: 0 as u128,\n            hashlock_low: 0 as u128,\n            secret_high: 0 as u128,\n            secret_low: 0 as u128,\n            ownership_hash_high: 0 as u128,\n            ownership_hash_low: 0 as u128,\n            timelock: timelock,\n            claimed: 1 as u8,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(htlc_public);\n        let log_msg = TokenCommitted {\n            Id: Id,\n            amount: amount,\n            token: token,\n            timelock: timelock,\n            src_receiver: src_receiver,\n            dst_chain: dst_chain,\n            dst_asset: dst_asset,\n            dst_address: dst_address,\n        };\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn add_lock_private_user(Id: Field, hashlock: [u8; 32], timelock: u64) {\n        let htlc_private = storage.contracts_private.at(Id).get_note();\n        assert(htlc_private.owner == context.msg_sender(), \"NoAllowance\");\n\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).add_lock_public_user(Id, hashlock, timelock).enqueue(\n            &mut context,\n        );\n    }\n\n    #[internal]\n    #[public]\n    fn add_lock_public_user(Id: Field, hashlock: [u8; 32], timelock: u64) {\n        assert(context.timestamp() + 900 < timelock, \"InvalidTimelock\");\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        assert(htlc_public.hashlock_high == (0 as u128), \"HashlockAlreadySet\");\n        assert(htlc_public.hashlock_low == (0 as u128), \"HashlockAlreadySet\");\n\n        let hashlock_tuple = bytes_to_u128_limbs(hashlock);\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: hashlock_tuple.0,\n            hashlock_low: hashlock_tuple.1,\n            secret_high: htlc_public.secret_high,\n            secret_low: htlc_public.secret_low,\n            ownership_hash_high: htlc_public.ownership_hash_high,\n            ownership_hash_low: htlc_public.ownership_hash_low,\n            timelock: timelock,\n            claimed: htlc_public.claimed,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n        let log_msg = TokenLockAdded { Id, hashlock, timelock };\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn refund_private(Id: Field) {\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).refund_public(Id).enqueue(&mut context);\n\n        let htlc_private = storage.contracts_private.at(Id).get_note();\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n\n        let partial_note = Token::at(htlc_public.token)\n            .prepare_private_balance_increase(htlc_private.owner, htlc_private.owner)\n            .call(&mut context);\n        Token::at(htlc_public.token)\n            .finalize_transfer_to_private(htlc_public.amount, partial_note)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn refund_public(Id: Field) {\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        assert(htlc_public.timelock < context.timestamp(), \"NotPassedTimelock\");\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: htlc_public.hashlock_high,\n            hashlock_low: htlc_public.hashlock_low,\n            secret_high: htlc_public.secret_high,\n            secret_low: htlc_public.secret_low,\n            ownership_hash_high: htlc_public.ownership_hash_high,\n            ownership_hash_low: htlc_public.ownership_hash_low,\n            timelock: htlc_public.timelock,\n            claimed: 2 as u8,\n        };\n\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n        let log_msg = TokenRefunded { Id };\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn lock_private_solver(\n        Id: Field,\n        hashlock: [u8; 32],\n        amount: u128,\n        ownership_hash: [u8; 32],\n        timelock: u64,\n        token: AztecAddress,\n        randomness: Field,\n        dst_chain: str<30>,\n        dst_asset: str<30>,\n        dst_address: str<90>,\n    ) {\n        assert(amount > 0, \"FundsNotSent\");\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address())\n            .lock_public_solver(\n                Id,\n                hashlock,\n                ownership_hash,\n                amount,\n                token,\n                timelock,\n                dst_chain,\n                dst_asset,\n                dst_address,\n            )\n            .enqueue(&mut context);\n\n        let htlc_note = HTLC_Private { owner: context.msg_sender(), randomness: randomness };\n        storage.contracts_private.at(Id).initialize(htlc_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        Token::at(token)\n            .transfer_to_public(context.msg_sender(), context.this_address(), amount, randomness)\n            .call(&mut context);\n    }\n\n    #[internal]\n    #[public]\n    fn lock_public_solver(\n        Id: Field,\n        hashlock: [u8; 32],\n        ownership_hash: [u8; 32],\n        amount: u128,\n        token: AztecAddress,\n        timelock: u64,\n        dst_chain: str<30>,\n        dst_asset: str<30>,\n        dst_address: str<90>,\n    ) {\n        let htlc_public_current = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public_current.amount == 0, \"HTLCAlreadyExists\");\n        assert(context.timestamp() + 1800 < timelock, \"InvalidTimelock\");\n        let hashlock_tuple = bytes_to_u128_limbs(hashlock);\n        let ownership_hash_tuple = bytes_to_u128_limbs(ownership_hash);\n        let htlc_public = HTLC_Public {\n            src_receiver: AztecAddress::zero(),\n            amount: amount,\n            token: token,\n            hashlock_high: hashlock_tuple.0,\n            hashlock_low: hashlock_tuple.1,\n            secret_high: 0 as u128,\n            secret_low: 0 as u128,\n            ownership_hash_high: ownership_hash_tuple.0,\n            ownership_hash_low: ownership_hash_tuple.1,\n            timelock: timelock,\n            claimed: 1 as u8,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(htlc_public);\n\n        let log_msg_1 = TokenLockedFirst {\n            Id: Id,\n            amount: amount,\n            token: token,\n            timelock: timelock,\n            src_receiver: AztecAddress::zero(),\n            dst_chain: dst_chain,\n            dst_asset: dst_asset,\n            dst_address: dst_address,\n        };\n\n        let log_msg_2 =\n            TokenLockedSecond { Id: Id, hashlock: hashlock, ownership_hash: ownership_hash };\n\n        context.emit_public_log(log_msg_1.pack());\n        context.emit_public_log(log_msg_2.pack());\n    }\n\n    #[private]\n    fn redeem_private(Id: Field, secret: [u8; 32], ownership_key: [u8; 32]) {\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).redeem_public(Id, secret, ownership_key).enqueue(\n            &mut context,\n        );\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        if (htlc_public.ownership_hash_high == 0 as u128) {\n            if htlc_public.ownership_hash_low == 0 as u128 {\n                let partial_note = Token::at(htlc_public.token)\n                    .prepare_private_balance_increase(\n                        htlc_public.src_receiver,\n                        htlc_public.src_receiver,\n                    )\n                    .call(&mut context);\n                Token::at(htlc_public.token)\n                    .finalize_transfer_to_private(htlc_public.amount, partial_note)\n                    .enqueue(&mut context);\n            }\n        } else {\n            let partial_note = Token::at(htlc_public.token)\n                .prepare_private_balance_increase(context.msg_sender(), context.msg_sender())\n                .call(&mut context);\n            Token::at(htlc_public.token)\n                .finalize_transfer_to_private(htlc_public.amount, partial_note)\n                .enqueue(&mut context);\n        }\n    }\n\n    #[public]\n    #[internal]\n    fn redeem_public(Id: Field, secret: [u8; 32], ownership_key: [u8; 32]) {\n        let mut htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.amount > 0, \"HTLCNotExists\"); // If it doesn't exist, all parameters will default to zero values.\n        let hashed_secret = sha256::sha256_var(secret, secret.len() as u64);\n        let hashed_secret_tuple = bytes_to_u128_limbs(hashed_secret);\n        assert(htlc_public.hashlock_high == hashed_secret_tuple.0, \"HashlockNotMatch\");\n        assert(htlc_public.hashlock_low == hashed_secret_tuple.1, \"HashlockNotMatch\");\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n\n        if (htlc_public.ownership_hash_high != 0 as u128) {\n            if htlc_public.ownership_hash_low != 0 as u128 {\n                let ownership_key_hashed =\n                    sha256::sha256_var(ownership_key, ownership_key.len() as u64);\n                let ownership_key_tuple = bytes_to_u128_limbs(ownership_key_hashed);\n                assert(htlc_public.ownership_hash_high == ownership_key_tuple.0, \"NotAnOwner\");\n                assert(htlc_public.ownership_hash_low == ownership_key_tuple.1, \"NotAnOwner\");\n            }\n        }\n\n        let secret_limbs = bytes_to_u128_limbs(secret);\n\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: htlc_public.hashlock_high,\n            hashlock_low: htlc_public.hashlock_low,\n            secret_high: secret_limbs.0,\n            secret_low: secret_limbs.1,\n            ownership_hash_high: htlc_public.ownership_hash_high,\n            ownership_hash_low: htlc_public.ownership_hash_low,\n            timelock: htlc_public.timelock,\n            claimed: 3 as u8,\n        };\n\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n\n        let log_msg = TokenRedeemed {\n            Id: Id,\n            hashlock: u128_limbs_to_bytes(htlc_public.hashlock_high, htlc_public.hashlock_low),\n            secret: secret,\n        };\n\n        context.emit_public_log(log_msg.pack());\n    }\n\n    // This utility function should be invoked by the frontend before each function call\n    // where the existence or non-existence of an HTLC is a critical security check.\n    #[utility]\n    unconstrained fn is_contract_initialized(Id: Field) -> bool {\n        storage.contracts_private.at(Id).is_initialized()\n    }\n\n    #[view]\n    #[public]\n    fn get_htlc_public(key: Field) -> pub HTLC_Public {\n        storage.contracts_public.at(key).get_current_value()\n    }\n}\n"
    },
    "52": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/types/events.nr",
      "source": "use crate::lib::{bytes_to_u128_limbs, u128_limbs_to_bytes};\nuse dep::aztec::prelude::AztecAddress;\nuse dep::aztec::protocol_types::traits::{Packable, Serialize};\n\n#[derive(Serialize)]\npub struct TokenCommitted {\n    pub Id: Field,\n    pub amount: u128,\n    pub token: AztecAddress,\n    pub timelock: u64,\n    pub src_receiver: AztecAddress,\n    pub dst_chain: str<30>,\n    pub dst_asset: str<30>,\n    pub dst_address: str<90>,\n}\n\nimpl Packable<11> for TokenCommitted {\n    fn pack(self) -> [Field; 11] {\n        let zero: Field = 0;\n        let mut out = [zero; 11];\n        out[0] = 0x7A3F2B1C;\n        out[1] = self.Id;\n        out[2] = self.amount as Field;\n        out[3] = self.token.inner;\n        out[4] = self.timelock as Field;\n        out[5] = self.src_receiver.inner;\n\n        let dst_chain_byte_array = self.dst_chain.as_bytes();\n        let mut dst_chain_byte_array_filled = [0 as u8; 30];\n        for i in 0..dst_chain_byte_array.len() {\n            dst_chain_byte_array_filled[i] = dst_chain_byte_array[i];\n        }\n        out[6] = Field::from_be_bytes::<30>(dst_chain_byte_array_filled);\n\n        let dst_asset_byte_array = self.dst_asset.as_bytes();\n        let mut dst_asset_byte_array_filled = [0 as u8; 30];\n        for i in 0..dst_asset_byte_array.len() {\n            dst_asset_byte_array_filled[i] = dst_asset_byte_array[i];\n        }\n        out[7] = Field::from_be_bytes::<30>(dst_asset_byte_array_filled);\n\n        let dst_address_byte_array = self.dst_address.as_bytes();\n        let mut dst_address_byte_array_filled_1 = [0 as u8; 30];\n        let mut dst_address_byte_array_filled_2 = [0 as u8; 30];\n        let mut dst_address_byte_array_filled_3 = [0 as u8; 30];\n\n        for i in 0..30 {\n            dst_address_byte_array_filled_1[i] = dst_address_byte_array[i];\n            dst_address_byte_array_filled_2[i] = dst_address_byte_array[i + 30];\n            dst_address_byte_array_filled_3[i] = dst_address_byte_array[i + 60];\n        }\n\n        out[8] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_1);\n        out[9] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_2);\n        out[10] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_3);\n        out\n    }\n\n    fn unpack(fields: [Field; 11]) -> Self {\n        assert(false, \"unpack not implemented\");\n        TokenCommitted {\n            Id: fields[1] as Field,\n            amount: 0 as u128,\n            token: AztecAddress::zero(),\n            timelock: 0 as u64,\n            src_receiver: AztecAddress::zero(),\n            dst_chain: \"000000000000000000000000000000\",\n            dst_asset: \"000000000000000000000000000000\",\n            dst_address: \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n        }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenLockAdded {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub timelock: u64,\n}\n\nimpl Packable<5> for TokenLockAdded {\n    fn pack(self) -> [Field; 5] {\n        let mut out = [0 as Field; 5];\n        out[0] = 0xC1D4E792;\n        out[1] = self.Id;\n\n        let (hashlock_high, hashlock_low) = bytes_to_u128_limbs(self.hashlock);\n        out[2] = hashlock_high as Field;\n        out[3] = hashlock_low as Field;\n        out[4] = self.timelock as Field;\n        out\n    }\n\n    fn unpack(fields: [Field; 5]) -> Self {\n        let Id = fields[1];\n        let hashlock = u128_limbs_to_bytes(fields[2] as u128, fields[3] as u128);\n        let timelock = fields[4] as u64;\n        TokenLockAdded { Id, hashlock, timelock }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenRefunded {\n    pub Id: Field,\n}\n\nimpl Packable<2> for TokenRefunded {\n    fn pack(self) -> [Field; 2] {\n        let mut out = [0 as Field; 2];\n        out[0] = 0x2D17C6B8;\n        out[1] = self.Id;\n        out\n    }\n\n    fn unpack(fields: [Field; 2]) -> Self {\n        let Id = fields[1];\n        TokenRefunded { Id }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenRedeemed {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub secret: [u8; 32],\n}\n\nimpl Packable<6> for TokenRedeemed {\n    fn pack(self) -> [Field; 6] {\n        let mut out = [0 as Field; 6];\n        out[0] = 0x4F8B9A3E;\n        out[1] = self.Id;\n\n        let (hashlock_high, hashlock_low) = bytes_to_u128_limbs(self.hashlock);\n        out[2] = hashlock_high as Field;\n        out[3] = hashlock_low as Field;\n\n        let (secret_high, secret_low) = bytes_to_u128_limbs(self.secret);\n        out[4] = secret_high as Field;\n        out[5] = secret_low as Field;\n\n        out\n    }\n\n    fn unpack(fields: [Field; 6]) -> Self {\n        let Id = fields[1];\n        let hashlock = u128_limbs_to_bytes(fields[2] as u128, fields[3] as u128);\n        let secret = u128_limbs_to_bytes(fields[4] as u128, fields[5] as u128);\n\n        TokenRedeemed { Id, hashlock, secret }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenLockedFirst {\n    pub Id: Field,\n    pub amount: u128,\n    pub token: AztecAddress,\n    pub timelock: u64,\n    pub src_receiver: AztecAddress,\n    pub dst_chain: str<30>,\n    pub dst_asset: str<30>,\n    pub dst_address: str<90>,\n}\n\nimpl Packable<11> for TokenLockedFirst {\n    fn pack(self) -> [Field; 11] {\n        let zero: Field = 0;\n        let mut out = [zero; 11];\n        out[0] = 0x9E5A4F03;\n        out[1] = self.Id;\n        out[2] = self.amount as Field;\n        out[3] = self.token.inner;\n        out[4] = self.timelock as Field;\n        out[5] = self.src_receiver.inner;\n\n        let dst_chain_byte_array = self.dst_chain.as_bytes();\n        let mut dst_chain_byte_array_filled = [0 as u8; 30];\n        for i in 0..dst_chain_byte_array.len() {\n            dst_chain_byte_array_filled[i] = dst_chain_byte_array[i];\n        }\n        out[6] = Field::from_be_bytes::<30>(dst_chain_byte_array_filled);\n\n        let dst_asset_byte_array = self.dst_asset.as_bytes();\n        let mut dst_asset_byte_array_filled = [0 as u8; 30];\n        for i in 0..dst_asset_byte_array.len() {\n            dst_asset_byte_array_filled[i] = dst_asset_byte_array[i];\n        }\n        out[7] = Field::from_be_bytes::<30>(dst_asset_byte_array_filled);\n\n        let dst_address_byte_array = self.dst_address.as_bytes();\n        let mut dst_address_byte_array_filled_1 = [0 as u8; 30];\n        let mut dst_address_byte_array_filled_2 = [0 as u8; 30];\n        let mut dst_address_byte_array_filled_3 = [0 as u8; 30];\n\n        for i in 0..30 {\n            dst_address_byte_array_filled_1[i] = dst_address_byte_array[i];\n            dst_address_byte_array_filled_2[i] = dst_address_byte_array[i + 30];\n            dst_address_byte_array_filled_3[i] = dst_address_byte_array[i + 60];\n        }\n\n        out[8] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_1);\n        out[9] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_2);\n        out[10] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_3);\n        out\n    }\n\n    fn unpack(fields: [Field; 11]) -> Self {\n        assert(false, \"unpack not implemented\");\n        TokenLockedFirst {\n            Id: fields[1] as Field,\n            amount: 0 as u128,\n            token: AztecAddress::zero(),\n            timelock: 0 as u64,\n            src_receiver: AztecAddress::zero(),\n            dst_chain: \"000000000000000000000000000000\",\n            dst_asset: \"000000000000000000000000000000\",\n            dst_address: \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n        }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenLockedSecond {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub ownership_hash: [u8; 32],\n}\n\nimpl Packable<6> for TokenLockedSecond {\n    fn pack(self) -> [Field; 6] {\n        let mut out = [0 as Field; 6];\n        out[0] = 0x9E5A4F03;\n        out[1] = self.Id;\n\n        let (hashlock_high, hashlock_low) = bytes_to_u128_limbs(self.hashlock);\n        out[2] = hashlock_high as Field;\n        out[3] = hashlock_low as Field;\n\n        let (ownership_hash_high, ownership_hash_low) = bytes_to_u128_limbs(self.ownership_hash);\n        out[4] = ownership_hash_high as Field;\n        out[5] = ownership_hash_low as Field;\n\n        out\n    }\n\n    fn unpack(fields: [Field; 6]) -> Self {\n        assert(false, \"unpack not implemented\");\n        TokenLockedSecond {\n            Id: fields[1] as Field,\n            hashlock: [0 as u8; 32],\n            ownership_hash: [0 as u8; 32],\n        }\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "63": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "64": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{\n    gas::GasOpts, private_context::PrivateContext, public_context::PublicContext,\n    returns_hash::ReturnsHash,\n};\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\nuse crate::test::helpers::cheatcodes;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateStaticCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<N>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateStaticCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateStaticVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateStaticVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PublicCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) -> T {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<N>())\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<N>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T, let N: u32> PublicVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T, let N: u32> PublicStaticCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<N>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicStaticCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T, let N: u32> PublicStaticVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicStaticVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for UtilityCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T, let N: u32> UtilityCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n\n// UtilityVoidCallInterface\n\npub struct UtilityVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for UtilityVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T, let N: u32> UtilityVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n\npub trait TXEPublicCallInterface<T, let N: u32> {\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field);\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicStaticCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicStaticVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\npub trait TXEPrivateCallInterface<T, let N: u32> {\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field);\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n\n        let (_end_side_effect_counter, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns: T = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let (_end_side_effect_counter, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateStaticCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let (_, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateStaticVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let (_, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\npub trait TXEUtilityCallInterface<T, let N: u32> {\n    unconstrained fn call_with_txe(self) -> T;\n}\n\nimpl<let M: u32, T, let N: u32> TXEUtilityCallInterface<T, N> for UtilityCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self) -> T {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let returns_hash = crate::oracle::simulate_utility_function::simulate_utility_function(\n            self.get_contract_address(),\n            self.get_selector(),\n            args_hash,\n        );\n\n        let returns: T = ReturnsHash::new(returns_hash).get_preimage();\n        returns\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEUtilityCallInterface<T, N> for UtilityVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self) -> T {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let returns_hash = crate::oracle::simulate_utility_function::simulate_utility_function(\n            self.get_contract_address(),\n            self.get_selector(),\n            args_hash,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n        returns\n    }\n}\n"
    },
    "71": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        include_by_timestamp::IncludeByTimestamp,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: IncludeByTimestamp,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: IncludeByTimestamp::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp =\n            IncludeByTimestamp::min_with_u64(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: IncludeByTimestamp::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "72": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_U32_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> u128 {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> u128 {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "73": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n\n    pub fn get_preimage_and_assert_empty<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n        assert_eq(self.hash, 0);\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "74": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_timestamp, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let contract_address = get_contract_address();\n        let version = get_version();\n        let chain_id = get_chain_id();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "77": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    // TODO(#2707): Consider making this a u64 as we already cast this to that when encoding the message. This would decrease\n    // the likelihood of collisions without any extra cost.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "79": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n    // +1 to length to account for the separator\n    let nonzero_length = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, nonzero_length)\n    // NOTE: we use poseidon2_hash_subarray here because we want to hash the bytecode only up to\n    // its nonzero length. We do NOT want to include a `1` at the end to indicate \"variable length\",\n    // and we want to enforce that all trailing elements are zero.\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "91": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(self.global_variables.block_number, public_data_tree_index)\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "94": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n"
    },
    "95": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
      "source": "use std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // Safety: we use the randomness to preserve the privacy of both the sender and recipient via encryption, so a\n    // malicious sender could use non-random values to reveal the plaintext. But they already know it themselves anyway,\n    // and so the recipient already trusts them to not disclose this information. We can therefore assume that the\n    // sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // TODO(#12757): compute the key pair without constraining eph_sk twice (once in from_field, once in the black box\n    // called by fixed_base_scalar_mul).\n    let eph_sk = EmbeddedCurveScalar::from_field(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
    },
    "96": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    }
  }
}
