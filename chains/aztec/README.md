# Interacting with TRAIN Protocol on Aztec

## 1. Setup

Run the setup script:

```bash
npx tsx setup.ts
```

* Deploys PXE1 (user), PXE2 (solver), and PXE3 (deployer)
* Registers FPC in each PXE, creates wallets
* Deployer (PXE3) deploys the token and sends 50% to PXE1, 50% to PXE2

---

## 2. Contract Deployment

Deploy the TRAIN Protocol contract:

```bash
npx tsx deploy.ts
```

* Deploys the TRAIN Protocol contract
* Registers it as a contract in all 3 PXEs

---

## 3. User Swaps Funds: Aztec → Destination Chain

### User: Commit Funds

```bash
npx tsx commit.ts
```

* Wallet: Uses PXE1 by default
* Config: Adjust call parameters in `scripts/commit.ts` (around line 58)
* Action: Commits funds to the TRAIN Protocol contract
* Output: On success, writes `commitId` into `data.json`

### Solver: Lock Funds

* Solver monitors publicly available log data (excluding user identity info) to confirm Aztec commitment succeeded
* Once confirmed, locks corresponding funds on the destination chain

### User: Add Locks

```bash
npx tsx addLock.ts
```

* Attaches a **hashlock** and **timelock** to the existing commitment
* Hashlock: Must *exactly* match the one the solver used on the destination chain—do not use a new value
* In `scripts/addLock.ts` (around line 69), replace the autogenerated hashlock with the agreed value
* Timelock: Set it *shorter* than the solver’s timelock on the destination chain

### Solver: Redeem Funds for User

```bash
npx tsx redeem.ts solver
```

* Calls the TRAIN Protocol’s redeem function on Aztec for the user to receive funds
* Required:

  * The preimage of the hashlock (the secret)
  * The correct commitment ID (from `data.json`)
  * An ownership\_key (can be any dummy value)
* If the solver doesn’t perform this, user can run the same command to claim funds—this reveals the secret on the destination chain
* Because commitment IDs are identical on both chains, user can retrieve all details via the `getHTLCDetails()` getter

### Refund: Expired Funds

```bash
npx tsx refund.ts user
```

* At any time (after timelock passes), refund a commitment by supplying the correct commitment ID

---

## 4. User Swaps Funds: Source Chain → Aztec

### User: Commit Funds

* User commits funds on the source chain, including in the `dst_address` the SHA-256 hash of a secret (called ownership\_key)
* This key is used later to prove the funds were locked specifically for them (only they know the preimage)

### Solver: Lock Funds

```bash
npx tsx lock.ts
```

* In Aztec, solver locks funds after monitoring the source chain and taking data from logs
* Passes as `ownership_hash` the data from `dst_address`
* In scripts, replace the autogenerated value with the correct one to match the source chain exactly
* Everything else is the same for every chain

### User: Add Locks

* On the source chain, after confirming the solver locked funds using their ownership\_hash (from Aztec logs), the user can prove funds were reserved for them
* User calls addLocks on the source chain with the same hashlock

### Solver: Redeems

* On the source chain, solver claims their funds, revealing the secret preimage used for the hashlock

### User: Redeems

```bash
npx tsx redeem.ts user
```

* User monitors the source chain until the solver’s secret (preimage) is revealed
* Then runs the redeem script on Aztec, supplying:

  * The commitment ID
  * The ownership\_key (`dst_address = sha256(ownership_key)`)
  * The secret (preimage of the hashlock)
* Ensure `redeem.ts` is updated to accept these three parameters in its call signature

Refunds follow the same procedure previously described for swaps executed in the opposite direction.

```bash
npx tsx refund.ts solver
```
---

## 5. Helper Functions

The `utils.ts` module centralizes all routine interactions with the TRAIN Protocol:

* Spin up and configure PXE environments
* Generate commitment IDs, secrets, and hashlocks
* Invoke contract getters to check commitment status
* Monitor Aztec public logs
* Artificially trigger transactions to simulate block passage

